// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"b5D61":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "eaa3e1f3ef63603e";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"fLDlt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _olCss = require("ol/ol.css");
var _olMapboxStyle = require("ol-mapbox-style");
var _olMapboxStyleDefault = parcelHelpers.interopDefault(_olMapboxStyle);
(0, _olMapboxStyleDefault.default)("map", "https://vectortiles.kartverket.no/styles/test/landtopo/style.json");

},{"ol/ol.css":"2wn4y","ol-mapbox-style":"9sE6B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2wn4y":[function() {},{}],"9sE6B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "apply", ()=>apply);
parcelHelpers.export(exports, "applyBackground", ()=>applyBackground);
parcelHelpers.export(exports, "applyStyle", ()=>applyStyle);
parcelHelpers.export(exports, "default", ()=>apply);
parcelHelpers.export(exports, "getFeatureState", ()=>getFeatureState);
parcelHelpers.export(exports, "getLayer", ()=>getLayer);
parcelHelpers.export(exports, "getLayers", ()=>getLayers);
parcelHelpers.export(exports, "getSource", ()=>getSource);
parcelHelpers.export(exports, "recordStyleLayer", ()=>recordStyleLayer);
parcelHelpers.export(exports, "renderTransparent", ()=>renderTransparent);
parcelHelpers.export(exports, "setFeatureState", ()=>setFeatureState);
parcelHelpers.export(exports, "stylefunction", ()=>stylefunction);
var _circleJs = require("ol/style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("ol/style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("ol/style/Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _featureJs = require("ol/render/Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _strokeJs = require("ol/style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("ol/style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("ol/style/Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
var _canvasJs = require("ol/render/canvas.js");
var _tileurlfunctionJs = require("ol/tileurlfunction.js");
var _geoJSONJs = require("ol/format/GeoJSON.js");
var _geoJSONJsDefault = parcelHelpers.interopDefault(_geoJSONJs);
var _imageJs = require("ol/layer/Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _mvtJs = require("ol/format/MVT.js");
var _mvtJsDefault = parcelHelpers.interopDefault(_mvtJs);
var _mapJs = require("ol/Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _rasterJs = require("ol/source/Raster.js");
var _rasterJsDefault = parcelHelpers.interopDefault(_rasterJs);
var _tileGridJs = require("ol/tilegrid/TileGrid.js");
var _tileGridJsDefault = parcelHelpers.interopDefault(_tileGridJs);
var _tileJSONJs = require("ol/source/TileJSON.js");
var _tileJSONJsDefault = parcelHelpers.interopDefault(_tileJSONJs);
var _tileJs = require("ol/layer/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _vectorJs = require("ol/layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("ol/source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _vectorTileJs = require("ol/layer/VectorTile.js");
var _vectorTileJsDefault = parcelHelpers.interopDefault(_vectorTileJs);
var _vectorTileJs1 = require("ol/source/VectorTile.js");
var _vectorTileJsDefault1 = parcelHelpers.interopDefault(_vectorTileJs1);
var _viewJs = require("ol/View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _loadingstrategyJs = require("ol/loadingstrategy.js");
var _tilegridJs = require("ol/tilegrid.js");
var _projJs = require("ol/proj.js");
var csscolorparser = {};
var parseCSSColor_1;
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
    "transparent": [
        0,
        0,
        0,
        0
    ],
    "aliceblue": [
        240,
        248,
        255,
        1
    ],
    "antiquewhite": [
        250,
        235,
        215,
        1
    ],
    "aqua": [
        0,
        255,
        255,
        1
    ],
    "aquamarine": [
        127,
        255,
        212,
        1
    ],
    "azure": [
        240,
        255,
        255,
        1
    ],
    "beige": [
        245,
        245,
        220,
        1
    ],
    "bisque": [
        255,
        228,
        196,
        1
    ],
    "black": [
        0,
        0,
        0,
        1
    ],
    "blanchedalmond": [
        255,
        235,
        205,
        1
    ],
    "blue": [
        0,
        0,
        255,
        1
    ],
    "blueviolet": [
        138,
        43,
        226,
        1
    ],
    "brown": [
        165,
        42,
        42,
        1
    ],
    "burlywood": [
        222,
        184,
        135,
        1
    ],
    "cadetblue": [
        95,
        158,
        160,
        1
    ],
    "chartreuse": [
        127,
        255,
        0,
        1
    ],
    "chocolate": [
        210,
        105,
        30,
        1
    ],
    "coral": [
        255,
        127,
        80,
        1
    ],
    "cornflowerblue": [
        100,
        149,
        237,
        1
    ],
    "cornsilk": [
        255,
        248,
        220,
        1
    ],
    "crimson": [
        220,
        20,
        60,
        1
    ],
    "cyan": [
        0,
        255,
        255,
        1
    ],
    "darkblue": [
        0,
        0,
        139,
        1
    ],
    "darkcyan": [
        0,
        139,
        139,
        1
    ],
    "darkgoldenrod": [
        184,
        134,
        11,
        1
    ],
    "darkgray": [
        169,
        169,
        169,
        1
    ],
    "darkgreen": [
        0,
        100,
        0,
        1
    ],
    "darkgrey": [
        169,
        169,
        169,
        1
    ],
    "darkkhaki": [
        189,
        183,
        107,
        1
    ],
    "darkmagenta": [
        139,
        0,
        139,
        1
    ],
    "darkolivegreen": [
        85,
        107,
        47,
        1
    ],
    "darkorange": [
        255,
        140,
        0,
        1
    ],
    "darkorchid": [
        153,
        50,
        204,
        1
    ],
    "darkred": [
        139,
        0,
        0,
        1
    ],
    "darksalmon": [
        233,
        150,
        122,
        1
    ],
    "darkseagreen": [
        143,
        188,
        143,
        1
    ],
    "darkslateblue": [
        72,
        61,
        139,
        1
    ],
    "darkslategray": [
        47,
        79,
        79,
        1
    ],
    "darkslategrey": [
        47,
        79,
        79,
        1
    ],
    "darkturquoise": [
        0,
        206,
        209,
        1
    ],
    "darkviolet": [
        148,
        0,
        211,
        1
    ],
    "deeppink": [
        255,
        20,
        147,
        1
    ],
    "deepskyblue": [
        0,
        191,
        255,
        1
    ],
    "dimgray": [
        105,
        105,
        105,
        1
    ],
    "dimgrey": [
        105,
        105,
        105,
        1
    ],
    "dodgerblue": [
        30,
        144,
        255,
        1
    ],
    "firebrick": [
        178,
        34,
        34,
        1
    ],
    "floralwhite": [
        255,
        250,
        240,
        1
    ],
    "forestgreen": [
        34,
        139,
        34,
        1
    ],
    "fuchsia": [
        255,
        0,
        255,
        1
    ],
    "gainsboro": [
        220,
        220,
        220,
        1
    ],
    "ghostwhite": [
        248,
        248,
        255,
        1
    ],
    "gold": [
        255,
        215,
        0,
        1
    ],
    "goldenrod": [
        218,
        165,
        32,
        1
    ],
    "gray": [
        128,
        128,
        128,
        1
    ],
    "green": [
        0,
        128,
        0,
        1
    ],
    "greenyellow": [
        173,
        255,
        47,
        1
    ],
    "grey": [
        128,
        128,
        128,
        1
    ],
    "honeydew": [
        240,
        255,
        240,
        1
    ],
    "hotpink": [
        255,
        105,
        180,
        1
    ],
    "indianred": [
        205,
        92,
        92,
        1
    ],
    "indigo": [
        75,
        0,
        130,
        1
    ],
    "ivory": [
        255,
        255,
        240,
        1
    ],
    "khaki": [
        240,
        230,
        140,
        1
    ],
    "lavender": [
        230,
        230,
        250,
        1
    ],
    "lavenderblush": [
        255,
        240,
        245,
        1
    ],
    "lawngreen": [
        124,
        252,
        0,
        1
    ],
    "lemonchiffon": [
        255,
        250,
        205,
        1
    ],
    "lightblue": [
        173,
        216,
        230,
        1
    ],
    "lightcoral": [
        240,
        128,
        128,
        1
    ],
    "lightcyan": [
        224,
        255,
        255,
        1
    ],
    "lightgoldenrodyellow": [
        250,
        250,
        210,
        1
    ],
    "lightgray": [
        211,
        211,
        211,
        1
    ],
    "lightgreen": [
        144,
        238,
        144,
        1
    ],
    "lightgrey": [
        211,
        211,
        211,
        1
    ],
    "lightpink": [
        255,
        182,
        193,
        1
    ],
    "lightsalmon": [
        255,
        160,
        122,
        1
    ],
    "lightseagreen": [
        32,
        178,
        170,
        1
    ],
    "lightskyblue": [
        135,
        206,
        250,
        1
    ],
    "lightslategray": [
        119,
        136,
        153,
        1
    ],
    "lightslategrey": [
        119,
        136,
        153,
        1
    ],
    "lightsteelblue": [
        176,
        196,
        222,
        1
    ],
    "lightyellow": [
        255,
        255,
        224,
        1
    ],
    "lime": [
        0,
        255,
        0,
        1
    ],
    "limegreen": [
        50,
        205,
        50,
        1
    ],
    "linen": [
        250,
        240,
        230,
        1
    ],
    "magenta": [
        255,
        0,
        255,
        1
    ],
    "maroon": [
        128,
        0,
        0,
        1
    ],
    "mediumaquamarine": [
        102,
        205,
        170,
        1
    ],
    "mediumblue": [
        0,
        0,
        205,
        1
    ],
    "mediumorchid": [
        186,
        85,
        211,
        1
    ],
    "mediumpurple": [
        147,
        112,
        219,
        1
    ],
    "mediumseagreen": [
        60,
        179,
        113,
        1
    ],
    "mediumslateblue": [
        123,
        104,
        238,
        1
    ],
    "mediumspringgreen": [
        0,
        250,
        154,
        1
    ],
    "mediumturquoise": [
        72,
        209,
        204,
        1
    ],
    "mediumvioletred": [
        199,
        21,
        133,
        1
    ],
    "midnightblue": [
        25,
        25,
        112,
        1
    ],
    "mintcream": [
        245,
        255,
        250,
        1
    ],
    "mistyrose": [
        255,
        228,
        225,
        1
    ],
    "moccasin": [
        255,
        228,
        181,
        1
    ],
    "navajowhite": [
        255,
        222,
        173,
        1
    ],
    "navy": [
        0,
        0,
        128,
        1
    ],
    "oldlace": [
        253,
        245,
        230,
        1
    ],
    "olive": [
        128,
        128,
        0,
        1
    ],
    "olivedrab": [
        107,
        142,
        35,
        1
    ],
    "orange": [
        255,
        165,
        0,
        1
    ],
    "orangered": [
        255,
        69,
        0,
        1
    ],
    "orchid": [
        218,
        112,
        214,
        1
    ],
    "palegoldenrod": [
        238,
        232,
        170,
        1
    ],
    "palegreen": [
        152,
        251,
        152,
        1
    ],
    "paleturquoise": [
        175,
        238,
        238,
        1
    ],
    "palevioletred": [
        219,
        112,
        147,
        1
    ],
    "papayawhip": [
        255,
        239,
        213,
        1
    ],
    "peachpuff": [
        255,
        218,
        185,
        1
    ],
    "peru": [
        205,
        133,
        63,
        1
    ],
    "pink": [
        255,
        192,
        203,
        1
    ],
    "plum": [
        221,
        160,
        221,
        1
    ],
    "powderblue": [
        176,
        224,
        230,
        1
    ],
    "purple": [
        128,
        0,
        128,
        1
    ],
    "rebeccapurple": [
        102,
        51,
        153,
        1
    ],
    "red": [
        255,
        0,
        0,
        1
    ],
    "rosybrown": [
        188,
        143,
        143,
        1
    ],
    "royalblue": [
        65,
        105,
        225,
        1
    ],
    "saddlebrown": [
        139,
        69,
        19,
        1
    ],
    "salmon": [
        250,
        128,
        114,
        1
    ],
    "sandybrown": [
        244,
        164,
        96,
        1
    ],
    "seagreen": [
        46,
        139,
        87,
        1
    ],
    "seashell": [
        255,
        245,
        238,
        1
    ],
    "sienna": [
        160,
        82,
        45,
        1
    ],
    "silver": [
        192,
        192,
        192,
        1
    ],
    "skyblue": [
        135,
        206,
        235,
        1
    ],
    "slateblue": [
        106,
        90,
        205,
        1
    ],
    "slategray": [
        112,
        128,
        144,
        1
    ],
    "slategrey": [
        112,
        128,
        144,
        1
    ],
    "snow": [
        255,
        250,
        250,
        1
    ],
    "springgreen": [
        0,
        255,
        127,
        1
    ],
    "steelblue": [
        70,
        130,
        180,
        1
    ],
    "tan": [
        210,
        180,
        140,
        1
    ],
    "teal": [
        0,
        128,
        128,
        1
    ],
    "thistle": [
        216,
        191,
        216,
        1
    ],
    "tomato": [
        255,
        99,
        71,
        1
    ],
    "turquoise": [
        64,
        224,
        208,
        1
    ],
    "violet": [
        238,
        130,
        238,
        1
    ],
    "wheat": [
        245,
        222,
        179,
        1
    ],
    "white": [
        255,
        255,
        255,
        1
    ],
    "whitesmoke": [
        245,
        245,
        245,
        1
    ],
    "yellow": [
        255,
        255,
        0,
        1
    ],
    "yellowgreen": [
        154,
        205,
        50,
        1
    ]
};
function clamp_css_byte(i) {
    // Clamp to integer 0 .. 255.
    i = Math.round(i);
    // Seems to be what Chrome does (vs truncation).
    return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clamp_css_float(f) {
    // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parse_css_int(str) {
    // int or percentage.
    if (str[str.length - 1] === "%") return clamp_css_byte(parseFloat(str) / 100 * 255);
    return clamp_css_byte(parseInt(str));
}
function parse_css_float(str) {
    // float or percentage.
    if (str[str.length - 1] === "%") return clamp_css_float(parseFloat(str) / 100);
    return clamp_css_float(parseFloat(str));
}
function css_hue_to_rgb(m1, m2, h) {
    if (h < 0) h += 1;
    else if (h > 1) h -= 1;
    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    return m1;
}
function parseCSSColor(css_str) {
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = css_str.replace(/ /g, "").toLowerCase();
    // Color keywords (and transparent) lookup.
    if (str in kCSSColorTable) return kCSSColorTable[str].slice();
    // dup.
    // #abc and #abc123 syntax.
    if (str[0] === "#") {
        if (str.length === 4) {
            var iv = parseInt(str.substr(1), 16);
            // TODO(deanm): Stricter parsing.
            if (!(iv >= 0 && iv <= 4095)) return null;
            // Covers NaN.
            return [
                (iv & 3840) >> 4 | (iv & 3840) >> 8,
                iv & 240 | (iv & 240) >> 4,
                iv & 15 | (iv & 15) << 4,
                1
            ];
        } else if (str.length === 7) {
            var iv = parseInt(str.substr(1), 16);
            // TODO(deanm): Stricter parsing.
            if (!(iv >= 0 && iv <= 16777215)) return null;
            // Covers NaN.
            return [
                (iv & 16711680) >> 16,
                (iv & 65280) >> 8,
                iv & 255,
                1
            ];
        }
        return null;
    }
    var op = str.indexOf("("), ep = str.indexOf(")");
    if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(",");
        var alpha = 1;
        // To allow case fallthrough.
        switch(fname){
            case "rgba":
                if (params.length !== 4) return null;
                alpha = parse_css_float(params.pop());
            // Fall through.
            case "rgb":
                if (params.length !== 3) return null;
                return [
                    parse_css_int(params[0]),
                    parse_css_int(params[1]),
                    parse_css_int(params[2]),
                    alpha
                ];
            case "hsla":
                if (params.length !== 4) return null;
                alpha = parse_css_float(params.pop());
            // Fall through.
            case "hsl":
                if (params.length !== 3) return null;
                var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360;
                // 0 .. 1
                // NOTE(deanm): According to the CSS spec s/l should only be
                // percentages, but we don't bother and let float or percentage.
                var s = parse_css_float(params[1]);
                var l = parse_css_float(params[2]);
                var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                var m1 = l * 2 - m2;
                return [
                    clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                    clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                    clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                    alpha
                ];
            default:
                return null;
        }
    }
    return null;
}
try {
    parseCSSColor_1 = csscolorparser.parseCSSColor = parseCSSColor;
} catch (e) {}
//      
/**
 * An RGBA color value. Create instances from color strings using the static
 * method `Color.parse`. The constructor accepts RGB channel values in the range
 * `[0, 1]`, premultiplied by A.
 *
 * @param {number} r The red channel.
 * @param {number} g The green channel.
 * @param {number} b The blue channel.
 * @param {number} a The alpha channel.
 * @private
 */ var Color = function Color(r, g, b, a) {
    if (a === void 0) a = 1;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
};
/**
 * Parses valid CSS color strings and returns a `Color` instance.
 * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
 */ Color.parse = function parse(input) {
    if (!input) return undefined;
    if (input instanceof Color) return input;
    if (typeof input !== "string") return undefined;
    var rgba = parseCSSColor_1(input);
    if (!rgba) return undefined;
    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
};
/**
 * Returns an RGBA string representing the color value.
 *
 * @returns An RGBA string.
 * @example
 * var purple = new Color.parse('purple');
 * purple.toString; // = "rgba(128,0,128,1)"
 * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
 * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
 */ Color.prototype.toString = function toString() {
    var ref = this.toArray();
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    return "rgba(" + Math.round(r) + "," + Math.round(g) + "," + Math.round(b) + "," + a + ")";
};
/**
 * Returns an RGBA array of values representing the color, unpremultiplied by A.
 *
 * @returns An array of RGBA color values in the range [0, 255].
 */ Color.prototype.toArray = function toArray() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [
        0,
        0,
        0,
        0
    ] : [
        r * 255 / a,
        g * 255 / a,
        b * 255 / a,
        a
    ];
};
/**
 * Returns a RGBA array of float values representing the color, unpremultiplied by A.
 *
 * @returns An array of RGBA color values in the range [0, 1].
 */ Color.prototype.toArray01 = function toArray01() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [
        0,
        0,
        0,
        0
    ] : [
        r / a,
        g / a,
        b / a,
        a
    ];
};
/**
 * Returns an RGBA array of values representing the color, premultiplied by A.
 *
 * @returns An array of RGBA color values in the range [0, 1].
 */ Color.prototype.toArray01PremultipliedAlpha = function toArray01PremultipliedAlpha() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return [
        r,
        g,
        b,
        a
    ];
};
Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);
Color.blue = new Color(0, 0, 1, 1);
var Color$1 = Color;
function convertLiteral(value) {
    return typeof value === "object" ? [
        "literal",
        value
    ] : value;
}
function convertFunction(parameters, propertySpec) {
    var stops = parameters.stops;
    if (!stops) // identity function
    return convertIdentityFunction(parameters, propertySpec);
    var zoomAndFeatureDependent = stops && typeof stops[0][0] === "object";
    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    var zoomDependent = zoomAndFeatureDependent || !featureDependent;
    stops = stops.map(function(stop) {
        if (!featureDependent && propertySpec.tokens && typeof stop[1] === "string") return [
            stop[0],
            convertTokenString(stop[1])
        ];
        return [
            stop[0],
            convertLiteral(stop[1])
        ];
    });
    if (zoomAndFeatureDependent) return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
    else if (zoomDependent) return convertZoomFunction(parameters, propertySpec, stops);
    else return convertPropertyFunction(parameters, propertySpec, stops);
}
function convertIdentityFunction(parameters, propertySpec) {
    var get = [
        "get",
        parameters.property
    ];
    if (parameters.default === undefined) // By default, expressions for string-valued properties get coerced. To preserve
    // legacy function semantics, insert an explicit assertion instead.
    return propertySpec.type === "string" ? [
        "string",
        get
    ] : get;
    else if (propertySpec.type === "enum") return [
        "match",
        get,
        Object.keys(propertySpec.values),
        get,
        parameters.default
    ];
    else {
        var expression = [
            propertySpec.type === "color" ? "to-color" : propertySpec.type,
            get,
            convertLiteral(parameters.default)
        ];
        if (propertySpec.type === "array") expression.splice(1, 0, propertySpec.value, propertySpec.length || null);
        return expression;
    }
}
function getInterpolateOperator(parameters) {
    switch(parameters.colorSpace){
        case "hcl":
            return "interpolate-hcl";
        case "lab":
            return "interpolate-lab";
        default:
            return "interpolate";
    }
}
function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
    var featureFunctionParameters = {};
    var featureFunctionStops = {};
    var zoomStops = [];
    for(var s = 0; s < stops.length; s++){
        var stop = stops[s];
        var zoom = stop[0].zoom;
        if (featureFunctionParameters[zoom] === undefined) {
            featureFunctionParameters[zoom] = {
                zoom: zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default
            };
            featureFunctionStops[zoom] = [];
            zoomStops.push(zoom);
        }
        featureFunctionStops[zoom].push([
            stop[0].value,
            stop[1]
        ]);
    }
    // the interpolation type for the zoom dimension of a zoom-and-property
    // function is determined directly from the style property specification
    // for which it's being used: linear for interpolatable properties, step
    // otherwise.
    var functionType = getFunctionType({}, propertySpec);
    if (functionType === "exponential") {
        var expression = [
            getInterpolateOperator(parameters),
            [
                "linear"
            ],
            [
                "zoom"
            ]
        ];
        for(var i = 0, list = zoomStops; i < list.length; i += 1){
            var z = list[i];
            var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
            appendStopPair(expression, z, output, false);
        }
        return expression;
    } else {
        var expression$1 = [
            "step",
            [
                "zoom"
            ]
        ];
        for(var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1){
            var z$1 = list$1[i$1];
            var output$1 = convertPropertyFunction(featureFunctionParameters[z$1], propertySpec, featureFunctionStops[z$1]);
            appendStopPair(expression$1, z$1, output$1, true);
        }
        fixupDegenerateStepCurve(expression$1);
        return expression$1;
    }
}
function coalesce(a, b) {
    if (a !== undefined) return a;
    if (b !== undefined) return b;
}
function getFallback(parameters, propertySpec) {
    var defaultValue = convertLiteral(coalesce(parameters.default, propertySpec.default));
    /*
     * Some fields with type: resolvedImage have an undefined default.
     * Because undefined is an invalid value for resolvedImage, set fallback to
     * an empty string instead of undefined to ensure output
     * passes validation.
     */ if (defaultValue === undefined && propertySpec.type === "resolvedImage") return "";
    return defaultValue;
}
function convertPropertyFunction(parameters, propertySpec, stops) {
    var type = getFunctionType(parameters, propertySpec);
    var get = [
        "get",
        parameters.property
    ];
    if (type === "categorical" && typeof stops[0][0] === "boolean") {
        var expression = [
            "case"
        ];
        for(var i = 0, list = stops; i < list.length; i += 1){
            var stop = list[i];
            expression.push([
                "==",
                get,
                stop[0]
            ], stop[1]);
        }
        expression.push(getFallback(parameters, propertySpec));
        return expression;
    } else if (type === "categorical") {
        var expression$1 = [
            "match",
            get
        ];
        for(var i$1 = 0, list$1 = stops; i$1 < list$1.length; i$1 += 1){
            var stop$1 = list$1[i$1];
            appendStopPair(expression$1, stop$1[0], stop$1[1], false);
        }
        expression$1.push(getFallback(parameters, propertySpec));
        return expression$1;
    } else if (type === "interval") {
        var expression$2 = [
            "step",
            [
                "number",
                get
            ]
        ];
        for(var i$2 = 0, list$2 = stops; i$2 < list$2.length; i$2 += 1){
            var stop$2 = list$2[i$2];
            appendStopPair(expression$2, stop$2[0], stop$2[1], true);
        }
        fixupDegenerateStepCurve(expression$2);
        return parameters.default === undefined ? expression$2 : [
            "case",
            [
                "==",
                [
                    "typeof",
                    get
                ],
                "number"
            ],
            expression$2,
            convertLiteral(parameters.default)
        ];
    } else if (type === "exponential") {
        var base = parameters.base !== undefined ? parameters.base : 1;
        var expression$3 = [
            getInterpolateOperator(parameters),
            base === 1 ? [
                "linear"
            ] : [
                "exponential",
                base
            ],
            [
                "number",
                get
            ]
        ];
        for(var i$3 = 0, list$3 = stops; i$3 < list$3.length; i$3 += 1){
            var stop$3 = list$3[i$3];
            appendStopPair(expression$3, stop$3[0], stop$3[1], false);
        }
        return parameters.default === undefined ? expression$3 : [
            "case",
            [
                "==",
                [
                    "typeof",
                    get
                ],
                "number"
            ],
            expression$3,
            convertLiteral(parameters.default)
        ];
    } else throw new Error("Unknown property function type " + type);
}
function convertZoomFunction(parameters, propertySpec, stops, input) {
    if (input === void 0) input = [
        "zoom"
    ];
    var type = getFunctionType(parameters, propertySpec);
    var expression;
    var isStep = false;
    if (type === "interval") {
        expression = [
            "step",
            input
        ];
        isStep = true;
    } else if (type === "exponential") {
        var base = parameters.base !== undefined ? parameters.base : 1;
        expression = [
            getInterpolateOperator(parameters),
            base === 1 ? [
                "linear"
            ] : [
                "exponential",
                base
            ],
            input
        ];
    } else throw new Error('Unknown zoom function type "' + type + '"');
    for(var i = 0, list = stops; i < list.length; i += 1){
        var stop = list[i];
        appendStopPair(expression, stop[0], stop[1], isStep);
    }
    fixupDegenerateStepCurve(expression);
    return expression;
}
function fixupDegenerateStepCurve(expression) {
    // degenerate step curve (i.e. a constant function): add a noop stop
    if (expression[0] === "step" && expression.length === 3) {
        expression.push(0);
        expression.push(expression[3]);
    }
}
function appendStopPair(curve, input, output, isStep) {
    // Skip duplicate stop values. They were not validated for functions, but they are for expressions.
    // https://github.com/mapbox/mapbox-gl-js/issues/4107
    if (curve.length > 3 && input === curve[curve.length - 2]) return;
    // step curves don't get the first input value, as it is redundant.
    if (!(isStep && curve.length === 2)) curve.push(input);
    curve.push(output);
}
function getFunctionType(parameters, propertySpec) {
    if (parameters.type) return parameters.type;
    else return propertySpec.expression.interpolated ? "exponential" : "interval";
}
// "String with {name} token" => ["concat", "String with ", ["get", "name"], " token"]
function convertTokenString(s) {
    var result = [
        "concat"
    ];
    var re = /{([^{}]+)}/g;
    var pos = 0;
    for(var match = re.exec(s); match !== null; match = re.exec(s)){
        var literal = s.slice(pos, re.lastIndex - match[0].length);
        pos = re.lastIndex;
        if (literal.length > 0) result.push(literal);
        result.push([
            "get",
            match[1]
        ]);
    }
    if (result.length === 1) return s;
    if (pos < s.length) result.push(s.slice(pos));
    else if (result.length === 2) return [
        "to-string",
        result[1]
    ];
    return result;
}
//      
var ParsingError = /*@__PURE__*/ function(Error1) {
    function ParsingError(key, message) {
        Error1.call(this, message);
        this.message = message;
        this.key = key;
    }
    if (Error1) ParsingError.__proto__ = Error1;
    ParsingError.prototype = Object.create(Error1 && Error1.prototype);
    ParsingError.prototype.constructor = ParsingError;
    return ParsingError;
}(Error);
var ParsingError$1 = ParsingError;
//      
/**
 * Tracks `let` bindings during expression parsing.
 * @private
 */ var Scope = function Scope(parent, bindings) {
    if (bindings === void 0) bindings = [];
    this.parent = parent;
    this.bindings = {};
    for(var i = 0, list = bindings; i < list.length; i += 1){
        var ref = list[i];
        var name = ref[0];
        var expression = ref[1];
        this.bindings[name] = expression;
    }
};
Scope.prototype.concat = function concat(bindings) {
    return new Scope(this, bindings);
};
Scope.prototype.get = function get(name) {
    if (this.bindings[name]) return this.bindings[name];
    if (this.parent) return this.parent.get(name);
    throw new Error(name + " not found in scope.");
};
Scope.prototype.has = function has(name) {
    if (this.bindings[name]) return true;
    return this.parent ? this.parent.has(name) : false;
};
var Scope$1 = Scope;
//      
var NullType = {
    kind: "null"
};
var NumberType = {
    kind: "number"
};
var StringType = {
    kind: "string"
};
var BooleanType = {
    kind: "boolean"
};
var ColorType = {
    kind: "color"
};
var ObjectType = {
    kind: "object"
};
var ValueType = {
    kind: "value"
};
var ErrorType = {
    kind: "error"
};
var CollatorType = {
    kind: "collator"
};
var FormattedType = {
    kind: "formatted"
};
var ResolvedImageType = {
    kind: "resolvedImage"
};
function array$1(itemType, N) {
    return {
        kind: "array",
        itemType: itemType,
        N: N
    };
}
function toString$1(type) {
    if (type.kind === "array") {
        var itemType = toString$1(type.itemType);
        return typeof type.N === "number" ? "array<" + itemType + ", " + type.N + ">" : type.itemType.kind === "value" ? "array" : "array<" + itemType + ">";
    } else return type.kind;
}
var valueMemberTypes = [
    NullType,
    NumberType,
    StringType,
    BooleanType,
    ColorType,
    FormattedType,
    ObjectType,
    array$1(ValueType),
    ResolvedImageType
];
/**
 * Returns null if `t` is a subtype of `expected`; otherwise returns an
 * error message.
 * @private
 */ function checkSubtype(expected, t) {
    if (t.kind === "error") // Error is a subtype of every type
    return null;
    else if (expected.kind === "array") {
        if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== "number" || expected.N === t.N)) return null;
    } else if (expected.kind === t.kind) return null;
    else if (expected.kind === "value") for(var i = 0, list = valueMemberTypes; i < list.length; i += 1){
        var memberType = list[i];
        if (!checkSubtype(memberType, t)) return null;
    }
    return "Expected " + toString$1(expected) + " but found " + toString$1(t) + " instead.";
}
function isValidType(provided, allowedTypes) {
    return allowedTypes.some(function(t) {
        return t.kind === provided.kind;
    });
}
function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(function(t) {
        if (t === "null") return provided === null;
        else if (t === "array") return Array.isArray(provided);
        else if (t === "object") return provided && !Array.isArray(provided) && typeof provided === "object";
        else return t === typeof provided;
    });
}
//      
// Flow type declarations for Intl cribbed from
// https://github.com/facebook/flow/issues/1270
var Collator = function Collator(caseSensitive, diacriticSensitive, locale) {
    if (caseSensitive) this.sensitivity = diacriticSensitive ? "variant" : "case";
    else this.sensitivity = diacriticSensitive ? "accent" : "base";
    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
        sensitivity: this.sensitivity,
        usage: "search"
    });
};
Collator.prototype.compare = function compare(lhs, rhs) {
    return this.collator.compare(lhs, rhs);
};
Collator.prototype.resolvedLocale = function resolvedLocale() {
    // We create a Collator without "usage: search" because we don't want
    // the search options encoded in our result (e.g. "en-u-co-search")
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
};
var Collator$1 = Collator;
//      
var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
    // combine characters so that diacritic marks are not separate code points
    this.text = text.normalize ? text.normalize() : text;
    this.image = image;
    this.scale = scale;
    this.fontStack = fontStack;
    this.textColor = textColor;
};
var Formatted = function Formatted(sections) {
    this.sections = sections;
};
Formatted.fromString = function fromString(unformatted) {
    return new Formatted([
        new FormattedSection(unformatted, null, null, null, null)
    ]);
};
Formatted.prototype.isEmpty = function isEmpty() {
    if (this.sections.length === 0) return true;
    return !this.sections.some(function(section) {
        return section.text.length !== 0 || section.image && section.image.name.length !== 0;
    });
};
Formatted.factory = function factory(text) {
    if (text instanceof Formatted) return text;
    else return Formatted.fromString(text);
};
Formatted.prototype.toString = function toString() {
    if (this.sections.length === 0) return "";
    return this.sections.map(function(section) {
        return section.text;
    }).join("");
};
Formatted.prototype.serialize = function serialize() {
    var serialized = [
        "format"
    ];
    for(var i = 0, list = this.sections; i < list.length; i += 1){
        var section = list[i];
        if (section.image) {
            serialized.push([
                "image",
                section.image.name
            ]);
            continue;
        }
        serialized.push(section.text);
        var options = {};
        if (section.fontStack) options["text-font"] = [
            "literal",
            section.fontStack.split(",")
        ];
        if (section.scale) options["font-scale"] = section.scale;
        if (section.textColor) options["text-color"] = [
            "rgba"
        ].concat(section.textColor.toArray());
        serialized.push(options);
    }
    return serialized;
};
var Formatted$1 = Formatted;
//      
var ResolvedImage = function ResolvedImage(options) {
    this.name = options.name;
    this.available = options.available;
};
ResolvedImage.prototype.toString = function toString() {
    return this.name;
};
ResolvedImage.fromString = function fromString(name) {
    if (!name) return null;
    // treat empty values as no image
    return new ResolvedImage({
        name: name,
        available: false
    });
};
ResolvedImage.prototype.serialize = function serialize() {
    return [
        "image",
        this.name
    ];
};
var ResolvedImage$1 = ResolvedImage;
function validateRGBA(r, g, b, a) {
    if (!(typeof r === "number" && r >= 0 && r <= 255 && typeof g === "number" && g >= 0 && g <= 255 && typeof b === "number" && b >= 0 && b <= 255)) {
        var value = typeof a === "number" ? [
            r,
            g,
            b,
            a
        ] : [
            r,
            g,
            b
        ];
        return "Invalid rgba value [" + value.join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
    }
    if (!(typeof a === "undefined" || typeof a === "number" && a >= 0 && a <= 1)) return "Invalid rgba value [" + [
        r,
        g,
        b,
        a
    ].join(", ") + "]: 'a' must be between 0 and 1.";
    return null;
}
function isValue(mixed) {
    if (mixed === null) return true;
    else if (typeof mixed === "string") return true;
    else if (typeof mixed === "boolean") return true;
    else if (typeof mixed === "number") return true;
    else if (mixed instanceof Color$1) return true;
    else if (mixed instanceof Collator$1) return true;
    else if (mixed instanceof Formatted$1) return true;
    else if (mixed instanceof ResolvedImage$1) return true;
    else if (Array.isArray(mixed)) {
        for(var i = 0, list = mixed; i < list.length; i += 1){
            var item = list[i];
            if (!isValue(item)) return false;
        }
        return true;
    } else if (typeof mixed === "object") {
        for(var key in mixed){
            if (!isValue(mixed[key])) return false;
        }
        return true;
    } else return false;
}
function typeOf(value) {
    if (value === null) return NullType;
    else if (typeof value === "string") return StringType;
    else if (typeof value === "boolean") return BooleanType;
    else if (typeof value === "number") return NumberType;
    else if (value instanceof Color$1) return ColorType;
    else if (value instanceof Collator$1) return CollatorType;
    else if (value instanceof Formatted$1) return FormattedType;
    else if (value instanceof ResolvedImage$1) return ResolvedImageType;
    else if (Array.isArray(value)) {
        var length = value.length;
        var itemType;
        for(var i = 0, list = value; i < list.length; i += 1){
            var item = list[i];
            var t = typeOf(item);
            if (!itemType) itemType = t;
            else if (itemType === t) continue;
            else {
                itemType = ValueType;
                break;
            }
        }
        return array$1(itemType || ValueType, length);
    } else return ObjectType;
}
function toString(value) {
    var type = typeof value;
    if (value === null) return "";
    else if (type === "string" || type === "number" || type === "boolean") return String(value);
    else if (value instanceof Color$1 || value instanceof Formatted$1 || value instanceof ResolvedImage$1) return value.toString();
    else return JSON.stringify(value);
}
var Literal = function Literal(type, value) {
    this.type = type;
    this.value = value;
};
Literal.parse = function parse(args, context) {
    if (args.length !== 2) return context.error("'literal' expression requires exactly one argument, but found " + (args.length - 1) + " instead.");
    if (!isValue(args[1])) return context.error("invalid value");
    var value = args[1];
    var type = typeOf(value);
    // special case: infer the item type if possible for zero-length arrays
    var expected = context.expectedType;
    if (type.kind === "array" && type.N === 0 && expected && expected.kind === "array" && (typeof expected.N !== "number" || expected.N === 0)) type = expected;
    return new Literal(type, value);
};
Literal.prototype.evaluate = function evaluate() {
    return this.value;
};
Literal.prototype.eachChild = function eachChild() {};
Literal.prototype.outputDefined = function outputDefined() {
    return true;
};
Literal.prototype.serialize = function serialize() {
    if (this.type.kind === "array" || this.type.kind === "object") return [
        "literal",
        this.value
    ];
    else if (this.value instanceof Color$1) // Constant-folding can generate Literal expressions that you
    // couldn't actually generate with a "literal" expression,
    // so we have to implement an equivalent serialization here
    return [
        "rgba"
    ].concat(this.value.toArray());
    else if (this.value instanceof Formatted$1) // Same as Color
    return this.value.serialize();
    else return this.value;
};
var Literal$1 = Literal;
//      
var RuntimeError = function RuntimeError(message) {
    this.name = "ExpressionEvaluationError";
    this.message = message;
};
RuntimeError.prototype.toJSON = function toJSON() {
    return this.message;
};
var RuntimeError$1 = RuntimeError;
var types$2 = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};
var Assertion = function Assertion(type, args) {
    this.type = type;
    this.args = args;
};
Assertion.parse = function parse(args, context) {
    if (args.length < 2) return context.error("Expected at least one argument.");
    var i = 1;
    var type;
    var name = args[0];
    if (name === "array") {
        var itemType;
        if (args.length > 2) {
            var type$1 = args[1];
            if (typeof type$1 !== "string" || !(type$1 in types$2) || type$1 === "object") return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
            itemType = types$2[type$1];
            i++;
        } else itemType = ValueType;
        var N;
        if (args.length > 3) {
            if (args[2] !== null && (typeof args[2] !== "number" || args[2] < 0 || args[2] !== Math.floor(args[2]))) return context.error('The length argument to "array" must be a positive integer literal', 2);
            N = args[2];
            i++;
        }
        type = array$1(itemType, N);
    } else type = types$2[name];
    var parsed = [];
    for(; i < args.length; i++){
        var input = context.parse(args[i], i, ValueType);
        if (!input) return null;
        parsed.push(input);
    }
    return new Assertion(type, parsed);
};
Assertion.prototype.evaluate = function evaluate(ctx) {
    for(var i = 0; i < this.args.length; i++){
        var value = this.args[i].evaluate(ctx);
        var error = checkSubtype(this.type, typeOf(value));
        if (!error) return value;
        else if (i === this.args.length - 1) throw new RuntimeError$1("Expected value to be of type " + toString$1(this.type) + ", but found " + toString$1(typeOf(value)) + " instead.");
    }
    return null;
};
Assertion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Assertion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function(arg) {
        return arg.outputDefined();
    });
};
Assertion.prototype.serialize = function serialize() {
    var type = this.type;
    var serialized = [
        type.kind
    ];
    if (type.kind === "array") {
        var itemType = type.itemType;
        if (itemType.kind === "string" || itemType.kind === "number" || itemType.kind === "boolean") {
            serialized.push(itemType.kind);
            var N = type.N;
            if (typeof N === "number" || this.args.length > 1) serialized.push(N);
        }
    }
    return serialized.concat(this.args.map(function(arg) {
        return arg.serialize();
    }));
};
var Assertion$1 = Assertion;
//      
var FormatExpression = function FormatExpression(sections) {
    this.type = FormattedType;
    this.sections = sections;
};
FormatExpression.parse = function parse(args, context) {
    if (args.length < 2) return context.error("Expected at least one argument.");
    var firstArg = args[1];
    if (!Array.isArray(firstArg) && typeof firstArg === "object") return context.error("First argument must be an image or text section.");
    var sections = [];
    var nextTokenMayBeObject = false;
    for(var i = 1; i <= args.length - 1; ++i){
        var arg = args[i];
        if (nextTokenMayBeObject && typeof arg === "object" && !Array.isArray(arg)) {
            nextTokenMayBeObject = false;
            var scale = null;
            if (arg["font-scale"]) {
                scale = context.parse(arg["font-scale"], 1, NumberType);
                if (!scale) return null;
            }
            var font = null;
            if (arg["text-font"]) {
                font = context.parse(arg["text-font"], 1, array$1(StringType));
                if (!font) return null;
            }
            var textColor = null;
            if (arg["text-color"]) {
                textColor = context.parse(arg["text-color"], 1, ColorType);
                if (!textColor) return null;
            }
            var lastExpression = sections[sections.length - 1];
            lastExpression.scale = scale;
            lastExpression.font = font;
            lastExpression.textColor = textColor;
        } else {
            var content = context.parse(args[i], 1, ValueType);
            if (!content) return null;
            var kind = content.type.kind;
            if (kind !== "string" && kind !== "value" && kind !== "null" && kind !== "resolvedImage") return context.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            nextTokenMayBeObject = true;
            sections.push({
                content: content,
                scale: null,
                font: null,
                textColor: null
            });
        }
    }
    return new FormatExpression(sections);
};
FormatExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluateSection = function(section) {
        var evaluatedContent = section.content.evaluate(ctx);
        if (typeOf(evaluatedContent) === ResolvedImageType) return new FormattedSection("", evaluatedContent, null, null, null);
        return new FormattedSection(toString(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(",") : null, section.textColor ? section.textColor.evaluate(ctx) : null);
    };
    return new Formatted$1(this.sections.map(evaluateSection));
};
FormatExpression.prototype.eachChild = function eachChild(fn) {
    for(var i = 0, list = this.sections; i < list.length; i += 1){
        var section = list[i];
        fn(section.content);
        if (section.scale) fn(section.scale);
        if (section.font) fn(section.font);
        if (section.textColor) fn(section.textColor);
    }
};
FormatExpression.prototype.outputDefined = function outputDefined() {
    // Technically the combinatoric set of all children
    // Usually, this.text will be undefined anyway
    return false;
};
FormatExpression.prototype.serialize = function serialize() {
    var serialized = [
        "format"
    ];
    for(var i = 0, list = this.sections; i < list.length; i += 1){
        var section = list[i];
        serialized.push(section.content.serialize());
        var options = {};
        if (section.scale) options["font-scale"] = section.scale.serialize();
        if (section.font) options["text-font"] = section.font.serialize();
        if (section.textColor) options["text-color"] = section.textColor.serialize();
        serialized.push(options);
    }
    return serialized;
};
var FormatExpression$1 = FormatExpression;
//      
var ImageExpression = function ImageExpression(input) {
    this.type = ResolvedImageType;
    this.input = input;
};
ImageExpression.parse = function parse(args, context) {
    if (args.length !== 2) return context.error("Expected two arguments.");
    var name = context.parse(args[1], 1, StringType);
    if (!name) return context.error("No image name provided.");
    return new ImageExpression(name);
};
ImageExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluatedImageName = this.input.evaluate(ctx);
    var value = ResolvedImage$1.fromString(evaluatedImageName);
    if (value && ctx.availableImages) value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
    return value;
};
ImageExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
ImageExpression.prototype.outputDefined = function outputDefined() {
    // The output of image is determined by the list of available images in the evaluation context
    return false;
};
ImageExpression.prototype.serialize = function serialize() {
    return [
        "image",
        this.input.serialize()
    ];
};
var ImageExpression$1 = ImageExpression;
var types$1 = {
    "to-boolean": BooleanType,
    "to-color": ColorType,
    "to-number": NumberType,
    "to-string": StringType
};
/**
 * Special form for error-coalescing coercion expressions "to-number",
 * "to-color".  Since these coercions can fail at runtime, they accept multiple
 * arguments, only evaluating one at a time until one succeeds.
 *
 * @private
 */ var Coercion = function Coercion(type, args) {
    this.type = type;
    this.args = args;
};
Coercion.parse = function parse(args, context) {
    if (args.length < 2) return context.error("Expected at least one argument.");
    var name = args[0];
    if ((name === "to-boolean" || name === "to-string") && args.length !== 2) return context.error("Expected one argument.");
    var type = types$1[name];
    var parsed = [];
    for(var i = 1; i < args.length; i++){
        var input = context.parse(args[i], i, ValueType);
        if (!input) return null;
        parsed.push(input);
    }
    return new Coercion(type, parsed);
};
Coercion.prototype.evaluate = function evaluate(ctx) {
    if (this.type.kind === "boolean") return Boolean(this.args[0].evaluate(ctx));
    else if (this.type.kind === "color") {
        var input;
        var error;
        for(var i = 0, list = this.args; i < list.length; i += 1){
            var arg = list[i];
            input = arg.evaluate(ctx);
            error = null;
            if (input instanceof Color$1) return input;
            else if (typeof input === "string") {
                var c = ctx.parseColor(input);
                if (c) return c;
            } else if (Array.isArray(input)) {
                if (input.length < 3 || input.length > 4) error = "Invalid rbga value " + JSON.stringify(input) + ": expected an array containing either three or four numeric values.";
                else error = validateRGBA(input[0], input[1], input[2], input[3]);
                if (!error) return new Color$1(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
            }
        }
        throw new RuntimeError$1(error || "Could not parse color from value '" + (typeof input === "string" ? input : String(JSON.stringify(input))) + "'");
    } else if (this.type.kind === "number") {
        var value = null;
        for(var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1){
            var arg$1 = list$1[i$1];
            value = arg$1.evaluate(ctx);
            if (value === null) return 0;
            var num = Number(value);
            if (isNaN(num)) continue;
            return num;
        }
        throw new RuntimeError$1("Could not convert " + JSON.stringify(value) + " to number.");
    } else if (this.type.kind === "formatted") // There is no explicit 'to-formatted' but this coercion can be implicitly
    // created by properties that expect the 'formatted' type.
    return Formatted$1.fromString(toString(this.args[0].evaluate(ctx)));
    else if (this.type.kind === "resolvedImage") return ResolvedImage$1.fromString(toString(this.args[0].evaluate(ctx)));
    else return toString(this.args[0].evaluate(ctx));
};
Coercion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coercion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function(arg) {
        return arg.outputDefined();
    });
};
Coercion.prototype.serialize = function serialize() {
    if (this.type.kind === "formatted") return new FormatExpression$1([
        {
            content: this.args[0],
            scale: null,
            font: null,
            textColor: null
        }
    ]).serialize();
    if (this.type.kind === "resolvedImage") return new ImageExpression$1(this.args[0]).serialize();
    var serialized = [
        "to-" + this.type.kind
    ];
    this.eachChild(function(child) {
        serialized.push(child.serialize());
    });
    return serialized;
};
var Coercion$1 = Coercion;
//      
var geometryTypes = [
    "Unknown",
    "Point",
    "LineString",
    "Polygon"
];
var EvaluationContext = function EvaluationContext() {
    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = {};
    this.availableImages = null;
    this.canonical = null;
    this.featureTileCoord = null;
    this.featureDistanceData = null;
};
EvaluationContext.prototype.id = function id() {
    return this.feature && this.feature.id !== undefined ? this.feature.id : null;
};
EvaluationContext.prototype.geometryType = function geometryType() {
    return this.feature ? typeof this.feature.type === "number" ? geometryTypes[this.feature.type] : this.feature.type : null;
};
EvaluationContext.prototype.geometry = function geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
};
EvaluationContext.prototype.canonicalID = function canonicalID() {
    return this.canonical;
};
EvaluationContext.prototype.properties = function properties() {
    return this.feature && this.feature.properties || {};
};
EvaluationContext.prototype.distanceFromCenter = function distanceFromCenter() {
    if (this.featureTileCoord && this.featureDistanceData) {
        var c = this.featureDistanceData.center;
        var scale = this.featureDistanceData.scale;
        var ref = this.featureTileCoord;
        var x = ref.x;
        var y = ref.y;
        // Calculate the distance vector `d` (left handed)
        var dX = x * scale - c[0];
        var dY = y * scale - c[1];
        // The bearing vector `b` (left handed)
        var bX = this.featureDistanceData.bearing[0];
        var bY = this.featureDistanceData.bearing[1];
        // Distance is calculated as `dot(d, v)`
        var dist = bX * dX + bY * dY;
        return dist;
    }
    return 0;
};
EvaluationContext.prototype.parseColor = function parseColor(input) {
    var cached = this._parseColorCache[input];
    if (!cached) cached = this._parseColorCache[input] = Color$1.parse(input);
    return cached;
};
var EvaluationContext$1 = EvaluationContext;
//      
var CompoundExpression = function CompoundExpression(name, type, evaluate, args) {
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
};
CompoundExpression.prototype.evaluate = function evaluate(ctx) {
    return this._evaluate(ctx, this.args);
};
CompoundExpression.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
CompoundExpression.prototype.outputDefined = function outputDefined() {
    return false;
};
CompoundExpression.prototype.serialize = function serialize() {
    return [
        this.name
    ].concat(this.args.map(function(arg) {
        return arg.serialize();
    }));
};
CompoundExpression.parse = function parse(args, context) {
    var ref$1;
    var op = args[0];
    var definition = CompoundExpression.definitions[op];
    if (!definition) return context.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    // Now check argument types against each signature
    var type = Array.isArray(definition) ? definition[0] : definition.type;
    var availableOverloads = Array.isArray(definition) ? [
        [
            definition[1],
            definition[2]
        ]
    ] : definition.overloads;
    var overloads = availableOverloads.filter(function(ref) {
        var signature = ref[0];
        return !Array.isArray(signature) || // varags
        signature.length === args.length - 1;
    } // correct param count
    );
    var signatureContext = null;
    for(var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1){
        // Use a fresh context for each attempted signature so that, if
        // we eventually succeed, we haven't polluted `context.errors`.
        var ref = list[i$3];
        var params = ref[0];
        var evaluate = ref[1];
        signatureContext = new ParsingContext$1(context.registry, context.path, null, context.scope);
        // First parse all the args, potentially coercing to the
        // types expected by this overload.
        var parsedArgs = [];
        var argParseFailed = false;
        for(var i = 1; i < args.length; i++){
            var arg = args[i];
            var expectedType = Array.isArray(params) ? params[i - 1] : params.type;
            var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
            if (!parsed) {
                argParseFailed = true;
                break;
            }
            parsedArgs.push(parsed);
        }
        if (argParseFailed) continue;
        if (Array.isArray(params)) {
            if (params.length !== parsedArgs.length) {
                signatureContext.error("Expected " + params.length + " arguments, but found " + parsedArgs.length + " instead.");
                continue;
            }
        }
        for(var i$1 = 0; i$1 < parsedArgs.length; i$1++){
            var expected = Array.isArray(params) ? params[i$1] : params.type;
            var arg$1 = parsedArgs[i$1];
            signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);
        }
        if (signatureContext.errors.length === 0) return new CompoundExpression(op, type, evaluate, parsedArgs);
    }
    if (overloads.length === 1) (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);
    else {
        var expected$1 = overloads.length ? overloads : availableOverloads;
        var signatures = expected$1.map(function(ref) {
            var params = ref[0];
            return stringifySignature(params);
        }).join(" | ");
        var actualTypes = [];
        // For error message, re-parse arguments without trying to
        // apply any coercions
        for(var i$2 = 1; i$2 < args.length; i$2++){
            var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);
            if (!parsed$1) return null;
            actualTypes.push(toString$1(parsed$1.type));
        }
        context.error("Expected arguments of type " + signatures + ", but found (" + actualTypes.join(", ") + ") instead.");
    }
    return null;
};
CompoundExpression.register = function register(registry, definitions) {
    CompoundExpression.definitions = definitions;
    for(var name in definitions)registry[name] = CompoundExpression;
};
function stringifySignature(signature) {
    if (Array.isArray(signature)) return "(" + signature.map(toString$1).join(", ") + ")";
    else return "(" + toString$1(signature.type) + "...)";
}
var CompoundExpression$1 = CompoundExpression;
//      
var CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
};
CollatorExpression.parse = function parse(args, context) {
    if (args.length !== 2) return context.error("Expected one argument.");
    var options = args[1];
    if (typeof options !== "object" || Array.isArray(options)) return context.error("Collator options argument must be an object.");
    var caseSensitive = context.parse(options["case-sensitive"] === undefined ? false : options["case-sensitive"], 1, BooleanType);
    if (!caseSensitive) return null;
    var diacriticSensitive = context.parse(options["diacritic-sensitive"] === undefined ? false : options["diacritic-sensitive"], 1, BooleanType);
    if (!diacriticSensitive) return null;
    var locale = null;
    if (options["locale"]) {
        locale = context.parse(options["locale"], 1, StringType);
        if (!locale) return null;
    }
    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
};
CollatorExpression.prototype.evaluate = function evaluate(ctx) {
    return new Collator$1(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
};
CollatorExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.caseSensitive);
    fn(this.diacriticSensitive);
    if (this.locale) fn(this.locale);
};
CollatorExpression.prototype.outputDefined = function outputDefined() {
    // Technically the set of possible outputs is the combinatoric set of Collators produced
    // by all possible outputs of locale/caseSensitive/diacriticSensitive
    // But for the primary use of Collators in comparison operators, we ignore the Collator's
    // possible outputs anyway, so we can get away with leaving this false for now.
    return false;
};
CollatorExpression.prototype.serialize = function serialize() {
    var options = {};
    options["case-sensitive"] = this.caseSensitive.serialize();
    options["diacritic-sensitive"] = this.diacriticSensitive.serialize();
    if (this.locale) options["locale"] = this.locale.serialize();
    return [
        "collator",
        options
    ];
};
var CollatorExpression$1 = CollatorExpression;
//      
// minX, minY, maxX, maxY
var EXTENT = 8192;
function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
}
function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0]) return false;
    if (bbox1[2] >= bbox2[2]) return false;
    if (bbox1[1] <= bbox2[1]) return false;
    if (bbox1[3] >= bbox2[3]) return false;
    return true;
}
function getTileCoordinates(p, canonical) {
    var x = mercatorXfromLng(p[0]);
    var y = mercatorYfromLat(p[1]);
    var tilesAtZoom = Math.pow(2, canonical.z);
    return [
        Math.round(x * tilesAtZoom * EXTENT),
        Math.round(y * tilesAtZoom * EXTENT)
    ];
}
function onBoundary(p, p1, p2) {
    var x1 = p[0] - p1[0];
    var y1 = p[1] - p1[1];
    var x2 = p[0] - p2[0];
    var y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
// ray casting algorithm for detecting if point is in polygon
function pointWithinPolygon(point, rings) {
    var inside = false;
    for(var i = 0, len = rings.length; i < len; i++){
        var ring = rings[i];
        for(var j = 0, len2 = ring.length; j < len2 - 1; j++){
            if (onBoundary(point, ring[j], ring[j + 1])) return false;
            if (rayIntersect(point, ring[j], ring[j + 1])) inside = !inside;
        }
    }
    return inside;
}
function pointWithinPolygons(point, polygons) {
    for(var i = 0; i < polygons.length; i++){
        if (pointWithinPolygon(point, polygons[i])) return true;
    }
    return false;
}
function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}
// check if p1 and p2 are in different sides of line segment q1->q2
function twoSided(p1, p2, q1, q2) {
    // q1->p1 (x1, y1), q1->p2 (x2, y2), q1->q2 (x3, y3)
    var x1 = p1[0] - q1[0];
    var y1 = p1[1] - q1[1];
    var x2 = p2[0] - q1[0];
    var y2 = p2[1] - q1[1];
    var x3 = q2[0] - q1[0];
    var y3 = q2[1] - q1[1];
    var det1 = x1 * y3 - x3 * y1;
    var det2 = x2 * y3 - x3 * y2;
    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) return true;
    return false;
}
// a, b are end points for line segment1, c and d are end points for line segment2
function lineIntersectLine(a, b, c, d) {
    // check if two segments are parallel or not
    // precondition is end point a, b is inside polygon, if line a->b is
    // parallel to polygon edge c->d, then a->b won't intersect with c->d
    var vectorP = [
        b[0] - a[0],
        b[1] - a[1]
    ];
    var vectorQ = [
        d[0] - c[0],
        d[1] - c[1]
    ];
    if (perp(vectorQ, vectorP) === 0) return false;
    // If lines are intersecting with each other, the relative location should be:
    // a and b lie in different sides of segment c->d
    // c and d lie in different sides of segment a->b
    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) return true;
    return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
    for(var i = 0, list = polygon; i < list.length; i += 1){
        // loop through every edge of the ring
        var ring = list[i];
        for(var j = 0; j < ring.length - 1; ++j){
            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) return true;
        }
    }
    return false;
}
function lineStringWithinPolygon(line, polygon) {
    // First, check if geometry points of line segments are all inside polygon
    for(var i = 0; i < line.length; ++i){
        if (!pointWithinPolygon(line[i], polygon)) return false;
    }
    // Second, check if there is line segment intersecting polygon edge
    for(var i$1 = 0; i$1 < line.length - 1; ++i$1){
        if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) return false;
    }
    return true;
}
function lineStringWithinPolygons(line, polygons) {
    for(var i = 0; i < polygons.length; i++){
        if (lineStringWithinPolygon(line, polygons[i])) return true;
    }
    return false;
}
function getTilePolygon(coordinates, bbox, canonical) {
    var polygon = [];
    for(var i = 0; i < coordinates.length; i++){
        var ring = [];
        for(var j = 0; j < coordinates[i].length; j++){
            var coord = getTileCoordinates(coordinates[i][j], canonical);
            updateBBox(bbox, coord);
            ring.push(coord);
        }
        polygon.push(ring);
    }
    return polygon;
}
function getTilePolygons(coordinates, bbox, canonical) {
    var polygons = [];
    for(var i = 0; i < coordinates.length; i++){
        var polygon = getTilePolygon(coordinates[i], bbox, canonical);
        polygons.push(polygon);
    }
    return polygons;
}
function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
        var halfWorldSize = worldSize * 0.5;
        var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
        if (shift === 0) shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
        p[0] += shift;
    }
    updateBBox(bbox, p);
}
function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [
        canonical.x * EXTENT,
        canonical.y * EXTENT
    ];
    var tilePoints = [];
    if (!geometry) return tilePoints;
    for(var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1){
        var points = list$1[i$1];
        for(var i = 0, list = points; i < list.length; i += 1){
            var point = list[i];
            var p = [
                point.x + shifts[0],
                point.y + shifts[1]
            ];
            updatePoint(p, pointBBox, polyBBox, worldSize);
            tilePoints.push(p);
        }
    }
    return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [
        canonical.x * EXTENT,
        canonical.y * EXTENT
    ];
    var tileLines = [];
    if (!geometry) return tileLines;
    for(var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1){
        var line = list$1[i$1];
        var tileLine = [];
        for(var i = 0, list = line; i < list.length; i += 1){
            var point = list[i];
            var p = [
                point.x + shifts[0],
                point.y + shifts[1]
            ];
            updateBBox(lineBBox, p);
            tileLine.push(p);
        }
        tileLines.push(tileLine);
    }
    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
        resetBBox(lineBBox);
        for(var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1){
            var line$1 = list$3[i$3];
            for(var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1){
                var p$1 = list$2[i$2];
                updatePoint(p$1, lineBBox, polyBBox, worldSize);
            }
        }
    }
    return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
    var pointBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var polyBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var canonical = ctx.canonicalID();
    if (!canonical) return false;
    if (polygonGeometry.type === "Polygon") {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) return false;
        for(var i = 0, list = tilePoints; i < list.length; i += 1){
            var point = list[i];
            if (!pointWithinPolygon(point, tilePolygon)) return false;
        }
    }
    if (polygonGeometry.type === "MultiPolygon") {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox)) return false;
        for(var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1){
            var point$1 = list$1[i$1];
            if (!pointWithinPolygons(point$1, tilePolygons)) return false;
        }
    }
    return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
    var lineBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var polyBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    var canonical = ctx.canonicalID();
    if (!canonical) return false;
    if (polygonGeometry.type === "Polygon") {
        var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) return false;
        for(var i = 0, list = tileLines; i < list.length; i += 1){
            var line = list[i];
            if (!lineStringWithinPolygon(line, tilePolygon)) return false;
        }
    }
    if (polygonGeometry.type === "MultiPolygon") {
        var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox)) return false;
        for(var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1){
            var line$1 = list$1[i$1];
            if (!lineStringWithinPolygons(line$1, tilePolygons)) return false;
        }
    }
    return true;
}
var Within = function Within(geojson, geometries) {
    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
};
Within.parse = function parse(args, context) {
    if (args.length !== 2) return context.error("'within' expression requires exactly one argument, but found " + (args.length - 1) + " instead.");
    if (isValue(args[1])) {
        var geojson = args[1];
        if (geojson.type === "FeatureCollection") for(var i = 0; i < geojson.features.length; ++i){
            var type = geojson.features[i].geometry.type;
            if (type === "Polygon" || type === "MultiPolygon") return new Within(geojson, geojson.features[i].geometry);
        }
        else if (geojson.type === "Feature") {
            var type$1 = geojson.geometry.type;
            if (type$1 === "Polygon" || type$1 === "MultiPolygon") return new Within(geojson, geojson.geometry);
        } else if (geojson.type === "Polygon" || geojson.type === "MultiPolygon") return new Within(geojson, geojson);
    }
    return context.error("'within' expression requires valid geojson object that contains polygon geometry type.");
};
Within.prototype.evaluate = function evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
        if (ctx.geometryType() === "Point") return pointsWithinPolygons(ctx, this.geometries);
        else if (ctx.geometryType() === "LineString") return linesWithinPolygons(ctx, this.geometries);
    }
    return false;
};
Within.prototype.eachChild = function eachChild() {};
Within.prototype.outputDefined = function outputDefined() {
    return true;
};
Within.prototype.serialize = function serialize() {
    return [
        "within",
        this.geojson
    ];
};
var Within$1 = Within;
//      
function isFeatureConstant(e) {
    if (e instanceof CompoundExpression$1) {
        if (e.name === "get" && e.args.length === 1) return false;
        else if (e.name === "feature-state") return false;
        else if (e.name === "has" && e.args.length === 1) return false;
        else if (e.name === "properties" || e.name === "geometry-type" || e.name === "id") return false;
        else if (/^filter-/.test(e.name)) return false;
    }
    if (e instanceof Within$1) return false;
    var result = true;
    e.eachChild(function(arg) {
        if (result && !isFeatureConstant(arg)) result = false;
    });
    return result;
}
function isStateConstant(e) {
    if (e instanceof CompoundExpression$1) {
        if (e.name === "feature-state") return false;
    }
    var result = true;
    e.eachChild(function(arg) {
        if (result && !isStateConstant(arg)) result = false;
    });
    return result;
}
function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression$1 && properties.indexOf(e.name) >= 0) return false;
    var result = true;
    e.eachChild(function(arg) {
        if (result && !isGlobalPropertyConstant(arg, properties)) result = false;
    });
    return result;
}
//      
var Var = function Var(name, boundExpression) {
    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
};
Var.parse = function parse(args, context) {
    if (args.length !== 2 || typeof args[1] !== "string") return context.error("'var' expression requires exactly one string literal argument.");
    var name = args[1];
    if (!context.scope.has(name)) return context.error('Unknown variable "' + name + '". Make sure "' + name + '" has been bound in an enclosing "let" expression before using it.', 1);
    return new Var(name, context.scope.get(name));
};
Var.prototype.evaluate = function evaluate(ctx) {
    return this.boundExpression.evaluate(ctx);
};
Var.prototype.eachChild = function eachChild() {};
Var.prototype.outputDefined = function outputDefined() {
    return false;
};
Var.prototype.serialize = function serialize() {
    return [
        "var",
        this.name
    ];
};
var Var$1 = Var;
//      
/**
 * State associated parsing at a given point in an expression tree.
 * @private
 */ var ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {
    if (path === void 0) path = [];
    if (scope === void 0) scope = new Scope$1();
    if (errors === void 0) errors = [];
    this.registry = registry;
    this.path = path;
    this.key = path.map(function(part) {
        return "[" + part + "]";
    }).join("");
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
};
/**
 * @param expr the JSON expression to parse
 * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
 * @param options
 * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
 * @private
 */ ParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {
    if (options === void 0) options = {};
    if (index) return this.concat(index, expectedType, bindings)._parse(expr, options);
    return this._parse(expr, options);
};
ParsingContext.prototype._parse = function _parse(expr, options) {
    if (expr === null || typeof expr === "string" || typeof expr === "boolean" || typeof expr === "number") expr = [
        "literal",
        expr
    ];
    function annotate(parsed, type, typeAnnotation) {
        if (typeAnnotation === "assert") return new Assertion$1(type, [
            parsed
        ]);
        else if (typeAnnotation === "coerce") return new Coercion$1(type, [
            parsed
        ]);
        else return parsed;
    }
    if (Array.isArray(expr)) {
        if (expr.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
        var op = expr[0];
        if (typeof op !== "string") {
            this.error("Expression name must be a string, but found " + typeof op + ' instead. If you wanted a literal array, use ["literal", [...]].', 0);
            return null;
        }
        var Expr = this.registry[op];
        if (Expr) {
            var parsed = Expr.parse(expr, this);
            if (!parsed) return null;
            if (this.expectedType) {
                var expected = this.expectedType;
                var actual = parsed.type;
                // When we expect a number, string, boolean, or array but have a value, wrap it in an assertion.
                // When we expect a color or formatted string, but have a string or value, wrap it in a coercion.
                // Otherwise, we do static type-checking.
                //
                // These behaviors are overridable for:
                //   * The "coalesce" operator, which needs to omit type annotations.
                //   * String-valued properties (e.g. `text-field`), where coercion is more convenient than assertion.
                //
                if ((expected.kind === "string" || expected.kind === "number" || expected.kind === "boolean" || expected.kind === "object" || expected.kind === "array") && actual.kind === "value") parsed = annotate(parsed, expected, options.typeAnnotation || "assert");
                else if ((expected.kind === "color" || expected.kind === "formatted" || expected.kind === "resolvedImage") && (actual.kind === "value" || actual.kind === "string")) parsed = annotate(parsed, expected, options.typeAnnotation || "coerce");
                else if (this.checkSubtype(expected, actual)) return null;
            }
            // If an expression's arguments are all literals, we can evaluate
            // it immediately and replace it with a literal value in the
            // parsed/compiled result. Expressions that expect an image should
            // not be resolved here so we can later get the available images.
            if (!(parsed instanceof Literal$1) && parsed.type.kind !== "resolvedImage" && isConstant(parsed)) {
                var ec = new EvaluationContext$1();
                try {
                    parsed = new Literal$1(parsed.type, parsed.evaluate(ec));
                } catch (e) {
                    this.error(e.message);
                    return null;
                }
            }
            return parsed;
        }
        return this.error('Unknown expression "' + op + '". If you wanted a literal array, use ["literal", [...]].', 0);
    } else if (typeof expr === "undefined") return this.error("'undefined' value invalid. Use null instead.");
    else if (typeof expr === "object") return this.error('Bare objects invalid. Use ["literal", {...}] instead.');
    else return this.error("Expected an array, but found " + typeof expr + " instead.");
};
/**
 * Returns a copy of this context suitable for parsing the subexpression at
 * index `index`, optionally appending to 'let' binding map.
 *
 * Note that `errors` property, intended for collecting errors while
 * parsing, is copied by reference rather than cloned.
 * @private
 */ ParsingContext.prototype.concat = function concat(index, expectedType, bindings) {
    var path = typeof index === "number" ? this.path.concat(index) : this.path;
    var scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
};
/**
 * Push a parsing (or type checking) error into the `this.errors`
 * @param error The message
 * @param keys Optionally specify the source of the error at a child
 * of the current expression at `this.key`.
 * @private
 */ ParsingContext.prototype.error = function error(error$1) {
    var keys = [], len = arguments.length - 1;
    while(len-- > 0)keys[len] = arguments[len + 1];
    var key = "" + this.key + keys.map(function(k) {
        return "[" + k + "]";
    }).join("");
    this.errors.push(new ParsingError$1(key, error$1));
};
/**
 * Returns null if `t` is a subtype of `expected`; otherwise returns an
 * error message and also pushes it to `this.errors`.
 */ ParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {
    var error = checkSubtype(expected, t);
    if (error) this.error(error);
    return error;
};
var ParsingContext$1 = ParsingContext;
function isConstant(expression) {
    if (expression instanceof Var$1) return isConstant(expression.boundExpression);
    else if (expression instanceof CompoundExpression$1 && expression.name === "error") return false;
    else if (expression instanceof CollatorExpression$1) // Although the results of a Collator expression with fixed arguments
    // generally shouldn't change between executions, we can't serialize them
    // as constant expressions because results change based on environment.
    return false;
    else if (expression instanceof Within$1) return false;
    var isTypeAnnotation = expression instanceof Coercion$1 || expression instanceof Assertion$1;
    var childrenConstant = true;
    expression.eachChild(function(child) {
        // We can _almost_ assume that if `expressions` children are constant,
        // they would already have been evaluated to Literal values when they
        // were parsed.  Type annotations are the exception, because they might
        // have been inferred and added after a child was parsed.
        // So we recurse into isConstant() for the children of type annotations,
        // but otherwise simply check whether they are Literals.
        if (isTypeAnnotation) childrenConstant = childrenConstant && isConstant(child);
        else childrenConstant = childrenConstant && child instanceof Literal$1;
    });
    if (!childrenConstant) return false;
    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [
        "zoom",
        "heatmap-density",
        "line-progress",
        "sky-radial-progress",
        "accumulated",
        "is-supported-script",
        "pitch",
        "distance-from-center"
    ]);
}
//      
/**
 * Returns the index of the last stop <= input, or 0 if it doesn't exist.
 * @private
 */ function findStopLessThanOrEqualTo(stops, input) {
    var lastIndex = stops.length - 1;
    var lowerIndex = 0;
    var upperIndex = lastIndex;
    var currentIndex = 0;
    var currentValue, nextValue;
    while(lowerIndex <= upperIndex){
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
            if (currentIndex === lastIndex || input < nextValue) // Search complete
            return currentIndex;
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) upperIndex = currentIndex - 1;
        else throw new RuntimeError$1("Input is not a number.");
    }
    return 0;
}
//      
var Step = function Step(type, input, stops) {
    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for(var i = 0, list = stops; i < list.length; i += 1){
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Step.parse = function parse(args, context) {
    if (args.length - 1 < 4) return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
    if ((args.length - 1) % 2 !== 0) return context.error("Expected an even number of arguments.");
    var input = context.parse(args[1], 1, NumberType);
    if (!input) return null;
    var stops = [];
    var outputType = null;
    if (context.expectedType && context.expectedType.kind !== "value") outputType = context.expectedType;
    for(var i = 1; i < args.length; i += 2){
        var label = i === 1 ? -Infinity : args[i];
        var value = args[i + 1];
        var labelKey = i;
        var valueKey = i + 1;
        if (typeof label !== "number") return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        if (stops.length && stops[stops.length - 1][0] >= label) return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) return null;
        outputType = outputType || parsed.type;
        stops.push([
            label,
            parsed
        ]);
    }
    return new Step(outputType, input, stops);
};
Step.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) return outputs[0].evaluate(ctx);
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) return outputs[0].evaluate(ctx);
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) return outputs[stopCount - 1].evaluate(ctx);
    var index = findStopLessThanOrEqualTo(labels, value);
    return outputs[index].evaluate(ctx);
};
Step.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for(var i = 0, list = this.outputs; i < list.length; i += 1){
        var expression = list[i];
        fn(expression);
    }
};
Step.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function(out) {
        return out.outputDefined();
    });
};
Step.prototype.serialize = function serialize() {
    var serialized = [
        "step",
        this.input.serialize()
    ];
    for(var i = 0; i < this.labels.length; i++){
        if (i > 0) serialized.push(this.labels[i]);
        serialized.push(this.outputs[i].serialize());
    }
    return serialized;
};
var Step$1 = Step;
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */ var unitbezier = UnitBezier;
function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3 * p1x;
    this.bx = 3 * (p2x - p1x) - this.cx;
    this.ax = 1 - this.cx - this.bx;
    this.cy = 3 * p1y;
    this.by = 3 * (p2y - p1y) - this.cy;
    this.ay = 1 - this.cy - this.by;
    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}
UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};
UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};
UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
};
UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === "undefined") epsilon = 0.000001;
    var t0, t1, t2, x2, i;
    // First try a few iterations of Newton's method -- normally very fast.
    for(t2 = x, i = 0; i < 8; i++){
        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;
        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 0.000001) break;
        t2 = t2 - x2 / d2;
    }
    // Fall back to the bisection method for reliability.
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0) return t0;
    if (t2 > t1) return t1;
    while(t0 < t1){
        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;
        if (x > x2) t0 = t2;
        else t1 = t2;
        t2 = (t1 - t0) * 0.5 + t0;
    }
    // Failure.
    return t2;
};
UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};
//      
function number(a, b, t) {
    return a * (1 - t) + b * t;
}
function color(from, to, t) {
    return new Color$1(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}
function array(from, to, t) {
    return from.map(function(d, i) {
        return number(d, to[i], t);
    });
}
var interpolate = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    number: number,
    color: color,
    array: array
});
//      
// Constants
var Xn = 0.95047, // D65 standard referent
Yn = 1, Zn = 1.08883, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1, deg2rad$1 = Math.PI / 180, rad2deg = 180 / Math.PI;
// Utilities
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
// LAB
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor.r), a = rgb2xyz(rgbColor.g), l = rgb2xyz(rgbColor.b), x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn), y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn), z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
        l: 116 * y - 16,
        a: 500 * (x - y),
        b: 200 * (y - z),
        alpha: rgbColor.a
    };
}
function labToRgb(labColor) {
    var y = (labColor.l + 16) / 116, x = isNaN(labColor.a) ? y : y + labColor.a / 500, z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color$1(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}
function interpolateLab(from, to, t) {
    return {
        l: number(from.l, to.l, t),
        a: number(from.a, to.a, t),
        b: number(from.b, to.b, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
// HCL
function rgbToHcl(rgbColor) {
    var ref = rgbToLab(rgbColor);
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var h = Math.atan2(b, a) * rad2deg;
    return {
        h: h < 0 ? h + 360 : h,
        c: Math.sqrt(a * a + b * b),
        l: l,
        alpha: rgbColor.a
    };
}
function hclToRgb(hclColor) {
    var h = hclColor.h * deg2rad$1, c = hclColor.c, l = hclColor.l;
    return labToRgb({
        l: l,
        a: Math.cos(h) * c,
        b: Math.sin(h) * c,
        alpha: hclColor.alpha
    });
}
function interpolateHue(a, b, t) {
    var d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}
function interpolateHcl(from, to, t) {
    return {
        h: interpolateHue(from.h, to.h, t),
        c: number(from.c, to.c, t),
        l: number(from.l, to.l, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
var lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
};
var hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
};
//      
var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for(var i = 0, list = stops; i < list.length; i += 1){
        var ref = list[i];
        var label = ref[0];
        var expression = ref[1];
        this.labels.push(label);
        this.outputs.push(expression);
    }
};
Interpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {
    var t = 0;
    if (interpolation.name === "exponential") t = exponentialInterpolation(input, interpolation.base, lower, upper);
    else if (interpolation.name === "linear") t = exponentialInterpolation(input, 1, lower, upper);
    else if (interpolation.name === "cubic-bezier") {
        var c = interpolation.controlPoints;
        var ub = new unitbezier(c[0], c[1], c[2], c[3]);
        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }
    return t;
};
Interpolate.parse = function parse(args, context) {
    var operator = args[0];
    var interpolation = args[1];
    var input = args[2];
    var rest = args.slice(3);
    if (!Array.isArray(interpolation) || interpolation.length === 0) return context.error("Expected an interpolation type expression.", 1);
    if (interpolation[0] === "linear") interpolation = {
        name: "linear"
    };
    else if (interpolation[0] === "exponential") {
        var base = interpolation[1];
        if (typeof base !== "number") return context.error("Exponential interpolation requires a numeric base.", 1, 1);
        interpolation = {
            name: "exponential",
            base: base
        };
    } else if (interpolation[0] === "cubic-bezier") {
        var controlPoints = interpolation.slice(1);
        if (controlPoints.length !== 4 || controlPoints.some(function(t) {
            return typeof t !== "number" || t < 0 || t > 1;
        })) return context.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
        interpolation = {
            name: "cubic-bezier",
            controlPoints: controlPoints
        };
    } else return context.error("Unknown interpolation type " + String(interpolation[0]), 1, 0);
    if (args.length - 1 < 4) return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
    if ((args.length - 1) % 2 !== 0) return context.error("Expected an even number of arguments.");
    input = context.parse(input, 2, NumberType);
    if (!input) return null;
    var stops = [];
    var outputType = null;
    if (operator === "interpolate-hcl" || operator === "interpolate-lab") outputType = ColorType;
    else if (context.expectedType && context.expectedType.kind !== "value") outputType = context.expectedType;
    for(var i = 0; i < rest.length; i += 2){
        var label = rest[i];
        var value = rest[i + 1];
        var labelKey = i + 3;
        var valueKey = i + 4;
        if (typeof label !== "number") return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
        if (stops.length && stops[stops.length - 1][0] >= label) return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
        var parsed = context.parse(value, valueKey, outputType);
        if (!parsed) return null;
        outputType = outputType || parsed.type;
        stops.push([
            label,
            parsed
        ]);
    }
    if (outputType.kind !== "number" && outputType.kind !== "color" && !(outputType.kind === "array" && outputType.itemType.kind === "number" && typeof outputType.N === "number")) return context.error("Type " + toString$1(outputType) + " is not interpolatable.");
    return new Interpolate(outputType, operator, interpolation, input, stops);
};
Interpolate.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;
    if (labels.length === 1) return outputs[0].evaluate(ctx);
    var value = this.input.evaluate(ctx);
    if (value <= labels[0]) return outputs[0].evaluate(ctx);
    var stopCount = labels.length;
    if (value >= labels[stopCount - 1]) return outputs[stopCount - 1].evaluate(ctx);
    var index = findStopLessThanOrEqualTo(labels, value);
    var lower = labels[index];
    var upper = labels[index + 1];
    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
    var outputLower = outputs[index].evaluate(ctx);
    var outputUpper = outputs[index + 1].evaluate(ctx);
    if (this.operator === "interpolate") return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t); // eslint-disable-line import/namespace
    else if (this.operator === "interpolate-hcl") return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
    else return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
};
Interpolate.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    for(var i = 0, list = this.outputs; i < list.length; i += 1){
        var expression = list[i];
        fn(expression);
    }
};
Interpolate.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function(out) {
        return out.outputDefined();
    });
};
Interpolate.prototype.serialize = function serialize() {
    var interpolation;
    if (this.interpolation.name === "linear") interpolation = [
        "linear"
    ];
    else if (this.interpolation.name === "exponential") {
        if (this.interpolation.base === 1) interpolation = [
            "linear"
        ];
        else interpolation = [
            "exponential",
            this.interpolation.base
        ];
    } else interpolation = [
        "cubic-bezier"
    ].concat(this.interpolation.controlPoints);
    var serialized = [
        this.operator,
        interpolation,
        this.input.serialize()
    ];
    for(var i = 0; i < this.labels.length; i++)serialized.push(this.labels[i], this.outputs[i].serialize());
    return serialized;
};
/**
 * Returns a ratio that can be used to interpolate between exponential function
 * stops.
 * How it works: Two consecutive stop values define a (scaled and shifted) exponential function `f(x) = a * base^x + b`, where `base` is the user-specified base,
 * and `a` and `b` are constants affording sufficient degrees of freedom to fit
 * the function to the given stops.
 *
 * Here's a bit of algebra that lets us compute `f(x)` directly from the stop
 * values without explicitly solving for `a` and `b`:
 *
 * First stop value: `f(x0) = y0 = a * base^x0 + b`
 * Second stop value: `f(x1) = y1 = a * base^x1 + b`
 * => `y1 - y0 = a(base^x1 - base^x0)`
 * => `a = (y1 - y0)/(base^x1 - base^x0)`
 *
 * Desired value: `f(x) = y = a * base^x + b`
 * => `f(x) = y0 + a * (base^x - base^x0)`
 *
 * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a
 * little algebra:
 * ```
 * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)
 *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)
 * ```
 *
 * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have
 * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as
 * an interpolation factor between the two stops' output values.
 *
 * (Note: a slightly different form for `ratio`,
 * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer
 * expensive `Math.pow()` operations.)
 *
 * @private
*/ function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;
    if (difference === 0) return 0;
    else if (base === 1) return progress / difference;
    else return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
}
var Interpolate$1 = Interpolate;
var Coalesce = function Coalesce(type, args) {
    this.type = type;
    this.args = args;
};
Coalesce.parse = function parse(args, context) {
    if (args.length < 2) return context.error("Expectected at least one argument.");
    var outputType = null;
    var expectedType = context.expectedType;
    if (expectedType && expectedType.kind !== "value") outputType = expectedType;
    var parsedArgs = [];
    for(var i = 0, list = args.slice(1); i < list.length; i += 1){
        var arg = list[i];
        var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, {
            typeAnnotation: "omit"
        });
        if (!parsed) return null;
        outputType = outputType || parsed.type;
        parsedArgs.push(parsed);
    }
    // Above, we parse arguments without inferred type annotation so that
    // they don't produce a runtime error for `null` input, which would
    // preempt the desired null-coalescing behavior.
    // Thus, if any of our arguments would have needed an annotation, we
    // need to wrap the enclosing coalesce expression with it instead.
    var needsAnnotation = expectedType && parsedArgs.some(function(arg) {
        return checkSubtype(expectedType, arg.type);
    });
    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
};
Coalesce.prototype.evaluate = function evaluate(ctx) {
    var result = null;
    var argCount = 0;
    var firstImage;
    for(var i = 0, list = this.args; i < list.length; i += 1){
        var arg = list[i];
        argCount++;
        result = arg.evaluate(ctx);
        // we need to keep track of the first requested image in a coalesce statement
        // if coalesce can't find a valid image, we return the first image so styleimagemissing can fire
        if (result && result instanceof ResolvedImage$1 && !result.available) {
            // set to first image
            if (!firstImage) firstImage = result;
            result = null;
            // if we reach the end, return the first image
            if (argCount === this.args.length) return firstImage;
        }
        if (result !== null) break;
    }
    return result;
};
Coalesce.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
};
Coalesce.prototype.outputDefined = function outputDefined() {
    return this.args.every(function(arg) {
        return arg.outputDefined();
    });
};
Coalesce.prototype.serialize = function serialize() {
    var serialized = [
        "coalesce"
    ];
    this.eachChild(function(child) {
        serialized.push(child.serialize());
    });
    return serialized;
};
var Coalesce$1 = Coalesce;
//      
var Let = function Let(bindings, result) {
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
};
Let.prototype.evaluate = function evaluate(ctx) {
    return this.result.evaluate(ctx);
};
Let.prototype.eachChild = function eachChild(fn) {
    for(var i = 0, list = this.bindings; i < list.length; i += 1){
        var binding = list[i];
        fn(binding[1]);
    }
    fn(this.result);
};
Let.parse = function parse(args, context) {
    if (args.length < 4) return context.error("Expected at least 3 arguments, but found " + (args.length - 1) + " instead.");
    var bindings = [];
    for(var i = 1; i < args.length - 1; i += 2){
        var name = args[i];
        if (typeof name !== "string") return context.error("Expected string, but found " + typeof name + " instead.", i);
        if (/[^a-zA-Z0-9_]/.test(name)) return context.error("Variable names must contain only alphanumeric characters or '_'.", i);
        var value = context.parse(args[i + 1], i + 1);
        if (!value) return null;
        bindings.push([
            name,
            value
        ]);
    }
    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
    if (!result) return null;
    return new Let(bindings, result);
};
Let.prototype.outputDefined = function outputDefined() {
    return this.result.outputDefined();
};
Let.prototype.serialize = function serialize() {
    var serialized = [
        "let"
    ];
    for(var i = 0, list = this.bindings; i < list.length; i += 1){
        var ref = list[i];
        var name = ref[0];
        var expr = ref[1];
        serialized.push(name, expr.serialize());
    }
    serialized.push(this.result.serialize());
    return serialized;
};
var Let$1 = Let;
//      
var At = function At(type, index, input) {
    this.type = type;
    this.index = index;
    this.input = input;
};
At.parse = function parse(args, context) {
    if (args.length !== 3) return context.error("Expected 2 arguments, but found " + (args.length - 1) + " instead.");
    var index = context.parse(args[1], 1, NumberType);
    var input = context.parse(args[2], 2, array$1(context.expectedType || ValueType));
    if (!index || !input) return null;
    var t = input.type;
    return new At(t.itemType, index, input);
};
At.prototype.evaluate = function evaluate(ctx) {
    var index = this.index.evaluate(ctx);
    var array = this.input.evaluate(ctx);
    if (index < 0) throw new RuntimeError$1("Array index out of bounds: " + index + " < 0.");
    if (index >= array.length) throw new RuntimeError$1("Array index out of bounds: " + index + " > " + (array.length - 1) + ".");
    if (index !== Math.floor(index)) throw new RuntimeError$1("Array index must be an integer, but found " + index + " instead.");
    return array[index];
};
At.prototype.eachChild = function eachChild(fn) {
    fn(this.index);
    fn(this.input);
};
At.prototype.outputDefined = function outputDefined() {
    return false;
};
At.prototype.serialize = function serialize() {
    return [
        "at",
        this.index.serialize(),
        this.input.serialize()
    ];
};
var At$1 = At;
//      
var In = function In(needle, haystack) {
    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
};
In.parse = function parse(args, context) {
    if (args.length !== 3) return context.error("Expected 2 arguments, but found " + (args.length - 1) + " instead.");
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) return null;
    if (!isValidType(needle.type, [
        BooleanType,
        StringType,
        NumberType,
        NullType,
        ValueType
    ])) return context.error("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(needle.type) + " instead");
    return new In(needle, haystack);
};
In.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (haystack == null) return false;
    if (!isValidNativeType(needle, [
        "boolean",
        "string",
        "number",
        "null"
    ])) throw new RuntimeError$1("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(typeOf(needle)) + " instead.");
    if (!isValidNativeType(haystack, [
        "string",
        "array"
    ])) throw new RuntimeError$1("Expected second argument to be of type array or string, but found " + toString$1(typeOf(haystack)) + " instead.");
    return haystack.indexOf(needle) >= 0;
};
In.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
};
In.prototype.outputDefined = function outputDefined() {
    return true;
};
In.prototype.serialize = function serialize() {
    return [
        "in",
        this.needle.serialize(),
        this.haystack.serialize()
    ];
};
var In$1 = In;
//      
var IndexOf = function IndexOf(needle, haystack, fromIndex) {
    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
};
IndexOf.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) return context.error("Expected 3 or 4 arguments, but found " + (args.length - 1) + " instead.");
    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack) return null;
    if (!isValidType(needle.type, [
        BooleanType,
        StringType,
        NumberType,
        NullType,
        ValueType
    ])) return context.error("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(needle.type) + " instead");
    if (args.length === 4) {
        var fromIndex = context.parse(args[3], 3, NumberType);
        if (!fromIndex) return null;
        return new IndexOf(needle, haystack, fromIndex);
    } else return new IndexOf(needle, haystack);
};
IndexOf.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);
    if (!isValidNativeType(needle, [
        "boolean",
        "string",
        "number",
        "null"
    ])) throw new RuntimeError$1("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(typeOf(needle)) + " instead.");
    if (!isValidNativeType(haystack, [
        "string",
        "array"
    ])) throw new RuntimeError$1("Expected second argument to be of type array or string, but found " + toString$1(typeOf(haystack)) + " instead.");
    if (this.fromIndex) {
        var fromIndex = this.fromIndex.evaluate(ctx);
        return haystack.indexOf(needle, fromIndex);
    }
    return haystack.indexOf(needle);
};
IndexOf.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
    if (this.fromIndex) fn(this.fromIndex);
};
IndexOf.prototype.outputDefined = function outputDefined() {
    return false;
};
IndexOf.prototype.serialize = function serialize() {
    if (this.fromIndex != null && this.fromIndex !== undefined) {
        var fromIndex = this.fromIndex.serialize();
        return [
            "index-of",
            this.needle.serialize(),
            this.haystack.serialize(),
            fromIndex
        ];
    }
    return [
        "index-of",
        this.needle.serialize(),
        this.haystack.serialize()
    ];
};
var IndexOf$1 = IndexOf;
// Map input label values to output expression index
var Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
};
Match.parse = function parse(args, context) {
    if (args.length < 5) return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
    if (args.length % 2 !== 1) return context.error("Expected an even number of arguments.");
    var inputType;
    var outputType;
    if (context.expectedType && context.expectedType.kind !== "value") outputType = context.expectedType;
    var cases = {};
    var outputs = [];
    for(var i = 2; i < args.length - 1; i += 2){
        var labels = args[i];
        var value = args[i + 1];
        if (!Array.isArray(labels)) labels = [
            labels
        ];
        var labelContext = context.concat(i);
        if (labels.length === 0) return labelContext.error("Expected at least one branch label.");
        for(var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1){
            var label = list[i$1];
            if (typeof label !== "number" && typeof label !== "string") return labelContext.error("Branch labels must be numbers or strings.");
            else if (typeof label === "number" && Math.abs(label) > Number.MAX_SAFE_INTEGER) return labelContext.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
            else if (typeof label === "number" && Math.floor(label) !== label) return labelContext.error("Numeric branch labels must be integer values.");
            else if (!inputType) inputType = typeOf(label);
            else if (labelContext.checkSubtype(inputType, typeOf(label))) return null;
            if (typeof cases[String(label)] !== "undefined") return labelContext.error("Branch labels must be unique.");
            cases[String(label)] = outputs.length;
        }
        var result = context.parse(value, i, outputType);
        if (!result) return null;
        outputType = outputType || result.type;
        outputs.push(result);
    }
    var input = context.parse(args[1], 1, ValueType);
    if (!input) return null;
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) return null;
    if (input.type.kind !== "value" && context.concat(1).checkSubtype(inputType, input.type)) return null;
    return new Match(inputType, outputType, input, cases, outputs, otherwise);
};
Match.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
    return output.evaluate(ctx);
};
Match.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
};
Match.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function(out) {
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Match.prototype.serialize = function serialize() {
    var this$1$1 = this;
    var serialized = [
        "match",
        this.input.serialize()
    ];
    // Sort so serialization has an arbitrary defined order, even though
    // branch order doesn't affect evaluation
    var sortedLabels = Object.keys(this.cases).sort();
    // Group branches by unique match expression to support condensed
    // serializations of the form [case1, case2, ...] -> matchExpression
    var groupedByOutput = [];
    var outputLookup = {};
    // lookup index into groupedByOutput for a given output expression
    for(var i = 0, list = sortedLabels; i < list.length; i += 1){
        var label = list[i];
        var outputIndex = outputLookup[this.cases[label]];
        if (outputIndex === undefined) {
            // First time seeing this output, add it to the end of the grouped list
            outputLookup[this.cases[label]] = groupedByOutput.length;
            groupedByOutput.push([
                this.cases[label],
                [
                    label
                ]
            ]);
        } else // We've seen this expression before, add the label to that output's group
        groupedByOutput[outputIndex][1].push(label);
    }
    var coerceLabel = function(label) {
        return this$1$1.inputType.kind === "number" ? Number(label) : label;
    };
    for(var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1){
        var ref = list$1[i$1];
        var outputIndex = ref[0];
        var labels = ref[1];
        if (labels.length === 1) // Only a single label matches this output expression
        serialized.push(coerceLabel(labels[0]));
        else // Array of literal labels pointing to this output expression
        serialized.push(labels.map(coerceLabel));
        serialized.push(this.outputs[outputIndex$1].serialize());
    }
    serialized.push(this.otherwise.serialize());
    return serialized;
};
var Match$1 = Match;
var Case = function Case(type, branches, otherwise) {
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
};
Case.parse = function parse(args, context) {
    if (args.length < 4) return context.error("Expected at least 3 arguments, but found only " + (args.length - 1) + ".");
    if (args.length % 2 !== 0) return context.error("Expected an odd number of arguments.");
    var outputType;
    if (context.expectedType && context.expectedType.kind !== "value") outputType = context.expectedType;
    var branches = [];
    for(var i = 1; i < args.length - 1; i += 2){
        var test = context.parse(args[i], i, BooleanType);
        if (!test) return null;
        var result = context.parse(args[i + 1], i + 1, outputType);
        if (!result) return null;
        branches.push([
            test,
            result
        ]);
        outputType = outputType || result.type;
    }
    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise) return null;
    return new Case(outputType, branches, otherwise);
};
Case.prototype.evaluate = function evaluate(ctx) {
    for(var i = 0, list = this.branches; i < list.length; i += 1){
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        if (test.evaluate(ctx)) return expression.evaluate(ctx);
    }
    return this.otherwise.evaluate(ctx);
};
Case.prototype.eachChild = function eachChild(fn) {
    for(var i = 0, list = this.branches; i < list.length; i += 1){
        var ref = list[i];
        var test = ref[0];
        var expression = ref[1];
        fn(test);
        fn(expression);
    }
    fn(this.otherwise);
};
Case.prototype.outputDefined = function outputDefined() {
    return this.branches.every(function(ref) {
        ref[0];
        var out = ref[1];
        return out.outputDefined();
    }) && this.otherwise.outputDefined();
};
Case.prototype.serialize = function serialize() {
    var serialized = [
        "case"
    ];
    this.eachChild(function(child) {
        serialized.push(child.serialize());
    });
    return serialized;
};
var Case$1 = Case;
//      
var Slice = function Slice(type, input, beginIndex, endIndex) {
    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
};
Slice.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) return context.error("Expected 3 or 4 arguments, but found " + (args.length - 1) + " instead.");
    var input = context.parse(args[1], 1, ValueType);
    var beginIndex = context.parse(args[2], 2, NumberType);
    if (!input || !beginIndex) return null;
    if (!isValidType(input.type, [
        array$1(ValueType),
        StringType,
        ValueType
    ])) return context.error("Expected first argument to be of type array or string, but found " + toString$1(input.type) + " instead");
    if (args.length === 4) {
        var endIndex = context.parse(args[3], 3, NumberType);
        if (!endIndex) return null;
        return new Slice(input.type, input, beginIndex, endIndex);
    } else return new Slice(input.type, input, beginIndex);
};
Slice.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var beginIndex = this.beginIndex.evaluate(ctx);
    if (!isValidNativeType(input, [
        "string",
        "array"
    ])) throw new RuntimeError$1("Expected first argument to be of type array or string, but found " + toString$1(typeOf(input)) + " instead.");
    if (this.endIndex) {
        var endIndex = this.endIndex.evaluate(ctx);
        return input.slice(beginIndex, endIndex);
    }
    return input.slice(beginIndex);
};
Slice.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    fn(this.beginIndex);
    if (this.endIndex) fn(this.endIndex);
};
Slice.prototype.outputDefined = function outputDefined() {
    return false;
};
Slice.prototype.serialize = function serialize() {
    if (this.endIndex != null && this.endIndex !== undefined) {
        var endIndex = this.endIndex.serialize();
        return [
            "slice",
            this.input.serialize(),
            this.beginIndex.serialize(),
            endIndex
        ];
    }
    return [
        "slice",
        this.input.serialize(),
        this.beginIndex.serialize()
    ];
};
var Slice$1 = Slice;
//      
function isComparableType(op, type) {
    if (op === "==" || op === "!=") // equality operator
    return type.kind === "boolean" || type.kind === "string" || type.kind === "number" || type.kind === "null" || type.kind === "value";
    else // ordering operator
    return type.kind === "string" || type.kind === "number" || type.kind === "value";
}
function eq(ctx, a, b) {
    return a === b;
}
function neq(ctx, a, b) {
    return a !== b;
}
function lt(ctx, a, b) {
    return a < b;
}
function gt(ctx, a, b) {
    return a > b;
}
function lteq(ctx, a, b) {
    return a <= b;
}
function gteq(ctx, a, b) {
    return a >= b;
}
function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
}
/**
 * Special form for comparison operators, implementing the signatures:
 * - (T, T, ?Collator) => boolean
 * - (T, value, ?Collator) => boolean
 * - (value, T, ?Collator) => boolean
 *
 * For inequalities, T must be either value, string, or number. For ==/!=, it
 * can also be boolean or null.
 *
 * Equality semantics are equivalent to Javascript's strict equality (===/!==)
 * -- i.e., when the arguments' types don't match, == evaluates to false, != to
 * true.
 *
 * When types don't match in an ordering comparison, a runtime error is thrown.
 *
 * @private
 */ function makeComparison(op, compareBasic, compareWithCollator) {
    var isOrderComparison = op !== "==" && op !== "!=";
    return /*@__PURE__*/ function() {
        function Comparison(lhs, rhs, collator) {
            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === "value" || rhs.type.kind === "value";
        }
        Comparison.parse = function parse(args, context) {
            if (args.length !== 3 && args.length !== 4) return context.error("Expected two or three arguments.");
            var op = args[0];
            var lhs = context.parse(args[1], 1, ValueType);
            if (!lhs) return null;
            if (!isComparableType(op, lhs.type)) return context.concat(1).error('"' + op + "\" comparisons are not supported for type '" + toString$1(lhs.type) + "'.");
            var rhs = context.parse(args[2], 2, ValueType);
            if (!rhs) return null;
            if (!isComparableType(op, rhs.type)) return context.concat(2).error('"' + op + "\" comparisons are not supported for type '" + toString$1(rhs.type) + "'.");
            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== "value" && rhs.type.kind !== "value") return context.error("Cannot compare types '" + toString$1(lhs.type) + "' and '" + toString$1(rhs.type) + "'.");
            if (isOrderComparison) {
                // typing rules specific to less/greater than operators
                if (lhs.type.kind === "value" && rhs.type.kind !== "value") // (value, T)
                lhs = new Assertion$1(rhs.type, [
                    lhs
                ]);
                else if (lhs.type.kind !== "value" && rhs.type.kind === "value") // (T, value)
                rhs = new Assertion$1(lhs.type, [
                    rhs
                ]);
            }
            var collator = null;
            if (args.length === 4) {
                if (lhs.type.kind !== "string" && rhs.type.kind !== "string" && lhs.type.kind !== "value" && rhs.type.kind !== "value") return context.error("Cannot use collator to compare non-string types.");
                collator = context.parse(args[3], 3, CollatorType);
                if (!collator) return null;
            }
            return new Comparison(lhs, rhs, collator);
        };
        Comparison.prototype.evaluate = function evaluate(ctx) {
            var lhs = this.lhs.evaluate(ctx);
            var rhs = this.rhs.evaluate(ctx);
            if (isOrderComparison && this.hasUntypedArgument) {
                var lt = typeOf(lhs);
                var rt = typeOf(rhs);
                // check that type is string or number, and equal
                if (lt.kind !== rt.kind || !(lt.kind === "string" || lt.kind === "number")) throw new RuntimeError$1('Expected arguments for "' + op + '" to be (string, string) or (number, number), but found (' + lt.kind + ", " + rt.kind + ") instead.");
            }
            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                var lt$1 = typeOf(lhs);
                var rt$1 = typeOf(rhs);
                if (lt$1.kind !== "string" || rt$1.kind !== "string") return compareBasic(ctx, lhs, rhs);
            }
            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
        };
        Comparison.prototype.eachChild = function eachChild(fn) {
            fn(this.lhs);
            fn(this.rhs);
            if (this.collator) fn(this.collator);
        };
        Comparison.prototype.outputDefined = function outputDefined() {
            return true;
        };
        Comparison.prototype.serialize = function serialize() {
            var serialized = [
                op
            ];
            this.eachChild(function(child) {
                serialized.push(child.serialize());
            });
            return serialized;
        };
        return Comparison;
    }();
}
var Equals = makeComparison("==", eq, eqCollate);
var NotEquals = makeComparison("!=", neq, neqCollate);
var LessThan = makeComparison("<", lt, ltCollate);
var GreaterThan = makeComparison(">", gt, gtCollate);
var LessThanOrEqual = makeComparison("<=", lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison(">=", gteq, gteqCollate);
//      
var NumberFormat = function NumberFormat(number, locale, currency, unit, minFractionDigits, maxFractionDigits) {
    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.unit = unit;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
};
NumberFormat.parse = function parse(args, context) {
    if (args.length !== 3) return context.error("Expected two arguments.");
    var number = context.parse(args[1], 1, NumberType);
    if (!number) return null;
    var options = args[2];
    if (typeof options !== "object" || Array.isArray(options)) return context.error("NumberFormat options argument must be an object.");
    var locale = null;
    if (options["locale"]) {
        locale = context.parse(options["locale"], 1, StringType);
        if (!locale) return null;
    }
    var currency = null;
    if (options["currency"]) {
        currency = context.parse(options["currency"], 1, StringType);
        if (!currency) return null;
    }
    var unit = null;
    if (options["unit"]) {
        unit = context.parse(options["unit"], 1, StringType);
        if (!unit) return null;
    }
    var minFractionDigits = null;
    if (options["min-fraction-digits"]) {
        minFractionDigits = context.parse(options["min-fraction-digits"], 1, NumberType);
        if (!minFractionDigits) return null;
    }
    var maxFractionDigits = null;
    if (options["max-fraction-digits"]) {
        maxFractionDigits = context.parse(options["max-fraction-digits"], 1, NumberType);
        if (!maxFractionDigits) return null;
    }
    return new NumberFormat(number, locale, currency, unit, minFractionDigits, maxFractionDigits);
};
NumberFormat.prototype.evaluate = function evaluate(ctx) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
        style: this.currency && "currency" || this.unit && "unit" || "decimal",
        currency: this.currency ? this.currency.evaluate(ctx) : undefined,
        unit: this.unit ? this.unit.evaluate(ctx) : undefined,
        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
    }).format(this.number.evaluate(ctx));
};
NumberFormat.prototype.eachChild = function eachChild(fn) {
    fn(this.number);
    if (this.locale) fn(this.locale);
    if (this.currency) fn(this.currency);
    if (this.unit) fn(this.unit);
    if (this.minFractionDigits) fn(this.minFractionDigits);
    if (this.maxFractionDigits) fn(this.maxFractionDigits);
};
NumberFormat.prototype.outputDefined = function outputDefined() {
    return false;
};
NumberFormat.prototype.serialize = function serialize() {
    var options = {};
    if (this.locale) options["locale"] = this.locale.serialize();
    if (this.currency) options["currency"] = this.currency.serialize();
    if (this.unit) options["unit"] = this.unit.serialize();
    if (this.minFractionDigits) options["min-fraction-digits"] = this.minFractionDigits.serialize();
    if (this.maxFractionDigits) options["max-fraction-digits"] = this.maxFractionDigits.serialize();
    return [
        "number-format",
        this.number.serialize(),
        options
    ];
};
var NumberFormat$1 = NumberFormat;
//      
var Length = function Length(input) {
    this.type = NumberType;
    this.input = input;
};
Length.parse = function parse(args, context) {
    if (args.length !== 2) return context.error("Expected 1 argument, but found " + (args.length - 1) + " instead.");
    var input = context.parse(args[1], 1);
    if (!input) return null;
    if (input.type.kind !== "array" && input.type.kind !== "string" && input.type.kind !== "value") return context.error("Expected argument of type string or array, but found " + toString$1(input.type) + " instead.");
    return new Length(input);
};
Length.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    if (typeof input === "string") return input.length;
    else if (Array.isArray(input)) return input.length;
    else throw new RuntimeError$1("Expected value to be of type string or array, but found " + toString$1(typeOf(input)) + " instead.");
};
Length.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
};
Length.prototype.outputDefined = function outputDefined() {
    return false;
};
Length.prototype.serialize = function serialize() {
    var serialized = [
        "length"
    ];
    this.eachChild(function(child) {
        serialized.push(child.serialize());
    });
    return serialized;
};
var Length$1 = Length;
//      
var expressions = {
    // special forms
    "==": Equals,
    "!=": NotEquals,
    ">": GreaterThan,
    "<": LessThan,
    ">=": GreaterThanOrEqual,
    "<=": LessThanOrEqual,
    "array": Assertion$1,
    "at": At$1,
    "boolean": Assertion$1,
    "case": Case$1,
    "coalesce": Coalesce$1,
    "collator": CollatorExpression$1,
    "format": FormatExpression$1,
    "image": ImageExpression$1,
    "in": In$1,
    "index-of": IndexOf$1,
    "interpolate": Interpolate$1,
    "interpolate-hcl": Interpolate$1,
    "interpolate-lab": Interpolate$1,
    "length": Length$1,
    "let": Let$1,
    "literal": Literal$1,
    "match": Match$1,
    "number": Assertion$1,
    "number-format": NumberFormat$1,
    "object": Assertion$1,
    "slice": Slice$1,
    "step": Step$1,
    "string": Assertion$1,
    "to-boolean": Coercion$1,
    "to-color": Coercion$1,
    "to-number": Coercion$1,
    "to-string": Coercion$1,
    "var": Var$1,
    "within": Within$1
};
function rgba(ctx, ref) {
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    var alpha = a ? a.evaluate(ctx) : 1;
    var error = validateRGBA(r, g, b, alpha);
    if (error) throw new RuntimeError$1(error);
    return new Color$1(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}
function has(key, obj) {
    return key in obj;
}
function get(key, obj) {
    var v = obj[key];
    return typeof v === "undefined" ? null : v;
}
function binarySearch(v, a, i, j) {
    while(i <= j){
        var m = i + j >> 1;
        if (a[m] === v) return true;
        if (a[m] > v) j = m - 1;
        else i = m + 1;
    }
    return false;
}
function varargs(type) {
    return {
        type: type
    };
}
CompoundExpression$1.register(expressions, {
    "error": [
        ErrorType,
        [
            StringType
        ],
        function(ctx, ref) {
            var v = ref[0];
            throw new RuntimeError$1(v.evaluate(ctx));
        }
    ],
    "typeof": [
        StringType,
        [
            ValueType
        ],
        function(ctx, ref) {
            var v = ref[0];
            return toString$1(typeOf(v.evaluate(ctx)));
        }
    ],
    "to-rgba": [
        array$1(NumberType, 4),
        [
            ColorType
        ],
        function(ctx, ref) {
            var v = ref[0];
            return v.evaluate(ctx).toArray();
        }
    ],
    "rgb": [
        ColorType,
        [
            NumberType,
            NumberType,
            NumberType
        ],
        rgba
    ],
    "rgba": [
        ColorType,
        [
            NumberType,
            NumberType,
            NumberType,
            NumberType
        ],
        rgba
    ],
    "has": {
        type: BooleanType,
        overloads: [
            [
                [
                    StringType
                ],
                function(ctx, ref) {
                    var key = ref[0];
                    return has(key.evaluate(ctx), ctx.properties());
                }
            ],
            [
                [
                    StringType,
                    ObjectType
                ],
                function(ctx, ref) {
                    var key = ref[0];
                    var obj = ref[1];
                    return has(key.evaluate(ctx), obj.evaluate(ctx));
                }
            ]
        ]
    },
    "get": {
        type: ValueType,
        overloads: [
            [
                [
                    StringType
                ],
                function(ctx, ref) {
                    var key = ref[0];
                    return get(key.evaluate(ctx), ctx.properties());
                }
            ],
            [
                [
                    StringType,
                    ObjectType
                ],
                function(ctx, ref) {
                    var key = ref[0];
                    var obj = ref[1];
                    return get(key.evaluate(ctx), obj.evaluate(ctx));
                }
            ]
        ]
    },
    "feature-state": [
        ValueType,
        [
            StringType
        ],
        function(ctx, ref) {
            var key = ref[0];
            return get(key.evaluate(ctx), ctx.featureState || {});
        }
    ],
    "properties": [
        ObjectType,
        [],
        function(ctx) {
            return ctx.properties();
        }
    ],
    "geometry-type": [
        StringType,
        [],
        function(ctx) {
            return ctx.geometryType();
        }
    ],
    "id": [
        ValueType,
        [],
        function(ctx) {
            return ctx.id();
        }
    ],
    "zoom": [
        NumberType,
        [],
        function(ctx) {
            return ctx.globals.zoom;
        }
    ],
    "pitch": [
        NumberType,
        [],
        function(ctx) {
            return ctx.globals.pitch || 0;
        }
    ],
    "distance-from-center": [
        NumberType,
        [],
        function(ctx) {
            return ctx.distanceFromCenter();
        }
    ],
    "heatmap-density": [
        NumberType,
        [],
        function(ctx) {
            return ctx.globals.heatmapDensity || 0;
        }
    ],
    "line-progress": [
        NumberType,
        [],
        function(ctx) {
            return ctx.globals.lineProgress || 0;
        }
    ],
    "sky-radial-progress": [
        NumberType,
        [],
        function(ctx) {
            return ctx.globals.skyRadialProgress || 0;
        }
    ],
    "accumulated": [
        ValueType,
        [],
        function(ctx) {
            return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
        }
    ],
    "+": [
        NumberType,
        varargs(NumberType),
        function(ctx, args) {
            var result = 0;
            for(var i = 0, list = args; i < list.length; i += 1){
                var arg = list[i];
                result += arg.evaluate(ctx);
            }
            return result;
        }
    ],
    "*": [
        NumberType,
        varargs(NumberType),
        function(ctx, args) {
            var result = 1;
            for(var i = 0, list = args; i < list.length; i += 1){
                var arg = list[i];
                result *= arg.evaluate(ctx);
            }
            return result;
        }
    ],
    "-": {
        type: NumberType,
        overloads: [
            [
                [
                    NumberType,
                    NumberType
                ],
                function(ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];
                    return a.evaluate(ctx) - b.evaluate(ctx);
                }
            ],
            [
                [
                    NumberType
                ],
                function(ctx, ref) {
                    var a = ref[0];
                    return -a.evaluate(ctx);
                }
            ]
        ]
    },
    "/": [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        function(ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) / b.evaluate(ctx);
        }
    ],
    "%": [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        function(ctx, ref) {
            var a = ref[0];
            var b = ref[1];
            return a.evaluate(ctx) % b.evaluate(ctx);
        }
    ],
    "ln2": [
        NumberType,
        [],
        function() {
            return Math.LN2;
        }
    ],
    "pi": [
        NumberType,
        [],
        function() {
            return Math.PI;
        }
    ],
    "e": [
        NumberType,
        [],
        function() {
            return Math.E;
        }
    ],
    "^": [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        function(ctx, ref) {
            var b = ref[0];
            var e = ref[1];
            return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
        }
    ],
    "sqrt": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var x = ref[0];
            return Math.sqrt(x.evaluate(ctx));
        }
    ],
    "log10": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.log(n.evaluate(ctx)) / Math.LN10;
        }
    ],
    "ln": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.log(n.evaluate(ctx));
        }
    ],
    "log2": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.log(n.evaluate(ctx)) / Math.LN2;
        }
    ],
    "sin": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.sin(n.evaluate(ctx));
        }
    ],
    "cos": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.cos(n.evaluate(ctx));
        }
    ],
    "tan": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.tan(n.evaluate(ctx));
        }
    ],
    "asin": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.asin(n.evaluate(ctx));
        }
    ],
    "acos": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.acos(n.evaluate(ctx));
        }
    ],
    "atan": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.atan(n.evaluate(ctx));
        }
    ],
    "min": [
        NumberType,
        varargs(NumberType),
        function(ctx, args) {
            return Math.min.apply(Math, args.map(function(arg) {
                return arg.evaluate(ctx);
            }));
        }
    ],
    "max": [
        NumberType,
        varargs(NumberType),
        function(ctx, args) {
            return Math.max.apply(Math, args.map(function(arg) {
                return arg.evaluate(ctx);
            }));
        }
    ],
    "abs": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.abs(n.evaluate(ctx));
        }
    ],
    "round": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            var v = n.evaluate(ctx);
            // Javascript's Math.round() rounds towards +Infinity for halfway
            // values, even when they're negative. It's more common to round
            // away from 0 (e.g., this is what python and C++ do)
            return v < 0 ? -Math.round(-v) : Math.round(v);
        }
    ],
    "floor": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.floor(n.evaluate(ctx));
        }
    ],
    "ceil": [
        NumberType,
        [
            NumberType
        ],
        function(ctx, ref) {
            var n = ref[0];
            return Math.ceil(n.evaluate(ctx));
        }
    ],
    "filter-==": [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function(ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            return ctx.properties()[k.value] === v.value;
        }
    ],
    "filter-id-==": [
        BooleanType,
        [
            ValueType
        ],
        function(ctx, ref) {
            var v = ref[0];
            return ctx.id() === v.value;
        }
    ],
    "filter-type-==": [
        BooleanType,
        [
            StringType
        ],
        function(ctx, ref) {
            var v = ref[0];
            return ctx.geometryType() === v.value;
        }
    ],
    "filter-<": [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function(ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a < b;
        }
    ],
    "filter-id-<": [
        BooleanType,
        [
            ValueType
        ],
        function(ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a < b;
        }
    ],
    "filter->": [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function(ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a > b;
        }
    ],
    "filter-id->": [
        BooleanType,
        [
            ValueType
        ],
        function(ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a > b;
        }
    ],
    "filter-<=": [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function(ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a <= b;
        }
    ],
    "filter-id-<=": [
        BooleanType,
        [
            ValueType
        ],
        function(ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a <= b;
        }
    ],
    "filter->=": [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        function(ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            var a = ctx.properties()[k.value];
            var b = v.value;
            return typeof a === typeof b && a >= b;
        }
    ],
    "filter-id->=": [
        BooleanType,
        [
            ValueType
        ],
        function(ctx, ref) {
            var v = ref[0];
            var a = ctx.id();
            var b = v.value;
            return typeof a === typeof b && a >= b;
        }
    ],
    "filter-has": [
        BooleanType,
        [
            ValueType
        ],
        function(ctx, ref) {
            var k = ref[0];
            return k.value in ctx.properties();
        }
    ],
    "filter-has-id": [
        BooleanType,
        [],
        function(ctx) {
            return ctx.id() !== null && ctx.id() !== undefined;
        }
    ],
    "filter-type-in": [
        BooleanType,
        [
            array$1(StringType)
        ],
        function(ctx, ref) {
            var v = ref[0];
            return v.value.indexOf(ctx.geometryType()) >= 0;
        }
    ],
    "filter-id-in": [
        BooleanType,
        [
            array$1(ValueType)
        ],
        function(ctx, ref) {
            var v = ref[0];
            return v.value.indexOf(ctx.id()) >= 0;
        }
    ],
    "filter-in-small": [
        BooleanType,
        [
            StringType,
            array$1(ValueType)
        ],
        // assumes v is an array literal
        function(ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            return v.value.indexOf(ctx.properties()[k.value]) >= 0;
        }
    ],
    "filter-in-large": [
        BooleanType,
        [
            StringType,
            array$1(ValueType)
        ],
        // assumes v is a array literal with values sorted in ascending order and of a single type
        function(ctx, ref) {
            var k = ref[0];
            var v = ref[1];
            return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
        }
    ],
    "all": {
        type: BooleanType,
        overloads: [
            [
                [
                    BooleanType,
                    BooleanType
                ],
                function(ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];
                    return a.evaluate(ctx) && b.evaluate(ctx);
                }
            ],
            [
                varargs(BooleanType),
                function(ctx, args) {
                    for(var i = 0, list = args; i < list.length; i += 1){
                        var arg = list[i];
                        if (!arg.evaluate(ctx)) return false;
                    }
                    return true;
                }
            ]
        ]
    },
    "any": {
        type: BooleanType,
        overloads: [
            [
                [
                    BooleanType,
                    BooleanType
                ],
                function(ctx, ref) {
                    var a = ref[0];
                    var b = ref[1];
                    return a.evaluate(ctx) || b.evaluate(ctx);
                }
            ],
            [
                varargs(BooleanType),
                function(ctx, args) {
                    for(var i = 0, list = args; i < list.length; i += 1){
                        var arg = list[i];
                        if (arg.evaluate(ctx)) return true;
                    }
                    return false;
                }
            ]
        ]
    },
    "!": [
        BooleanType,
        [
            BooleanType
        ],
        function(ctx, ref) {
            var b = ref[0];
            return !b.evaluate(ctx);
        }
    ],
    "is-supported-script": [
        BooleanType,
        [
            StringType
        ],
        // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
        function(ctx, ref) {
            var s = ref[0];
            var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
            if (isSupportedScript) return isSupportedScript(s.evaluate(ctx));
            return true;
        }
    ],
    "upcase": [
        StringType,
        [
            StringType
        ],
        function(ctx, ref) {
            var s = ref[0];
            return s.evaluate(ctx).toUpperCase();
        }
    ],
    "downcase": [
        StringType,
        [
            StringType
        ],
        function(ctx, ref) {
            var s = ref[0];
            return s.evaluate(ctx).toLowerCase();
        }
    ],
    "concat": [
        StringType,
        varargs(ValueType),
        function(ctx, args) {
            return args.map(function(arg) {
                return toString(arg.evaluate(ctx));
            }).join("");
        }
    ],
    "resolved-locale": [
        StringType,
        [
            CollatorType
        ],
        function(ctx, ref) {
            var collator = ref[0];
            return collator.evaluate(ctx).resolvedLocale();
        }
    ]
});
var definitions = expressions;
//      
/**
 * A type used for returning and propagating errors. The first element of the union
 * represents success and contains a value, and the second represents an error and
 * contains an error value.
 * @private
 */ function success(value) {
    return {
        result: "success",
        value: value
    };
}
function error(value) {
    return {
        result: "error",
        value: value
    };
}
//      
function supportsPropertyExpression(spec) {
    return spec["property-type"] === "data-driven" || spec["property-type"] === "cross-faded-data-driven";
}
function supportsZoomExpression(spec) {
    return !!spec.expression && spec.expression.parameters.indexOf("zoom") > -1;
}
function supportsInterpolation(spec) {
    return !!spec.expression && spec.expression.interpolated;
}
function isFunction(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
}
var StyleExpression = function StyleExpression(expression, propertySpec) {
    this.expression = expression;
    this._warningHistory = {};
    this._evaluator = new EvaluationContext$1();
    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
    this._enumValues = propertySpec && propertySpec.type === "enum" ? propertySpec.values : null;
};
StyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature;
    this._evaluator.featureState = featureState;
    this._evaluator.canonical = canonical || null;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection;
    this._evaluator.featureTileCoord = featureTileCoord || null;
    this._evaluator.featureDistanceData = featureDistanceData || null;
    return this.expression.evaluate(this._evaluator);
};
StyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature || null;
    this._evaluator.featureState = featureState || null;
    this._evaluator.canonical = canonical || null;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection || null;
    this._evaluator.featureTileCoord = featureTileCoord || null;
    this._evaluator.featureDistanceData = featureDistanceData || null;
    try {
        var val = this.expression.evaluate(this._evaluator);
        // eslint-disable-next-line no-self-compare
        if (val === null || val === undefined || typeof val === "number" && val !== val) return this._defaultValue;
        if (this._enumValues && !(val in this._enumValues)) throw new RuntimeError$1("Expected value to be one of " + Object.keys(this._enumValues).map(function(v) {
            return JSON.stringify(v);
        }).join(", ") + ", but found " + JSON.stringify(val) + " instead.");
        return val;
    } catch (e) {
        if (!this._warningHistory[e.message]) {
            this._warningHistory[e.message] = true;
            if (typeof console !== "undefined") console.warn(e.message);
        }
        return this._defaultValue;
    }
};
function isExpression(expression) {
    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === "string" && expression[0] in definitions;
}
/**
 * Parse and typecheck the given style spec JSON expression.  If
 * options.defaultValue is provided, then the resulting StyleExpression's
 * `evaluate()` method will handle errors by logging a warning (once per
 * message) and returning the default value.  Otherwise, it will throw
 * evaluation errors.
 *
 * @private
 */ function createExpression(expression, propertySpec) {
    var parser = new ParsingContext$1(definitions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
    // For string-valued properties, coerce to string at the top level rather than asserting.
    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === "string" ? {
        typeAnnotation: "coerce"
    } : undefined);
    if (!parsed) return error(parser.errors);
    return success(new StyleExpression(parsed, propertySpec));
}
var ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {
    this.kind = kind;
    this._styleExpression = expression;
    this.isStateDependent = kind !== "constant" && !isStateConstant(expression.expression);
};
ZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
var ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {
    this.kind = kind;
    this.zoomStops = zoomStops;
    this._styleExpression = expression;
    this.isStateDependent = kind !== "camera" && !isStateConstant(expression.expression);
    this.interpolationType = interpolationType;
};
ZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
};
ZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {
    if (this.interpolationType) return Interpolate$1.interpolationFactor(this.interpolationType, input, lower, upper);
    else return 0;
};
function createPropertyExpression(expression, propertySpec) {
    expression = createExpression(expression, propertySpec);
    if (expression.result === "error") return expression;
    var parsed = expression.value.expression;
    var isFeatureConstant$1 = isFeatureConstant(parsed);
    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) return error([
        new ParsingError$1("", "data expressions not supported")
    ]);
    var isZoomConstant = isGlobalPropertyConstant(parsed, [
        "zoom",
        "pitch",
        "distance-from-center"
    ]);
    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) return error([
        new ParsingError$1("", "zoom expressions not supported")
    ]);
    var zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve && !isZoomConstant) return error([
        new ParsingError$1("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')
    ]);
    else if (zoomCurve instanceof ParsingError$1) return error([
        zoomCurve
    ]);
    else if (zoomCurve instanceof Interpolate$1 && !supportsInterpolation(propertySpec)) return error([
        new ParsingError$1("", '"interpolate" expressions cannot be used with this property')
    ]);
    if (!zoomCurve) return success(isFeatureConstant$1 ? new ZoomConstantExpression("constant", expression.value) : new ZoomConstantExpression("source", expression.value));
    var interpolationType = zoomCurve instanceof Interpolate$1 ? zoomCurve.interpolation : undefined;
    return success(isFeatureConstant$1 ? new ZoomDependentExpression("camera", expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression("composite", expression.value, zoomCurve.labels, interpolationType));
}
// Zoom-dependent expressions may only use ["zoom"] as the input to a top-level "step" or "interpolate"
// expression (collectively referred to as a "curve"). The curve may be wrapped in one or more "let" or
// "coalesce" expressions.
function findZoomCurve(expression) {
    var result = null;
    if (expression instanceof Let$1) result = findZoomCurve(expression.result);
    else if (expression instanceof Coalesce$1) for(var i = 0, list = expression.args; i < list.length; i += 1){
        var arg = list[i];
        result = findZoomCurve(arg);
        if (result) break;
    }
    else if ((expression instanceof Step$1 || expression instanceof Interpolate$1) && expression.input instanceof CompoundExpression$1 && expression.input.name === "zoom") result = expression;
    if (result instanceof ParsingError$1) return result;
    expression.eachChild(function(child) {
        var childResult = findZoomCurve(child);
        if (childResult instanceof ParsingError$1) result = childResult;
        else if (!result && childResult) result = new ParsingError$1("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
        else if (result && childResult && result !== childResult) result = new ParsingError$1("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
    });
    return result;
}
function getExpectedType(spec) {
    var types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType,
        formatted: FormattedType,
        resolvedImage: ResolvedImageType
    };
    if (spec.type === "array") return array$1(types[spec.value] || ValueType, spec.length);
    return types[spec.type];
}
function getDefaultValue(spec) {
    if (spec.type === "color" && (isFunction(spec.default) || Array.isArray(spec.default))) // Special case for heatmap-color: it uses the 'default:' to define a
    // default color ramp, but createExpression expects a simple value to fall
    // back to in case of runtime errors
    return new Color$1(0, 0, 0, 0);
    else if (spec.type === "color") return Color$1.parse(spec.default) || null;
    else if (spec.default === undefined) return null;
    else return spec.default;
}
//      
// Turn jsonlint-lines-primitives objects into primitive objects
function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) return value.valueOf();
    else return value;
}
function deepUnbundle(value) {
    if (Array.isArray(value)) return value.map(deepUnbundle);
    else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
        var unbundledValue = {};
        for(var key in value)unbundledValue[key] = deepUnbundle(value[key]);
        return unbundledValue;
    }
    return unbundle(value);
}
var spec = {
    "$version": 8,
    "$root": {
        "version": {
            "required": true,
            "type": "enum",
            "values": [
                8
            ]
        },
        "name": {
            "type": "string"
        },
        "metadata": {
            "type": "*"
        },
        "center": {
            "type": "array",
            "value": "number"
        },
        "zoom": {
            "type": "number"
        },
        "bearing": {
            "type": "number",
            "default": 0,
            "period": 360,
            "units": "degrees"
        },
        "pitch": {
            "type": "number",
            "default": 0,
            "units": "degrees"
        },
        "light": {
            "type": "light"
        },
        "terrain": {
            "type": "terrain"
        },
        "fog": {
            "type": "fog"
        },
        "sources": {
            "required": true,
            "type": "sources"
        },
        "sprite": {
            "type": "string"
        },
        "glyphs": {
            "type": "string"
        },
        "transition": {
            "type": "transition"
        },
        "projection": {
            "type": "projection"
        },
        "layers": {
            "required": true,
            "type": "array",
            "value": "layer"
        }
    },
    "sources": {
        "*": {
            "type": "source"
        }
    },
    "source": [
        "source_vector",
        "source_raster",
        "source_raster_dem",
        "source_geojson",
        "source_video",
        "source_image"
    ],
    "source_vector": {
        "type": {
            "required": true,
            "type": "enum",
            "values": {
                "vector": {}
            }
        },
        "url": {
            "type": "string"
        },
        "tiles": {
            "type": "array",
            "value": "string"
        },
        "bounds": {
            "type": "array",
            "value": "number",
            "length": 4,
            "default": [
                -180,
                -85.051129,
                180,
                85.051129
            ]
        },
        "scheme": {
            "type": "enum",
            "values": {
                "xyz": {},
                "tms": {}
            },
            "default": "xyz"
        },
        "minzoom": {
            "type": "number",
            "default": 0
        },
        "maxzoom": {
            "type": "number",
            "default": 22
        },
        "attribution": {
            "type": "string"
        },
        "promoteId": {
            "type": "promoteId"
        },
        "volatile": {
            "type": "boolean",
            "default": false
        },
        "*": {
            "type": "*"
        }
    },
    "source_raster": {
        "type": {
            "required": true,
            "type": "enum",
            "values": {
                "raster": {}
            }
        },
        "url": {
            "type": "string"
        },
        "tiles": {
            "type": "array",
            "value": "string"
        },
        "bounds": {
            "type": "array",
            "value": "number",
            "length": 4,
            "default": [
                -180,
                -85.051129,
                180,
                85.051129
            ]
        },
        "minzoom": {
            "type": "number",
            "default": 0
        },
        "maxzoom": {
            "type": "number",
            "default": 22
        },
        "tileSize": {
            "type": "number",
            "default": 512,
            "units": "pixels"
        },
        "scheme": {
            "type": "enum",
            "values": {
                "xyz": {},
                "tms": {}
            },
            "default": "xyz"
        },
        "attribution": {
            "type": "string"
        },
        "volatile": {
            "type": "boolean",
            "default": false
        },
        "*": {
            "type": "*"
        }
    },
    "source_raster_dem": {
        "type": {
            "required": true,
            "type": "enum",
            "values": {
                "raster-dem": {}
            }
        },
        "url": {
            "type": "string"
        },
        "tiles": {
            "type": "array",
            "value": "string"
        },
        "bounds": {
            "type": "array",
            "value": "number",
            "length": 4,
            "default": [
                -180,
                -85.051129,
                180,
                85.051129
            ]
        },
        "minzoom": {
            "type": "number",
            "default": 0
        },
        "maxzoom": {
            "type": "number",
            "default": 22
        },
        "tileSize": {
            "type": "number",
            "default": 512,
            "units": "pixels"
        },
        "attribution": {
            "type": "string"
        },
        "encoding": {
            "type": "enum",
            "values": {
                "terrarium": {},
                "mapbox": {}
            },
            "default": "mapbox"
        },
        "volatile": {
            "type": "boolean",
            "default": false
        },
        "*": {
            "type": "*"
        }
    },
    "source_geojson": {
        "type": {
            "required": true,
            "type": "enum",
            "values": {
                "geojson": {}
            }
        },
        "data": {
            "type": "*"
        },
        "maxzoom": {
            "type": "number",
            "default": 18
        },
        "attribution": {
            "type": "string"
        },
        "buffer": {
            "type": "number",
            "default": 128,
            "maximum": 512,
            "minimum": 0
        },
        "filter": {
            "type": "*"
        },
        "tolerance": {
            "type": "number",
            "default": 0.375
        },
        "cluster": {
            "type": "boolean",
            "default": false
        },
        "clusterRadius": {
            "type": "number",
            "default": 50,
            "minimum": 0
        },
        "clusterMaxZoom": {
            "type": "number"
        },
        "clusterMinPoints": {
            "type": "number"
        },
        "clusterProperties": {
            "type": "*"
        },
        "lineMetrics": {
            "type": "boolean",
            "default": false
        },
        "generateId": {
            "type": "boolean",
            "default": false
        },
        "promoteId": {
            "type": "promoteId"
        }
    },
    "source_video": {
        "type": {
            "required": true,
            "type": "enum",
            "values": {
                "video": {}
            }
        },
        "urls": {
            "required": true,
            "type": "array",
            "value": "string"
        },
        "coordinates": {
            "required": true,
            "type": "array",
            "length": 4,
            "value": {
                "type": "array",
                "length": 2,
                "value": "number"
            }
        }
    },
    "source_image": {
        "type": {
            "required": true,
            "type": "enum",
            "values": {
                "image": {}
            }
        },
        "url": {
            "required": true,
            "type": "string"
        },
        "coordinates": {
            "required": true,
            "type": "array",
            "length": 4,
            "value": {
                "type": "array",
                "length": 2,
                "value": "number"
            }
        }
    },
    "layer": {
        "id": {
            "type": "string",
            "required": true
        },
        "type": {
            "type": "enum",
            "values": {
                "fill": {},
                "line": {},
                "symbol": {},
                "circle": {},
                "heatmap": {},
                "fill-extrusion": {},
                "raster": {},
                "hillshade": {},
                "background": {},
                "sky": {}
            },
            "required": true
        },
        "metadata": {
            "type": "*"
        },
        "source": {
            "type": "string"
        },
        "source-layer": {
            "type": "string"
        },
        "minzoom": {
            "type": "number",
            "minimum": 0,
            "maximum": 24
        },
        "maxzoom": {
            "type": "number",
            "minimum": 0,
            "maximum": 24
        },
        "filter": {
            "type": "filter"
        },
        "layout": {
            "type": "layout"
        },
        "paint": {
            "type": "paint"
        }
    },
    "layout": [
        "layout_fill",
        "layout_line",
        "layout_circle",
        "layout_heatmap",
        "layout_fill-extrusion",
        "layout_symbol",
        "layout_raster",
        "layout_hillshade",
        "layout_background",
        "layout_sky"
    ],
    "layout_background": {
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_sky": {
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_fill": {
        "fill-sort-key": {
            "type": "number",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_circle": {
        "circle-sort-key": {
            "type": "number",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_heatmap": {
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_fill-extrusion": {
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        },
        "fill-extrusion-edge-radius": {
            "type": "number",
            "private": true,
            "default": 0,
            "minimum": 0,
            "maximum": 1,
            "property-type": "constant"
        }
    },
    "layout_line": {
        "line-cap": {
            "type": "enum",
            "values": {
                "butt": {},
                "round": {},
                "square": {}
            },
            "default": "butt",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "line-join": {
            "type": "enum",
            "values": {
                "bevel": {},
                "round": {},
                "miter": {}
            },
            "default": "miter",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "line-miter-limit": {
            "type": "number",
            "default": 2,
            "requires": [
                {
                    "line-join": "miter"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "line-round-limit": {
            "type": "number",
            "default": 1.05,
            "requires": [
                {
                    "line-join": "round"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "line-sort-key": {
            "type": "number",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_symbol": {
        "symbol-placement": {
            "type": "enum",
            "values": {
                "point": {},
                "line": {},
                "line-center": {}
            },
            "default": "point",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "symbol-spacing": {
            "type": "number",
            "default": 250,
            "minimum": 1,
            "units": "pixels",
            "requires": [
                {
                    "symbol-placement": "line"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "symbol-avoid-edges": {
            "type": "boolean",
            "default": false,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "symbol-sort-key": {
            "type": "number",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "symbol-z-order": {
            "type": "enum",
            "values": {
                "auto": {},
                "viewport-y": {},
                "source": {}
            },
            "default": "auto",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-allow-overlap": {
            "type": "boolean",
            "default": false,
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-ignore-placement": {
            "type": "boolean",
            "default": false,
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-optional": {
            "type": "boolean",
            "default": false,
            "requires": [
                "icon-image",
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-rotation-alignment": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {},
                "auto": {}
            },
            "default": "auto",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-size": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "units": "factor of the original icon size",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-text-fit": {
            "type": "enum",
            "values": {
                "none": {},
                "width": {},
                "height": {},
                "both": {}
            },
            "default": "none",
            "requires": [
                "icon-image",
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-text-fit-padding": {
            "type": "array",
            "value": "number",
            "length": 4,
            "default": [
                0,
                0,
                0,
                0
            ],
            "units": "pixels",
            "requires": [
                "icon-image",
                "text-field",
                {
                    "icon-text-fit": [
                        "both",
                        "width",
                        "height"
                    ]
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-image": {
            "type": "resolvedImage",
            "tokens": true,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-rotate": {
            "type": "number",
            "default": 0,
            "period": 360,
            "units": "degrees",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-padding": {
            "type": "number",
            "default": 2,
            "minimum": 0,
            "units": "pixels",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-keep-upright": {
            "type": "boolean",
            "default": false,
            "requires": [
                "icon-image",
                {
                    "icon-rotation-alignment": "map"
                },
                {
                    "symbol-placement": [
                        "line",
                        "line-center"
                    ]
                }
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-offset": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-anchor": {
            "type": "enum",
            "values": {
                "center": {},
                "left": {},
                "right": {},
                "top": {},
                "bottom": {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
            },
            "default": "center",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-pitch-alignment": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {},
                "auto": {}
            },
            "default": "auto",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-pitch-alignment": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {},
                "auto": {}
            },
            "default": "auto",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-rotation-alignment": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {},
                "auto": {}
            },
            "default": "auto",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-field": {
            "type": "formatted",
            "default": "",
            "tokens": true,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-font": {
            "type": "array",
            "value": "string",
            "default": [
                "Open Sans Regular",
                "Arial Unicode MS Regular"
            ],
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-size": {
            "type": "number",
            "default": 16,
            "minimum": 0,
            "units": "pixels",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-max-width": {
            "type": "number",
            "default": 10,
            "minimum": 0,
            "units": "ems",
            "requires": [
                "text-field",
                {
                    "symbol-placement": [
                        "point"
                    ]
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-line-height": {
            "type": "number",
            "default": 1.2,
            "units": "ems",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-letter-spacing": {
            "type": "number",
            "default": 0,
            "units": "ems",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-justify": {
            "type": "enum",
            "values": {
                "auto": {},
                "left": {},
                "center": {},
                "right": {}
            },
            "default": "center",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-radial-offset": {
            "type": "number",
            "units": "ems",
            "default": 0,
            "requires": [
                "text-field"
            ],
            "property-type": "data-driven",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            }
        },
        "text-variable-anchor": {
            "type": "array",
            "value": "enum",
            "values": {
                "center": {},
                "left": {},
                "right": {},
                "top": {},
                "bottom": {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
            },
            "requires": [
                "text-field",
                {
                    "symbol-placement": [
                        "point"
                    ]
                }
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-anchor": {
            "type": "enum",
            "values": {
                "center": {},
                "left": {},
                "right": {},
                "top": {},
                "bottom": {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
            },
            "default": "center",
            "requires": [
                "text-field",
                {
                    "!": "text-variable-anchor"
                }
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-max-angle": {
            "type": "number",
            "default": 45,
            "units": "degrees",
            "requires": [
                "text-field",
                {
                    "symbol-placement": [
                        "line",
                        "line-center"
                    ]
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-writing-mode": {
            "type": "array",
            "value": "enum",
            "values": {
                "horizontal": {},
                "vertical": {}
            },
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-rotate": {
            "type": "number",
            "default": 0,
            "period": 360,
            "units": "degrees",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-padding": {
            "type": "number",
            "default": 2,
            "minimum": 0,
            "units": "pixels",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-keep-upright": {
            "type": "boolean",
            "default": true,
            "requires": [
                "text-field",
                {
                    "text-rotation-alignment": "map"
                },
                {
                    "symbol-placement": [
                        "line",
                        "line-center"
                    ]
                }
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-transform": {
            "type": "enum",
            "values": {
                "none": {},
                "uppercase": {},
                "lowercase": {}
            },
            "default": "none",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-offset": {
            "type": "array",
            "value": "number",
            "units": "ems",
            "length": 2,
            "default": [
                0,
                0
            ],
            "requires": [
                "text-field",
                {
                    "!": "text-radial-offset"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "data-driven"
        },
        "text-allow-overlap": {
            "type": "boolean",
            "default": false,
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-ignore-placement": {
            "type": "boolean",
            "default": false,
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-optional": {
            "type": "boolean",
            "default": false,
            "requires": [
                "text-field",
                "icon-image"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_raster": {
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "layout_hillshade": {
        "visibility": {
            "type": "enum",
            "values": {
                "visible": {},
                "none": {}
            },
            "default": "visible",
            "property-type": "constant"
        }
    },
    "filter": {
        "type": "array",
        "value": "*"
    },
    "filter_symbol": {
        "type": "boolean",
        "default": false,
        "transition": false,
        "property-type": "data-driven",
        "expression": {
            "interpolated": false,
            "parameters": [
                "zoom",
                "feature",
                "pitch",
                "distance-from-center"
            ]
        }
    },
    "filter_fill": {
        "type": "boolean",
        "default": false,
        "transition": false,
        "property-type": "data-driven",
        "expression": {
            "interpolated": false,
            "parameters": [
                "zoom",
                "feature"
            ]
        }
    },
    "filter_line": {
        "type": "boolean",
        "default": false,
        "transition": false,
        "property-type": "data-driven",
        "expression": {
            "interpolated": false,
            "parameters": [
                "zoom",
                "feature"
            ]
        }
    },
    "filter_circle": {
        "type": "boolean",
        "default": false,
        "transition": false,
        "property-type": "data-driven",
        "expression": {
            "interpolated": false,
            "parameters": [
                "zoom",
                "feature"
            ]
        }
    },
    "filter_fill-extrusion": {
        "type": "boolean",
        "default": false,
        "transition": false,
        "property-type": "data-driven",
        "expression": {
            "interpolated": false,
            "parameters": [
                "zoom",
                "feature"
            ]
        }
    },
    "filter_heatmap": {
        "type": "boolean",
        "default": false,
        "transition": false,
        "property-type": "data-driven",
        "expression": {
            "interpolated": false,
            "parameters": [
                "zoom",
                "feature"
            ]
        }
    },
    "filter_operator": {
        "type": "enum",
        "values": {
            "==": {},
            "!=": {},
            ">": {},
            ">=": {},
            "<": {},
            "<=": {},
            "in": {},
            "!in": {},
            "all": {},
            "any": {},
            "none": {},
            "has": {},
            "!has": {},
            "within": {}
        }
    },
    "geometry_type": {
        "type": "enum",
        "values": {
            "Point": {},
            "LineString": {},
            "Polygon": {}
        }
    },
    "function": {
        "expression": {
            "type": "expression"
        },
        "stops": {
            "type": "array",
            "value": "function_stop"
        },
        "base": {
            "type": "number",
            "default": 1,
            "minimum": 0
        },
        "property": {
            "type": "string",
            "default": "$zoom"
        },
        "type": {
            "type": "enum",
            "values": {
                "identity": {},
                "exponential": {},
                "interval": {},
                "categorical": {}
            },
            "default": "exponential"
        },
        "colorSpace": {
            "type": "enum",
            "values": {
                "rgb": {},
                "lab": {},
                "hcl": {}
            },
            "default": "rgb"
        },
        "default": {
            "type": "*",
            "required": false
        }
    },
    "function_stop": {
        "type": "array",
        "minimum": 0,
        "maximum": 24,
        "value": [
            "number",
            "color"
        ],
        "length": 2
    },
    "expression": {
        "type": "array",
        "value": "*",
        "minimum": 1
    },
    "expression_name": {
        "type": "enum",
        "values": {
            "let": {
                "group": "Variable binding"
            },
            "var": {
                "group": "Variable binding"
            },
            "literal": {
                "group": "Types"
            },
            "array": {
                "group": "Types"
            },
            "at": {
                "group": "Lookup"
            },
            "in": {
                "group": "Lookup"
            },
            "index-of": {
                "group": "Lookup"
            },
            "slice": {
                "group": "Lookup"
            },
            "case": {
                "group": "Decision"
            },
            "match": {
                "group": "Decision"
            },
            "coalesce": {
                "group": "Decision"
            },
            "step": {
                "group": "Ramps, scales, curves"
            },
            "interpolate": {
                "group": "Ramps, scales, curves"
            },
            "interpolate-hcl": {
                "group": "Ramps, scales, curves"
            },
            "interpolate-lab": {
                "group": "Ramps, scales, curves"
            },
            "ln2": {
                "group": "Math"
            },
            "pi": {
                "group": "Math"
            },
            "e": {
                "group": "Math"
            },
            "typeof": {
                "group": "Types"
            },
            "string": {
                "group": "Types"
            },
            "number": {
                "group": "Types"
            },
            "boolean": {
                "group": "Types"
            },
            "object": {
                "group": "Types"
            },
            "collator": {
                "group": "Types"
            },
            "format": {
                "group": "Types"
            },
            "image": {
                "group": "Types"
            },
            "number-format": {
                "group": "Types"
            },
            "to-string": {
                "group": "Types"
            },
            "to-number": {
                "group": "Types"
            },
            "to-boolean": {
                "group": "Types"
            },
            "to-rgba": {
                "group": "Color"
            },
            "to-color": {
                "group": "Types"
            },
            "rgb": {
                "group": "Color"
            },
            "rgba": {
                "group": "Color"
            },
            "get": {
                "group": "Lookup"
            },
            "has": {
                "group": "Lookup"
            },
            "length": {
                "group": "Lookup"
            },
            "properties": {
                "group": "Feature data"
            },
            "feature-state": {
                "group": "Feature data"
            },
            "geometry-type": {
                "group": "Feature data"
            },
            "id": {
                "group": "Feature data"
            },
            "zoom": {
                "group": "Camera"
            },
            "pitch": {
                "group": "Camera"
            },
            "distance-from-center": {
                "group": "Camera"
            },
            "heatmap-density": {
                "group": "Heatmap"
            },
            "line-progress": {
                "group": "Feature data"
            },
            "sky-radial-progress": {
                "group": "sky"
            },
            "accumulated": {
                "group": "Feature data"
            },
            "+": {
                "group": "Math"
            },
            "*": {
                "group": "Math"
            },
            "-": {
                "group": "Math"
            },
            "/": {
                "group": "Math"
            },
            "%": {
                "group": "Math"
            },
            "^": {
                "group": "Math"
            },
            "sqrt": {
                "group": "Math"
            },
            "log10": {
                "group": "Math"
            },
            "ln": {
                "group": "Math"
            },
            "log2": {
                "group": "Math"
            },
            "sin": {
                "group": "Math"
            },
            "cos": {
                "group": "Math"
            },
            "tan": {
                "group": "Math"
            },
            "asin": {
                "group": "Math"
            },
            "acos": {
                "group": "Math"
            },
            "atan": {
                "group": "Math"
            },
            "min": {
                "group": "Math"
            },
            "max": {
                "group": "Math"
            },
            "round": {
                "group": "Math"
            },
            "abs": {
                "group": "Math"
            },
            "ceil": {
                "group": "Math"
            },
            "floor": {
                "group": "Math"
            },
            "distance": {
                "group": "Math"
            },
            "==": {
                "group": "Decision"
            },
            "!=": {
                "group": "Decision"
            },
            ">": {
                "group": "Decision"
            },
            "<": {
                "group": "Decision"
            },
            ">=": {
                "group": "Decision"
            },
            "<=": {
                "group": "Decision"
            },
            "all": {
                "group": "Decision"
            },
            "any": {
                "group": "Decision"
            },
            "!": {
                "group": "Decision"
            },
            "within": {
                "group": "Decision"
            },
            "is-supported-script": {
                "group": "String"
            },
            "upcase": {
                "group": "String"
            },
            "downcase": {
                "group": "String"
            },
            "concat": {
                "group": "String"
            },
            "resolved-locale": {
                "group": "String"
            }
        }
    },
    "fog": {
        "range": {
            "type": "array",
            "default": [
                0.5,
                10
            ],
            "minimum": -20,
            "maximum": 20,
            "length": 2,
            "value": "number",
            "property-type": "data-constant",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            }
        },
        "color": {
            "type": "color",
            "property-type": "data-constant",
            "default": "#ffffff",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        },
        "high-color": {
            "type": "color",
            "property-type": "data-constant",
            "default": "#245cdf",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        },
        "space-color": {
            "type": "color",
            "property-type": "data-constant",
            "default": [
                "interpolate",
                [
                    "linear"
                ],
                [
                    "zoom"
                ],
                4,
                "#010b19",
                7,
                "#367ab9"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        },
        "horizon-blend": {
            "type": "number",
            "property-type": "data-constant",
            "default": [
                "interpolate",
                [
                    "linear"
                ],
                [
                    "zoom"
                ],
                4,
                0.2,
                7,
                0.1
            ],
            "minimum": 0,
            "maximum": 1,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        },
        "star-intensity": {
            "type": "number",
            "property-type": "data-constant",
            "default": [
                "interpolate",
                [
                    "linear"
                ],
                [
                    "zoom"
                ],
                5,
                0.35,
                6,
                0
            ],
            "minimum": 0,
            "maximum": 1,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        }
    },
    "light": {
        "anchor": {
            "type": "enum",
            "default": "viewport",
            "values": {
                "map": {},
                "viewport": {}
            },
            "property-type": "data-constant",
            "transition": false,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            }
        },
        "position": {
            "type": "array",
            "default": [
                1.15,
                210,
                30
            ],
            "length": 3,
            "value": "number",
            "property-type": "data-constant",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            }
        },
        "color": {
            "type": "color",
            "property-type": "data-constant",
            "default": "#ffffff",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        },
        "intensity": {
            "type": "number",
            "property-type": "data-constant",
            "default": 0.5,
            "minimum": 0,
            "maximum": 1,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        }
    },
    "projection": {
        "name": {
            "type": "enum",
            "values": {
                "albers": {},
                "equalEarth": {},
                "equirectangular": {},
                "lambertConformalConic": {},
                "mercator": {},
                "naturalEarth": {},
                "winkelTripel": {},
                "globe": {}
            },
            "default": "mercator",
            "required": true
        },
        "center": {
            "type": "array",
            "length": 2,
            "value": "number",
            "property-type": "data-constant",
            "minimum": [
                -180,
                -90
            ],
            "maximum": [
                180,
                90
            ],
            "transition": false,
            "requires": [
                {
                    "name": [
                        "albers",
                        "lambertConformalConic"
                    ]
                }
            ]
        },
        "parallels": {
            "type": "array",
            "length": 2,
            "value": "number",
            "property-type": "data-constant",
            "minimum": [
                -90,
                -90
            ],
            "maximum": [
                90,
                90
            ],
            "transition": false,
            "requires": [
                {
                    "name": [
                        "albers",
                        "lambertConformalConic"
                    ]
                }
            ]
        }
    },
    "terrain": {
        "source": {
            "type": "string",
            "required": true
        },
        "exaggeration": {
            "type": "number",
            "property-type": "data-constant",
            "default": 1,
            "minimum": 0,
            "maximum": 1000,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true,
            "requires": [
                "source"
            ]
        }
    },
    "paint": [
        "paint_fill",
        "paint_line",
        "paint_circle",
        "paint_heatmap",
        "paint_fill-extrusion",
        "paint_symbol",
        "paint_raster",
        "paint_hillshade",
        "paint_background",
        "paint_sky"
    ],
    "paint_fill": {
        "fill-antialias": {
            "type": "boolean",
            "default": true,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "fill-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "fill-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "requires": [
                {
                    "!": "fill-pattern"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "fill-outline-color": {
            "type": "color",
            "transition": true,
            "requires": [
                {
                    "!": "fill-pattern"
                },
                {
                    "fill-antialias": true
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "fill-translate": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "fill-translate-anchor": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "map",
            "requires": [
                "fill-translate"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "fill-pattern": {
            "type": "resolvedImage",
            "transition": true,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "cross-faded-data-driven"
        }
    },
    "paint_fill-extrusion": {
        "fill-extrusion-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "requires": [
                {
                    "!": "fill-extrusion-pattern"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-translate": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-translate-anchor": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "map",
            "requires": [
                "fill-extrusion-translate"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-pattern": {
            "type": "resolvedImage",
            "transition": true,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "cross-faded-data-driven"
        },
        "fill-extrusion-height": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "units": "meters",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-base": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "units": "meters",
            "transition": true,
            "requires": [
                "fill-extrusion-height"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "fill-extrusion-vertical-gradient": {
            "type": "boolean",
            "default": true,
            "transition": false,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "fill-extrusion-ambient-occlusion-intensity": {
            "property-type": "data-constant",
            "type": "number",
            "private": true,
            "default": 0,
            "minimum": 0,
            "maximum": 1,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        },
        "fill-extrusion-ambient-occlusion-radius": {
            "property-type": "data-constant",
            "type": "number",
            "private": true,
            "default": 3,
            "minimum": 0,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "transition": true
        }
    },
    "paint_line": {
        "line-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "line-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "requires": [
                {
                    "!": "line-pattern"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "line-translate": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "line-translate-anchor": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "map",
            "requires": [
                "line-translate"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "line-width": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "line-gap-width": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "line-offset": {
            "type": "number",
            "default": 0,
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "line-blur": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "line-dasharray": {
            "type": "array",
            "value": "number",
            "minimum": 0,
            "transition": true,
            "units": "line widths",
            "requires": [
                {
                    "!": "line-pattern"
                }
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "cross-faded-data-driven"
        },
        "line-pattern": {
            "type": "resolvedImage",
            "transition": true,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom",
                    "feature"
                ]
            },
            "property-type": "cross-faded-data-driven"
        },
        "line-gradient": {
            "type": "color",
            "transition": false,
            "requires": [
                {
                    "!": "line-pattern"
                },
                {
                    "source": "geojson",
                    "has": {
                        "lineMetrics": true
                    }
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "line-progress"
                ]
            },
            "property-type": "color-ramp"
        },
        "line-trim-offset": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "minimum": [
                0,
                0
            ],
            "maximum": [
                1,
                1
            ],
            "transition": false,
            "requires": [
                {
                    "source": "geojson",
                    "has": {
                        "lineMetrics": true
                    }
                }
            ],
            "property-type": "constant"
        }
    },
    "paint_circle": {
        "circle-radius": {
            "type": "number",
            "default": 5,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "circle-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "circle-blur": {
            "type": "number",
            "default": 0,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "circle-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "circle-translate": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "circle-translate-anchor": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "map",
            "requires": [
                "circle-translate"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "circle-pitch-scale": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "map",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "circle-pitch-alignment": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "viewport",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "circle-stroke-width": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "circle-stroke-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "circle-stroke-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        }
    },
    "paint_heatmap": {
        "heatmap-radius": {
            "type": "number",
            "default": 30,
            "minimum": 1,
            "transition": true,
            "units": "pixels",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "heatmap-weight": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "transition": false,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "heatmap-intensity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "heatmap-color": {
            "type": "color",
            "default": [
                "interpolate",
                [
                    "linear"
                ],
                [
                    "heatmap-density"
                ],
                0,
                "rgba(0, 0, 255, 0)",
                0.1,
                "royalblue",
                0.3,
                "cyan",
                0.5,
                "lime",
                0.7,
                "yellow",
                1,
                "red"
            ],
            "transition": false,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "heatmap-density"
                ]
            },
            "property-type": "color-ramp"
        },
        "heatmap-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        }
    },
    "paint_symbol": {
        "icon-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-halo-color": {
            "type": "color",
            "default": "rgba(0, 0, 0, 0)",
            "transition": true,
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-halo-width": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-halo-blur": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "icon-translate": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "transition": true,
            "units": "pixels",
            "requires": [
                "icon-image"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "icon-translate-anchor": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "map",
            "requires": [
                "icon-image",
                "icon-translate"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "text-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "overridable": true,
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "text-halo-color": {
            "type": "color",
            "default": "rgba(0, 0, 0, 0)",
            "transition": true,
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "text-halo-width": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "text-halo-blur": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "transition": true,
            "units": "pixels",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom",
                    "feature",
                    "feature-state"
                ]
            },
            "property-type": "data-driven"
        },
        "text-translate": {
            "type": "array",
            "value": "number",
            "length": 2,
            "default": [
                0,
                0
            ],
            "transition": true,
            "units": "pixels",
            "requires": [
                "text-field"
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "text-translate-anchor": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "map",
            "requires": [
                "text-field",
                "text-translate"
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        }
    },
    "paint_raster": {
        "raster-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "raster-hue-rotate": {
            "type": "number",
            "default": 0,
            "period": 360,
            "transition": true,
            "units": "degrees",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "raster-brightness-min": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "raster-brightness-max": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "raster-saturation": {
            "type": "number",
            "default": 0,
            "minimum": -1,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "raster-contrast": {
            "type": "number",
            "default": 0,
            "minimum": -1,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "raster-resampling": {
            "type": "enum",
            "values": {
                "linear": {},
                "nearest": {}
            },
            "default": "linear",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "raster-fade-duration": {
            "type": "number",
            "default": 300,
            "minimum": 0,
            "transition": false,
            "units": "milliseconds",
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        }
    },
    "paint_hillshade": {
        "hillshade-illumination-direction": {
            "type": "number",
            "default": 335,
            "minimum": 0,
            "maximum": 359,
            "transition": false,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "hillshade-illumination-anchor": {
            "type": "enum",
            "values": {
                "map": {},
                "viewport": {}
            },
            "default": "viewport",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "hillshade-exaggeration": {
            "type": "number",
            "default": 0.5,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "hillshade-shadow-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "hillshade-highlight-color": {
            "type": "color",
            "default": "#FFFFFF",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "hillshade-accent-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        }
    },
    "paint_background": {
        "background-color": {
            "type": "color",
            "default": "#000000",
            "transition": true,
            "requires": [
                {
                    "!": "background-pattern"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "background-pattern": {
            "type": "resolvedImage",
            "transition": true,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "cross-faded"
        },
        "background-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        }
    },
    "paint_sky": {
        "sky-type": {
            "type": "enum",
            "values": {
                "gradient": {},
                "atmosphere": {}
            },
            "default": "atmosphere",
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "sky-atmosphere-sun": {
            "type": "array",
            "value": "number",
            "length": 2,
            "units": "degrees",
            "minimum": [
                0,
                0
            ],
            "maximum": [
                360,
                180
            ],
            "transition": false,
            "requires": [
                {
                    "sky-type": "atmosphere"
                }
            ],
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "sky-atmosphere-sun-intensity": {
            "type": "number",
            "requires": [
                {
                    "sky-type": "atmosphere"
                }
            ],
            "default": 10,
            "minimum": 0,
            "maximum": 100,
            "transition": false,
            "property-type": "data-constant"
        },
        "sky-gradient-center": {
            "type": "array",
            "requires": [
                {
                    "sky-type": "gradient"
                }
            ],
            "value": "number",
            "default": [
                0,
                0
            ],
            "length": 2,
            "units": "degrees",
            "minimum": [
                0,
                0
            ],
            "maximum": [
                360,
                180
            ],
            "transition": false,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "sky-gradient-radius": {
            "type": "number",
            "requires": [
                {
                    "sky-type": "gradient"
                }
            ],
            "default": 90,
            "minimum": 0,
            "maximum": 180,
            "transition": false,
            "expression": {
                "interpolated": false,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        },
        "sky-gradient": {
            "type": "color",
            "default": [
                "interpolate",
                [
                    "linear"
                ],
                [
                    "sky-radial-progress"
                ],
                0.8,
                "#87ceeb",
                1,
                "white"
            ],
            "transition": false,
            "requires": [
                {
                    "sky-type": "gradient"
                }
            ],
            "expression": {
                "interpolated": true,
                "parameters": [
                    "sky-radial-progress"
                ]
            },
            "property-type": "color-ramp"
        },
        "sky-atmosphere-halo-color": {
            "type": "color",
            "default": "white",
            "transition": false,
            "requires": [
                {
                    "sky-type": "atmosphere"
                }
            ],
            "property-type": "data-constant"
        },
        "sky-atmosphere-color": {
            "type": "color",
            "default": "white",
            "transition": false,
            "requires": [
                {
                    "sky-type": "atmosphere"
                }
            ],
            "property-type": "data-constant"
        },
        "sky-opacity": {
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1,
            "transition": true,
            "expression": {
                "interpolated": true,
                "parameters": [
                    "zoom"
                ]
            },
            "property-type": "data-constant"
        }
    },
    "transition": {
        "duration": {
            "type": "number",
            "default": 300,
            "minimum": 0,
            "units": "milliseconds"
        },
        "delay": {
            "type": "number",
            "default": 0,
            "minimum": 0,
            "units": "milliseconds"
        }
    },
    "property-type": {
        "data-driven": {
            "type": "property-type"
        },
        "cross-faded": {
            "type": "property-type"
        },
        "cross-faded-data-driven": {
            "type": "property-type"
        },
        "color-ramp": {
            "type": "property-type"
        },
        "data-constant": {
            "type": "property-type"
        },
        "constant": {
            "type": "property-type"
        }
    },
    "promoteId": {
        "*": {
            "type": "string"
        }
    }
};
//      
function isExpressionFilter(filter) {
    if (filter === true || filter === false) return true;
    if (!Array.isArray(filter) || filter.length === 0) return false;
    switch(filter[0]){
        case "has":
            return filter.length >= 2 && filter[1] !== "$id" && filter[1] !== "$type";
        case "in":
            return filter.length >= 3 && (typeof filter[1] !== "string" || Array.isArray(filter[2]));
        case "!in":
        case "!has":
        case "none":
            return false;
        case "==":
        case "!=":
        case ">":
        case ">=":
        case "<":
        case "<=":
            return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);
        case "any":
        case "all":
            for(var i = 0, list = filter.slice(1); i < list.length; i += 1){
                var f = list[i];
                if (!isExpressionFilter(f) && typeof f !== "boolean") return false;
            }
            return true;
        default:
            return true;
    }
}
/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @private
 * @param {Array} filter mapbox gl filter
 * @param {string} layerType the type of the layer this filter will be applied to.
 * @returns {Function} filter-evaluating function
 */ function createFilter(filter, layerType) {
    if (layerType === void 0) layerType = "fill";
    if (filter === null || filter === undefined) return {
        filter: function() {
            return true;
        },
        needGeometry: false,
        needFeature: false
    };
    if (!isExpressionFilter(filter)) filter = convertFilter(filter);
    var filterExp = filter;
    var staticFilter = true;
    try {
        staticFilter = extractStaticFilter(filterExp);
    } catch (e) {
        console.warn("Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n" + JSON.stringify(filterExp, null, 2) + "\n        ");
    }
    // Compile the static component of the filter
    var filterSpec = spec["filter_" + layerType];
    var compiledStaticFilter = createExpression(staticFilter, filterSpec);
    var filterFunc = null;
    if (compiledStaticFilter.result === "error") throw new Error(compiledStaticFilter.value.map(function(err) {
        return err.key + ": " + err.message;
    }).join(", "));
    else filterFunc = function(globalProperties, feature, canonical) {
        return compiledStaticFilter.value.evaluate(globalProperties, feature, {}, canonical);
    };
    // If the static component is not equal to the entire filter then we have a dynamic component
    // Compile the dynamic component separately
    var dynamicFilterFunc = null;
    var needFeature = null;
    if (staticFilter !== filterExp) {
        var compiledDynamicFilter = createExpression(filterExp, filterSpec);
        if (compiledDynamicFilter.result === "error") throw new Error(compiledDynamicFilter.value.map(function(err) {
            return err.key + ": " + err.message;
        }).join(", "));
        else {
            dynamicFilterFunc = function(globalProperties, feature, canonical, featureTileCoord, featureDistanceData) {
                return compiledDynamicFilter.value.evaluate(globalProperties, feature, {}, canonical, undefined, undefined, featureTileCoord, featureDistanceData);
            };
            needFeature = !isFeatureConstant(compiledDynamicFilter.value.expression);
        }
    }
    filterFunc;
    var needGeometry = geometryNeeded(staticFilter);
    return {
        filter: filterFunc,
        dynamicFilter: dynamicFilterFunc ? dynamicFilterFunc : undefined,
        needGeometry: needGeometry,
        needFeature: !!needFeature
    };
}
function extractStaticFilter(filter) {
    if (!isDynamicFilter(filter)) return filter;
    // Shallow copy so we can replace expressions in-place
    var result = deepUnbundle(filter);
    // 1. Union branches
    unionDynamicBranches(result);
    // 2. Collapse dynamic conditions to  `true`
    result = collapseDynamicBooleanExpressions(result);
    return result;
}
function collapseDynamicBooleanExpressions(expression) {
    if (!Array.isArray(expression)) return expression;
    var collapsed = collapsedExpression(expression);
    if (collapsed === true) return collapsed;
    else return collapsed.map(function(subExpression) {
        return collapseDynamicBooleanExpressions(subExpression);
    });
}
/**
 * Traverses the expression and replaces all instances of branching on a
 * `dynamic` conditional (such as `['pitch']` or `['distance-from-center']`)
 * into an `any` expression.
 * This ensures that all possible outcomes of a `dynamic` branch are considered
 * when evaluating the expression upfront during filtering.
 *
 * @param {Array<any>} filter the filter expression mutated in-place.
 */ function unionDynamicBranches(filter) {
    var isBranchingDynamically = false;
    var branches = [];
    if (filter[0] === "case") {
        for(var i = 1; i < filter.length - 1; i += 2){
            isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[i]);
            branches.push(filter[i + 1]);
        }
        branches.push(filter[filter.length - 1]);
    } else if (filter[0] === "match") {
        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);
        for(var i$1 = 2; i$1 < filter.length - 1; i$1 += 2)branches.push(filter[i$1 + 1]);
        branches.push(filter[filter.length - 1]);
    } else if (filter[0] === "step") {
        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);
        for(var i$2 = 1; i$2 < filter.length - 1; i$2 += 2)branches.push(filter[i$2 + 1]);
    }
    if (isBranchingDynamically) {
        filter.length = 0;
        filter.push.apply(filter, [
            "any"
        ].concat(branches));
    }
    // traverse and recurse into children
    for(var i$3 = 1; i$3 < filter.length; i$3++)unionDynamicBranches(filter[i$3]);
}
function isDynamicFilter(filter) {
    // Base Cases
    if (!Array.isArray(filter)) return false;
    if (isRootExpressionDynamic(filter[0])) return true;
    for(var i = 1; i < filter.length; i++){
        var child = filter[i];
        if (isDynamicFilter(child)) return true;
    }
    return false;
}
function isRootExpressionDynamic(expression) {
    return expression === "pitch" || expression === "distance-from-center";
}
var dynamicConditionExpressions = new Set([
    "in",
    "==",
    "!=",
    ">",
    ">=",
    "<",
    "<=",
    "to-boolean"
]);
function collapsedExpression(expression) {
    if (dynamicConditionExpressions.has(expression[0])) for(var i = 1; i < expression.length; i++){
        var param = expression[i];
        if (isDynamicFilter(param)) return true;
    }
    return expression;
}
// Comparison function to sort numbers and strings
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function geometryNeeded(filter) {
    if (!Array.isArray(filter)) return false;
    if (filter[0] === "within") return true;
    for(var index = 1; index < filter.length; index++){
        if (geometryNeeded(filter[index])) return true;
    }
    return false;
}
function convertFilter(filter) {
    if (!filter) return true;
    var op = filter[0];
    if (filter.length <= 1) return op !== "any";
    var converted = op === "==" ? convertComparisonOp(filter[1], filter[2], "==") : op === "!=" ? convertNegation(convertComparisonOp(filter[1], filter[2], "==")) : op === "<" || op === ">" || op === "<=" || op === ">=" ? convertComparisonOp(filter[1], filter[2], op) : op === "any" ? convertDisjunctionOp(filter.slice(1)) : op === "all" ? [
        "all"
    ].concat(filter.slice(1).map(convertFilter)) : op === "none" ? [
        "all"
    ].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === "in" ? convertInOp(filter[1], filter.slice(2)) : op === "!in" ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === "has" ? convertHasOp(filter[1]) : op === "!has" ? convertNegation(convertHasOp(filter[1])) : op === "within" ? filter : true;
    return converted;
}
function convertComparisonOp(property, value, op) {
    switch(property){
        case "$type":
            return [
                "filter-type-" + op,
                value
            ];
        case "$id":
            return [
                "filter-id-" + op,
                value
            ];
        default:
            return [
                "filter-" + op,
                property,
                value
            ];
    }
}
function convertDisjunctionOp(filters) {
    return [
        "any"
    ].concat(filters.map(convertFilter));
}
function convertInOp(property, values) {
    if (values.length === 0) return false;
    switch(property){
        case "$type":
            return [
                "filter-type-in",
                [
                    "literal",
                    values
                ]
            ];
        case "$id":
            return [
                "filter-id-in",
                [
                    "literal",
                    values
                ]
            ];
        default:
            if (values.length > 200 && !values.some(function(v) {
                return typeof v !== typeof values[0];
            })) return [
                "filter-in-large",
                property,
                [
                    "literal",
                    values.sort(compare)
                ]
            ];
            else return [
                "filter-in-small",
                property,
                [
                    "literal",
                    values
                ]
            ];
    }
}
function convertHasOp(property) {
    switch(property){
        case "$type":
            return true;
        case "$id":
            return [
                "filter-has-id"
            ];
        default:
            return [
                "filter-has",
                property
            ];
    }
}
function convertNegation(filter) {
    return [
        "!",
        filter
    ];
}
//      
var refProperties = [
    "type",
    "source",
    "source-layer",
    "minzoom",
    "maxzoom",
    "filter",
    "layout"
];
//      
function deref(layer, parent) {
    var result = {};
    for(var k in layer)if (k !== "ref") result[k] = layer[k];
    refProperties.forEach(function(k) {
        if (k in parent) result[k] = parent[k];
    });
    return result;
}
/**
 * Given an array of layers, some of which may contain `ref` properties
 * whose value is the `id` of another property, return a new array where
 * such layers have been augmented with the 'type', 'source', etc. properties
 * from the parent layer, and the `ref` property has been removed.
 *
 * The input is not modified. The output may contain references to portions
 * of the input.
 *
 * @private
 * @param {Array<Layer>} layers
 * @returns {Array<Layer>}
 */ function derefLayers(layers) {
    layers = layers.slice();
    var map = Object.create(null);
    for(var i = 0; i < layers.length; i++)map[layers[i].id] = layers[i];
    for(var i$1 = 0; i$1 < layers.length; i$1++)if ("ref" in layers[i$1]) layers[i$1] = deref(layers[i$1], map[layers[i$1].ref]);
    return layers;
}
var fontWeights = {
    thin: 100,
    hairline: 100,
    "ultra-light": 100,
    "extra-light": 100,
    light: 200,
    book: 300,
    regular: 400,
    normal: 400,
    plain: 400,
    roman: 400,
    standard: 400,
    medium: 500,
    "semi-bold": 600,
    "demi-bold": 600,
    bold: 700,
    heavy: 800,
    black: 800,
    "extra-bold": 800,
    "ultra-black": 900,
    "extra-black": 900,
    "ultra-bold": 900,
    "heavy-black": 900,
    fat: 900,
    poster: 900
};
var sp = " ";
var italicRE = /(italic|oblique)$/i;
var fontCache = {};
var mapboxToCssFont = function(fonts, size, lineHeight) {
    var cssData = fontCache[fonts];
    if (!cssData) {
        if (!Array.isArray(fonts)) fonts = [
            fonts
        ];
        var weight = 400;
        var style = "normal";
        var fontFamilies = [];
        var haveWeight, haveStyle;
        for(var i = 0, ii = fonts.length; i < ii; ++i){
            var font = fonts[i];
            var parts = font.split(" ");
            var maybeWeight = parts[parts.length - 1].toLowerCase();
            if (maybeWeight == "normal" || maybeWeight == "italic" || maybeWeight == "oblique") {
                style = haveStyle ? style : maybeWeight;
                parts.pop();
                maybeWeight = parts[parts.length - 1].toLowerCase();
            } else if (italicRE.test(maybeWeight)) {
                maybeWeight = maybeWeight.replace(italicRE, "");
                style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, "");
            }
            for(var w in fontWeights){
                var previousPart = parts.length > 1 ? parts[parts.length - 2].toLowerCase() : "";
                if (maybeWeight == w || maybeWeight == w.replace("-", "") || previousPart + "-" + maybeWeight == w) {
                    weight = haveWeight ? weight : fontWeights[w];
                    parts.pop();
                    if (previousPart && w.startsWith(previousPart)) parts.pop();
                    break;
                }
            }
            if (!haveWeight && typeof maybeWeight == "number") weight = maybeWeight;
            var fontFamily = parts.join(sp).replace("Klokantech Noto Sans", "Noto Sans");
            if (fontFamily.indexOf(sp) !== -1) fontFamily = '"' + fontFamily + '"';
            fontFamilies.push(fontFamily);
        }
        // CSS font property: font-style font-weight font-size/line-height font-family
        cssData = fontCache[fonts] = [
            style,
            weight,
            fontFamilies
        ];
    }
    return cssData[0] + sp + cssData[1] + sp + size + "px" + (lineHeight ? "/" + lineHeight : "") + sp + cssData[2];
};
var mapboxBaseUrl = "https://api.mapbox.com";
/**
 * Gets the path from a mapbox:// URL.
 * @param {string} url The Mapbox URL.
 * @return {string} The path.
 * @private
 */ function getMapboxPath(url) {
    var startsWith = "mapbox://";
    if (url.indexOf(startsWith) !== 0) return "";
    return url.slice(startsWith.length);
}
/**
 * Turns mapbox:// sprite URLs into resolvable URLs.
 * @param {string} url The sprite URL.
 * @param {string} token The access token.
 * @param {string} styleUrl The style URL.
 * @return {string} A resolvable URL.
 * @private
 */ function normalizeSpriteUrl(url, token, styleUrl) {
    var mapboxPath = getMapboxPath(url);
    if (!mapboxPath) return decodeURI(new URL(url, styleUrl).href);
    var startsWith = "sprites/";
    if (mapboxPath.indexOf(startsWith) !== 0) throw new Error("unexpected sprites url: " + url);
    var sprite = mapboxPath.slice(startsWith.length);
    return mapboxBaseUrl + "/styles/v1/" + sprite + "/sprite?access_token=" + token;
}
/**
 * Turns mapbox:// style URLs into resolvable URLs.
 * @param {string} url The style URL.
 * @param {string} token The access token.
 * @return {string} A resolvable URL.
 * @private
 */ function normalizeStyleUrl(url, token) {
    var mapboxPath = getMapboxPath(url);
    if (!mapboxPath) return decodeURI(new URL(url, location.href).href);
    var startsWith = "styles/";
    if (mapboxPath.indexOf(startsWith) !== 0) throw new Error("unexpected style url: " + url);
    var style = mapboxPath.slice(startsWith.length);
    return mapboxBaseUrl + "/styles/v1/" + style + "?&access_token=" + token;
}
/**
 * Turns mapbox:// source URLs into vector tile URL templates.
 * @param {string} url The source URL.
 * @param {string} token The access token.
 * @param {string} tokenParam The access token key.
 * @param {string} styleUrl The style URL.
 * @return {string} A vector tile template.
 * @private
 */ function normalizeSourceUrl(url, token, tokenParam, styleUrl) {
    var urlObject = new URL(url, styleUrl);
    var mapboxPath = getMapboxPath(url);
    if (!mapboxPath) {
        if (!token) return decodeURI(urlObject.href);
        urlObject.searchParams.set(tokenParam, token);
        return decodeURI(urlObject.href);
    }
    if (mapboxPath === "mapbox.satellite") {
        var sizeFactor = window.devicePixelRatio >= 1.5 ? "@2x" : "";
        return "https://api.mapbox.com/v4/" + mapboxPath + "/{z}/{x}/{y}" + sizeFactor + ".webp?access_token=" + token;
    }
    return "https://{a-d}.tiles.mapbox.com/v4/" + mapboxPath + "/{z}/{x}/{y}.vector.pbf?access_token=" + token;
}
function deg2rad(degrees) {
    return degrees * Math.PI / 180;
}
var defaultResolutions = function() {
    var resolutions = [];
    for(var res = 78271.51696402048; resolutions.length <= 24; res /= 2)resolutions.push(res);
    return resolutions;
}();
/**
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @return {HTMLCanvasElement} Canvas.
 */ function createCanvas(width, height) {
    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof OffscreenCanvas !== "undefined") // eslint-disable-line
    return new OffscreenCanvas(width, height);
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
function getZoomForResolution(resolution, resolutions) {
    var i = 0;
    var ii = resolutions.length;
    for(; i < ii; ++i){
        var candidate = resolutions[i];
        if (candidate < resolution && i + 1 < ii) {
            var zoomFactor = resolutions[i] / resolutions[i + 1];
            return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
        }
    }
    return ii - 1;
}
var pendingRequests = {};
/**
 * @param {ResourceType} resourceType Type of resource to load.
 * @param {string} url Url of the resource.
 * @param {Options} [options={}] Options.
 * @param {{request?: Request}} [metadata] Object to be filled with the request.
 * @return {Promise<Object|Response>} Promise that resolves with the loaded resource
 * or rejects with the Response object.
 * @private
 */ function fetchResource(resourceType, url, options, metadata) {
    if (options === void 0) options = {};
    if (url in pendingRequests) return pendingRequests[url];
    var request = options.transformRequest ? options.transformRequest(url, resourceType) || new Request(url) : new Request(url);
    if (!request.headers.get("Accept")) request.headers.set("Accept", "application/json");
    if (metadata) metadata.request = request;
    var pendingRequest = fetch(request).then(function(response) {
        delete pendingRequests[url];
        return response.ok ? response.json() : Promise.reject(new Error("Error fetching source " + url));
    }).catch(function(error) {
        delete pendingRequests[url];
        return Promise.reject(new Error("Error fetching source " + url));
    });
    pendingRequests[url] = pendingRequest;
    return pendingRequest;
}
function getGlStyle(glStyleOrUrl, options) {
    if (typeof glStyleOrUrl === "string") {
        if (glStyleOrUrl.trim().startsWith("{")) try {
            var glStyle = JSON.parse(glStyleOrUrl);
            return Promise.resolve(glStyle);
        } catch (error) {
            return Promise.reject(error);
        }
        else {
            glStyleOrUrl = normalizeStyleUrl(glStyleOrUrl, options.accessToken);
            return fetchResource("Style", glStyleOrUrl, options);
        }
    } else return Promise.resolve(glStyleOrUrl);
}
function getTransformedTilesUrl(tilesUrl, options) {
    if (options.transformRequest) {
        var transformedRequest = options.transformRequest(tilesUrl, "Tiles");
        if (transformedRequest instanceof Request) return decodeURI(transformedRequest.url);
    }
    return tilesUrl;
}
var tilejsonCache = {};
/**
 * @param {Object} glSource glStyle source object.
 * @param {string} styleUrl Style URL.
 * @param {Options} options Options.
 * @return {Object} TileJson
 */ function getTileJson(glSource, styleUrl, options) {
    if (options === void 0) options = {};
    var cacheKey = [
        styleUrl,
        JSON.stringify(glSource)
    ].toString();
    var promise = tilejsonCache[cacheKey];
    if (!promise || options.transformRequest) {
        var url = glSource.url;
        if (url && !glSource.tiles) {
            var normalizedSourceUrl = normalizeSourceUrl(url, options.accessToken, options.accessTokenParam || "access_token", styleUrl || location.href);
            if (url.startsWith("mapbox://")) promise = Promise.resolve(Object.assign({}, glSource, {
                url: undefined,
                tiles: (0, _tileurlfunctionJs.expandUrl)(normalizedSourceUrl)
            }));
            else {
                var metadata = {};
                promise = fetchResource("Source", normalizedSourceUrl, options, metadata).then(function(tileJson) {
                    tileJson.tiles = tileJson.tiles.map(function(tileUrl) {
                        return getTransformedTilesUrl(normalizeSourceUrl(tileUrl, options.accessToken, options.accessTokenParam || "access_token", metadata.request.url), options);
                    });
                    return Promise.resolve(tileJson);
                });
            }
        } else {
            glSource = Object.assign({}, glSource, {
                tiles: glSource.tiles.map(function(tileUrl) {
                    return getTransformedTilesUrl(normalizeSourceUrl(tileUrl, options.accessToken, options.accessTokenParam || "access_token", styleUrl || location.href), options);
                })
            });
            promise = Promise.resolve(Object.assign({}, glSource));
        }
        tilejsonCache[cacheKey] = promise;
    }
    return promise;
} /**
 * @typedef {import("./apply.js").Options} Options
 * @typedef {import('./apply.js').ResourceType} ResourceType
 * @private
 */ 
var hairSpacePool = Array(256).join(" ");
function applyLetterSpacing(text, letterSpacing) {
    if (letterSpacing >= 0.05) {
        var textWithLetterSpacing = "";
        var lines = text.split("\n");
        var joinSpaceString = hairSpacePool.slice(0, Math.round(letterSpacing / 0.1));
        for(var l = 0, ll = lines.length; l < ll; ++l){
            if (l > 0) textWithLetterSpacing += "\n";
            textWithLetterSpacing += lines[l].split("").join(joinSpaceString);
        }
        return textWithLetterSpacing;
    }
    return text;
}
var measureContext;
function getMeasureContext() {
    if (!measureContext) measureContext = createCanvas(1, 1).getContext("2d");
    return measureContext;
}
function measureText(text, letterSpacing) {
    return getMeasureContext().measureText(text).width + (text.length - 1) * letterSpacing;
}
var measureCache = {};
function wrapText(text, font, em, letterSpacing) {
    if (text.indexOf("\n") !== -1) {
        var hardLines = text.split("\n");
        var lines = [];
        for(var i = 0, ii = hardLines.length; i < ii; ++i)lines.push(wrapText(hardLines[i], font, em, letterSpacing));
        return lines.join("\n");
    }
    var key = em + "," + font + "," + text + "," + letterSpacing;
    var wrappedText = measureCache[key];
    if (!wrappedText) {
        var words = text.split(" ");
        if (words.length > 1) {
            var ctx = getMeasureContext();
            ctx.font = font;
            var oneEm = ctx.measureText("M").width;
            var maxWidth = oneEm * em;
            var line = "";
            var lines$1 = [];
            // Pass 1 - wrap lines to not exceed maxWidth
            for(var i$1 = 0, ii$1 = words.length; i$1 < ii$1; ++i$1){
                var word = words[i$1];
                var testLine = line + (line ? " " : "") + word;
                if (measureText(testLine, letterSpacing) <= maxWidth) line = testLine;
                else {
                    if (line) lines$1.push(line);
                    line = word;
                }
            }
            if (line) lines$1.push(line);
            // Pass 2 - add lines with a width of less than 30% of maxWidth to the previous or next line
            for(var i$2 = 0, ii$2 = lines$1.length; i$2 < ii$2 && ii$2 > 1; ++i$2){
                var line$1 = lines$1[i$2];
                if (measureText(line$1, letterSpacing) < maxWidth * 0.35) {
                    var prevWidth = i$2 > 0 ? measureText(lines$1[i$2 - 1], letterSpacing) : Infinity;
                    var nextWidth = i$2 < ii$2 - 1 ? measureText(lines$1[i$2 + 1], letterSpacing) : Infinity;
                    lines$1.splice(i$2, 1);
                    ii$2 -= 1;
                    if (prevWidth < nextWidth) {
                        lines$1[i$2 - 1] += " " + line$1;
                        i$2 -= 1;
                    } else lines$1[i$2] = line$1 + " " + lines$1[i$2];
                }
            }
            // Pass 3 - try to fill 80% of maxWidth for each line
            for(var i$3 = 0, ii$3 = lines$1.length - 1; i$3 < ii$3; ++i$3){
                var line$2 = lines$1[i$3];
                var next = lines$1[i$3 + 1];
                if (measureText(line$2, letterSpacing) > maxWidth * 0.7 && measureText(next, letterSpacing) < maxWidth * 0.6) {
                    var lineWords = line$2.split(" ");
                    var lastWord = lineWords.pop();
                    if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {
                        lines$1[i$3] = lineWords.join(" ");
                        lines$1[i$3 + 1] = lastWord + " " + next;
                    }
                    ii$3 -= 1;
                }
            }
            wrappedText = lines$1.join("\n");
        } else wrappedText = text;
        wrappedText = applyLetterSpacing(wrappedText, letterSpacing);
        measureCache[key] = wrappedText;
    }
    return wrappedText;
}
var fontFamilyRegEx = /font-family: ?([^;]*);/;
var stripQuotesRegEx = /("|')/g;
var loadedFontFamilies;
function hasFontFamily(family) {
    if (!loadedFontFamilies) {
        loadedFontFamilies = {};
        var styleSheets = document.styleSheets;
        for(var i = 0, ii = styleSheets.length; i < ii; ++i){
            var styleSheet = styleSheets[i];
            try {
                var cssRules = styleSheet.rules || styleSheet.cssRules;
                if (cssRules) for(var j = 0, jj = cssRules.length; j < jj; ++j){
                    var cssRule = cssRules[j];
                    if (cssRule.type == 5) {
                        var match = cssRule.cssText.match(fontFamilyRegEx);
                        loadedFontFamilies[match[1].replace(stripQuotesRegEx, "")] = true;
                    }
                }
            } catch (e) {}
        }
    }
    return family in loadedFontFamilies;
}
var processedFontFamilies = {};
/**
 * @param {Array} fonts Fonts.
 * @return {Array} Processed fonts.
 * @private
 */ function getFonts(fonts) {
    var fontsKey = fonts.toString();
    if (fontsKey in processedFontFamilies) return processedFontFamilies[fontsKey];
    var googleFontDescriptions = [];
    for(var i = 0, ii = fonts.length; i < ii; ++i){
        fonts[i] = fonts[i].replace("Arial Unicode MS", "Arial");
        var font = fonts[i];
        var cssFont = mapboxToCssFont(font, 1);
        (0, _canvasJs.registerFont)(cssFont);
        var parts = cssFont.split(" ");
        googleFontDescriptions.push([
            parts.slice(3).join(" ").replace(/"/g, ""),
            parts[1],
            parts[0]
        ]);
    }
    for(var i$1 = 0, ii$1 = googleFontDescriptions.length; i$1 < ii$1; ++i$1){
        var googleFontDescription = googleFontDescriptions[i$1];
        var family = googleFontDescription[0];
        if (!hasFontFamily(family)) {
            if ((0, _canvasJs.checkedFonts).get(googleFontDescription[2] + "\n" + googleFontDescription[1] + " \n" + family) !== 100) {
                var fontUrl = "https://fonts.googleapis.com/css?family=" + family.replace(/ /g, "+") + ":" + googleFontDescription[1] + googleFontDescription[2];
                if (!document.querySelector('link[href="' + fontUrl + '"]')) {
                    var markup = document.createElement("link");
                    markup.href = fontUrl;
                    markup.rel = "stylesheet";
                    document.head.appendChild(markup);
                }
            }
        }
    }
    processedFontFamilies[fontsKey] = fonts;
    return fonts;
}
/*
ol-mapbox-style - Use Mapbox Style objects with OpenLayers
Copyright 2016-present ol-mapbox-style contributors
License: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE
*/ /**
 * @typedef {import("ol/layer/Vector").default} VectorLayer
 * @typedef {import("ol/layer/VectorTile").default} VectorTileLayer
 * @typedef {import("ol/style/Style").StyleFunction} StyleFunction
 */ var types = {
    "Point": 1,
    "MultiPoint": 1,
    "LineString": 2,
    "MultiLineString": 2,
    "Polygon": 3,
    "MultiPolygon": 3
};
var anchor = {
    "center": [
        0.5,
        0.5
    ],
    "left": [
        0,
        0.5
    ],
    "right": [
        1,
        0.5
    ],
    "top": [
        0.5,
        0
    ],
    "bottom": [
        0.5,
        1
    ],
    "top-left": [
        0,
        0
    ],
    "top-right": [
        1,
        0
    ],
    "bottom-left": [
        0,
        1
    ],
    "bottom-right": [
        1,
        1
    ]
};
var expressionData = function(rawExpression, propertySpec) {
    var compiledExpression = createPropertyExpression(rawExpression, propertySpec);
    if (compiledExpression.result === "error") throw new Error(compiledExpression.value.map(function(err) {
        return err.key + ": " + err.message;
    }).join(", "));
    return compiledExpression.value;
};
var emptyObj$1 = {};
var zoomObj = {
    zoom: 0
};
var renderFeatureCoordinates, renderFeature;
/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {string} layoutOrPaint 'layout' or 'paint'.
 * @param {string} property Feature property.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @param {Object} [functionCache] Function cache.
 * @param {Object} [featureState] Feature state.
 * @return {?} Value.
 */ function getValue(layer, layoutOrPaint, property, zoom, feature, functionCache, featureState) {
    var layerId = layer.id;
    if (!functionCache) {
        functionCache = {};
        console.warn("No functionCache provided to getValue()"); //eslint-disable-line no-console
    }
    if (!functionCache[layerId]) functionCache[layerId] = {};
    var functions = functionCache[layerId];
    if (!functions[property]) {
        var value = (layer[layoutOrPaint] || emptyObj$1)[property];
        var propertySpec = spec[layoutOrPaint + "_" + layer.type][property];
        if (value === undefined) value = propertySpec.default;
        var isExpr = isExpression(value);
        if (!isExpr && isFunction(value)) {
            value = convertFunction(value, propertySpec);
            isExpr = true;
        }
        if (isExpr) {
            var compiledExpression = expressionData(value, propertySpec);
            functions[property] = compiledExpression.evaluate.bind(compiledExpression);
        } else {
            if (propertySpec.type == "color") value = Color$1.parse(value);
            functions[property] = function() {
                return value;
            };
        }
    }
    zoomObj.zoom = zoom;
    return functions[property](zoomObj, feature, featureState);
}
/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @param {Object} [functionCache] Function cache.
 * @return {"declutter"|"obstacle"|"none"} Value.
 */ function getIconDeclutterMode(layer, zoom, feature, functionCache) {
    var allowOverlap = getValue(layer, "layout", "icon-allow-overlap", zoom, feature, functionCache);
    if (!allowOverlap) return "declutter";
    var ignorePlacement = getValue(layer, "layout", "icon-ignore-placement", zoom, feature, functionCache);
    if (!ignorePlacement) return "obstacle";
    return "none";
}
/**
 * @private
 * @param {string} layerId Layer id.
 * @param {?} filter Filter.
 * @param {Object} feature Feature.
 * @param {number} zoom Zoom.
 * @param {Object} [filterCache] Filter cache.
 * @return {boolean} Filter result.
 */ function evaluateFilter(layerId, filter, feature, zoom, filterCache) {
    if (!filterCache) console.warn("No filterCache provided to evaluateFilter()"); //eslint-disable-line no-console
    if (!(layerId in filterCache)) filterCache[layerId] = createFilter(filter).filter;
    zoomObj.zoom = zoom;
    return filterCache[layerId](zoomObj, feature);
}
var renderTransparentEnabled = false;
/**
 * Configure whether features with a transparent style should be rendered. When
 * set to `true`, it will be possible to hit detect content that is not visible,
 * like transparent fills of polygons, using `ol/layer/Layer#getFeatures()` or
 * `ol/Map#getFeaturesAtPixel()`
 * @param {boolean} enabled Rendering of transparent elements is enabled.
 * Default is `false`.
 */ function renderTransparent(enabled) {
    renderTransparentEnabled = enabled;
}
/**
 * @private
 * @param {?} color Color.
 * @param {number} [opacity] Opacity.
 * @return {string} Color.
 */ function colorWithOpacity(color, opacity) {
    if (color) {
        if (!renderTransparentEnabled && (color.a === 0 || opacity === 0)) return undefined;
        var a = color.a;
        opacity = opacity === undefined ? 1 : opacity;
        return a === 0 ? "transparent" : "rgba(" + Math.round(color.r * 255 / a) + "," + Math.round(color.g * 255 / a) + "," + Math.round(color.b * 255 / a) + "," + a * opacity + ")";
    }
    return color;
}
var templateRegEx = /\{[^{}}]*\}/g;
/**
 * @private
 * @param {string} text Text.
 * @param {Object} properties Properties.
 * @return {string} Text.
 */ function fromTemplate(text, properties) {
    return text.replace(templateRegEx, function(match) {
        return properties[match.slice(1, -1)] || "";
    });
}
var recordLayer = false;
/**
 * Turns recording of the Mapbox Style's `layer` on and off. When turned on,
 * the layer that a rendered feature belongs to will be set as the feature's
 * `mapbox-layer` property.
 * @param {boolean} record Recording of the style layer is on.
 */ function recordStyleLayer(record) {
    if (record === void 0) record = false;
    recordLayer = record;
}
/**
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source and applies it to the specified OpenLayers layer.
 *
 * Two additional properties will be set on the provided layer:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * This function also works in a web worker. In worker mode, the main thread needs
 * to listen to messages from the worker and respond with another message to make
 * sure that sprite image loading works:
 *
 * ```js
 *  worker.addEventListener('message', event => {
 *   if (event.data.action === 'loadImage') {
 *     const image = new Image();
 *     image.crossOrigin = 'anonymous';
 *     image.addEventListener('load', function() {
 *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {
 *         worker.postMessage({
 *           action: 'imageLoaded',
 *           image: imageBitmap,
 *           src: event.data.src
 *         }, [imageBitmap]);
 *       });
 *     });
 *     image.src = event.data.src;
 *   }
 * });
 * ```
 *
 * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to
 * apply the style to. In addition to the style, the layer will get two
 * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used
 * for the layer, and `mapbox-layers` will be an array of the `id`s of the
 * `glStyle`'s layers.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} sourceOrLayers `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} resolutions
 * Resolutions for mapping resolution to zoom level.
 * @param {Object} spriteData Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {string} spriteImageUrl Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {function(Array<string>):Array<string>} getFonts Function that
 * receives a font stack as arguments, and returns a (modified) font stack that
 * is available. Font names are the names used in the Mapbox Style object. If
 * not provided, the font stack will be used as-is. This function can also be
 * used for loading web fonts.
 * @param {function(VectorLayer|VectorTileLayer, string):HTMLImageElement|HTMLCanvasElement|string|undefined} [getImage=undefined]
 * Function that returns an image or a URL for an image name. If the result is an HTMLImageElement, it must already be
 * loaded. The layer can be used to call layer.changed() when the loading and processing of the image has finished.
 * This function can be used for icons not in the sprite or to override sprite icons.
 * @return {StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */ function stylefunction(olLayer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, getImage) {
    if (resolutions === void 0) resolutions = defaultResolutions;
    if (spriteData === void 0) spriteData = undefined;
    if (spriteImageUrl === void 0) spriteImageUrl = undefined;
    if (getFonts === void 0) getFonts = undefined;
    if (getImage === void 0) getImage = undefined;
    if (typeof glStyle == "string") glStyle = JSON.parse(glStyle);
    if (glStyle.version != 8) throw new Error("glStyle version 8 required.");
    var spriteImage, spriteImageSize;
    if (spriteImageUrl) {
        if (typeof Image !== "undefined") {
            var img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = function() {
                spriteImage = img;
                spriteImageSize = [
                    img.width,
                    img.height
                ];
                olLayer.changed();
                img.onload = null;
            };
            img.src = spriteImageUrl;
        } else if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
            //eslint-disable-line
            var worker = self;
            // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'
            worker.postMessage({
                action: "loadImage",
                src: spriteImageUrl
            });
            worker.addEventListener("message", function handler(event) {
                if (event.data.action === "imageLoaded" && event.data.src === spriteImageUrl) {
                    spriteImage = event.data.image;
                    spriteImageSize = [
                        spriteImage.width,
                        spriteImage.height
                    ];
                }
            });
        }
    }
    var allLayers = derefLayers(glStyle.layers);
    var layersBySourceLayer = {};
    var mapboxLayers = [];
    var iconImageCache = {};
    var patternCache = {};
    var functionCache = {};
    var filterCache = {};
    var mapboxSource;
    for(var i = 0, ii = allLayers.length; i < ii; ++i){
        var layer = allLayers[i];
        var layerId = layer.id;
        if (typeof sourceOrLayers == "string" && layer.source == sourceOrLayers || sourceOrLayers.indexOf(layerId) !== -1) {
            var sourceLayer = layer["source-layer"];
            if (!mapboxSource) {
                mapboxSource = layer.source;
                var source = glStyle.sources[mapboxSource];
                if (!source) throw new Error('Source "' + mapboxSource + '" is not defined');
                var type = source.type;
                if (type !== "vector" && type !== "geojson") throw new Error('Source "' + mapboxSource + '" is not of type "vector" or "geojson", but "' + type + '"');
            } else if (layer.source !== mapboxSource) throw new Error('Layer "' + layerId + '" does not use source "' + mapboxSource);
            var layers = layersBySourceLayer[sourceLayer];
            if (!layers) {
                layers = [];
                layersBySourceLayer[sourceLayer] = layers;
            }
            layers.push({
                layer: layer,
                index: i
            });
            mapboxLayers.push(layerId);
        }
    }
    var textHalo = new (0, _strokeJsDefault.default)();
    var textColor = new (0, _fillJsDefault.default)();
    var styles = [];
    var styleFunction = function(feature, resolution) {
        var properties = feature.getProperties();
        var layers = layersBySourceLayer[properties.layer];
        if (!layers) return;
        var zoom = resolutions.indexOf(resolution);
        if (zoom == -1) zoom = getZoomForResolution(resolution, resolutions);
        var type = types[feature.getGeometry().getType()];
        var f = {
            properties: properties,
            type: type
        };
        var featureState = olLayer.get("mapbox-featurestate")[feature.getId()];
        var stylesLength = -1;
        var featureBelongsToLayer;
        for(var i = 0, ii = layers.length; i < ii; ++i){
            var layerData = layers[i];
            var layer = layerData.layer;
            var layerId = layer.id;
            var layout = layer.layout || emptyObj$1;
            var paint = layer.paint || emptyObj$1;
            if (layout.visibility === "none" || "minzoom" in layer && zoom < layer.minzoom || "maxzoom" in layer && zoom >= layer.maxzoom) continue;
            var filter = layer.filter;
            if (!filter || evaluateFilter(layerId, filter, f, zoom, filterCache)) {
                featureBelongsToLayer = layer;
                var color = void 0, opacity = void 0, fill = void 0, stroke = void 0, strokeColor = void 0, style = void 0;
                var index = layerData.index;
                if (type == 3 && (layer.type == "fill" || layer.type == "fill-extrusion")) {
                    opacity = getValue(layer, "paint", layer.type + "-opacity", zoom, f, functionCache, featureState);
                    if (layer.type + "-pattern" in paint) {
                        var fillIcon = getValue(layer, "paint", layer.type + "-pattern", zoom, f, functionCache, featureState);
                        if (fillIcon) {
                            var icon = typeof fillIcon === "string" ? fromTemplate(fillIcon, properties) : fillIcon.toString();
                            if (spriteImage && spriteData && spriteData[icon]) {
                                ++stylesLength;
                                style = styles[stylesLength];
                                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                                    style = new (0, _styleJsDefault.default)({
                                        fill: new (0, _fillJsDefault.default)()
                                    });
                                    styles[stylesLength] = style;
                                }
                                fill = style.getFill();
                                style.setZIndex(index);
                                var icon_cache_key = icon + "." + opacity;
                                var pattern = patternCache[icon_cache_key];
                                if (!pattern) {
                                    var spriteImageData = spriteData[icon];
                                    var canvas = createCanvas(spriteImageData.width, spriteImageData.height);
                                    var ctx = canvas.getContext("2d");
                                    ctx.globalAlpha = opacity;
                                    ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);
                                    pattern = ctx.createPattern(canvas, "repeat");
                                    patternCache[icon_cache_key] = pattern;
                                }
                                fill.setColor(pattern);
                            }
                        }
                    } else {
                        color = colorWithOpacity(getValue(layer, "paint", layer.type + "-color", zoom, f, functionCache, featureState), opacity);
                        if (layer.type + "-outline-color" in paint) strokeColor = colorWithOpacity(getValue(layer, "paint", layer.type + "-outline-color", zoom, f, functionCache, featureState), opacity);
                        if (!strokeColor) strokeColor = color;
                        if (color || strokeColor) {
                            ++stylesLength;
                            style = styles[stylesLength];
                            if (!style || color && !style.getFill() || !color && style.getFill() || strokeColor && !style.getStroke() || !strokeColor && style.getStroke() || style.getText()) {
                                style = new (0, _styleJsDefault.default)({
                                    fill: color ? new (0, _fillJsDefault.default)() : undefined,
                                    stroke: strokeColor ? new (0, _strokeJsDefault.default)() : undefined
                                });
                                styles[stylesLength] = style;
                            }
                            if (color) {
                                fill = style.getFill();
                                fill.setColor(color);
                            }
                            if (strokeColor) {
                                stroke = style.getStroke();
                                stroke.setColor(strokeColor);
                                stroke.setWidth(0.5);
                            }
                            style.setZIndex(index);
                        }
                    }
                }
                if (type != 1 && layer.type == "line") {
                    color = !("line-pattern" in paint) && "line-color" in paint ? colorWithOpacity(getValue(layer, "paint", "line-color", zoom, f, functionCache, featureState), getValue(layer, "paint", "line-opacity", zoom, f, functionCache, featureState)) : undefined;
                    var width = getValue(layer, "paint", "line-width", zoom, f, functionCache, featureState);
                    if (color && width > 0) {
                        ++stylesLength;
                        style = styles[stylesLength];
                        if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                            style = new (0, _styleJsDefault.default)({
                                stroke: new (0, _strokeJsDefault.default)()
                            });
                            styles[stylesLength] = style;
                        }
                        stroke = style.getStroke();
                        stroke.setLineCap(getValue(layer, "layout", "line-cap", zoom, f, functionCache, featureState));
                        stroke.setLineJoin(getValue(layer, "layout", "line-join", zoom, f, functionCache, featureState));
                        stroke.setMiterLimit(getValue(layer, "layout", "line-miter-limit", zoom, f, functionCache, featureState));
                        stroke.setColor(color);
                        stroke.setWidth(width);
                        stroke.setLineDash(paint["line-dasharray"] ? getValue(layer, "paint", "line-dasharray", zoom, f, functionCache, featureState).map(function(x) {
                            return x * width;
                        }) : null);
                        style.setZIndex(index);
                    }
                }
                var hasImage = false;
                var text = null;
                var placementAngle = 0;
                var icon$1 = void 0, iconImg = void 0, skipLabel = void 0;
                if ((type == 1 || type == 2) && "icon-image" in layout) {
                    var iconImage = getValue(layer, "layout", "icon-image", zoom, f, functionCache, featureState);
                    if (iconImage) {
                        icon$1 = typeof iconImage === "string" ? fromTemplate(iconImage, properties) : iconImage.toString();
                        var styleGeom = undefined;
                        var imageElement = getImage ? getImage(olLayer, icon$1) : undefined;
                        if (spriteImage && spriteData && spriteData[icon$1] || imageElement) {
                            var iconRotationAlignment = getValue(layer, "layout", "icon-rotation-alignment", zoom, f, functionCache, featureState);
                            if (type == 2) {
                                var geom = feature.getGeometry();
                                // ol package and ol-debug.js only
                                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {
                                    var extent = geom.getExtent();
                                    var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));
                                    if (size > 150) {
                                        //FIXME Do not hard-code a size of 150
                                        var midpoint = geom.getType() === "MultiLineString" ? geom.getFlatMidpoints() : geom.getFlatMidpoint();
                                        if (!renderFeature) {
                                            renderFeatureCoordinates = [
                                                NaN,
                                                NaN
                                            ];
                                            renderFeature = new (0, _featureJsDefault.default)("Point", renderFeatureCoordinates, [], {}, null);
                                        }
                                        styleGeom = renderFeature;
                                        renderFeatureCoordinates[0] = midpoint[0];
                                        renderFeatureCoordinates[1] = midpoint[1];
                                        var placement = getValue(layer, "layout", "symbol-placement", zoom, f, functionCache, featureState);
                                        if (placement === "line" && iconRotationAlignment === "map") {
                                            var stride = geom.getStride();
                                            var coordinates = geom.getFlatCoordinates();
                                            for(var i$1 = 0, ii$1 = coordinates.length - stride; i$1 < ii$1; i$1 += stride){
                                                var x1 = coordinates[i$1];
                                                var y1 = coordinates[i$1 + 1];
                                                var x2 = coordinates[i$1 + stride];
                                                var y2 = coordinates[i$1 + stride + 1];
                                                var minX = Math.min(x1, x2);
                                                var minY = Math.min(y1, y2);
                                                var maxX = Math.max(x1, x2);
                                                var maxY = Math.max(y1, y2);
                                                if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {
                                                    placementAngle = Math.atan2(y1 - y2, x2 - x1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (type !== 2 || styleGeom) {
                                var iconSize = getValue(layer, "layout", "icon-size", zoom, f, functionCache, featureState);
                                var iconColor = paint["icon-color"] !== undefined ? getValue(layer, "paint", "icon-color", zoom, f, functionCache, featureState) : null;
                                if (!iconColor || iconColor.a !== 0) {
                                    var icon_cache_key$1 = icon$1 + "." + iconSize;
                                    if (iconColor !== null) icon_cache_key$1 += "." + iconColor;
                                    iconImg = iconImageCache[icon_cache_key$1];
                                    if (!iconImg) {
                                        var declutterMode = getIconDeclutterMode(layer, zoom, f, functionCache);
                                        var displacement = void 0;
                                        if ("icon-offset" in layout) {
                                            displacement = getValue(layer, "layout", "icon-offset", zoom, f, functionCache, featureState);
                                            displacement[1] *= -1;
                                        }
                                        var color$1 = iconColor ? [
                                            iconColor.r * 255,
                                            iconColor.g * 255,
                                            iconColor.b * 255,
                                            iconColor.a
                                        ] : undefined;
                                        if (imageElement) {
                                            if (typeof imageElement === "string") // it is a src URL
                                            iconImg = new (0, _iconJsDefault.default)({
                                                color: color$1,
                                                src: imageElement,
                                                rotateWithView: iconRotationAlignment === "map",
                                                displacement: displacement,
                                                declutterMode: declutterMode
                                            });
                                            else iconImg = new (0, _iconJsDefault.default)({
                                                color: color$1,
                                                img: imageElement,
                                                imgSize: [
                                                    imageElement.width,
                                                    imageElement.height
                                                ],
                                                rotateWithView: iconRotationAlignment === "map",
                                                displacement: displacement,
                                                declutterMode: declutterMode
                                            });
                                        } else {
                                            var spriteImageData$1 = spriteData[icon$1];
                                            iconImg = new (0, _iconJsDefault.default)({
                                                color: color$1,
                                                img: spriteImage,
                                                imgSize: spriteImageSize,
                                                size: [
                                                    spriteImageData$1.width,
                                                    spriteImageData$1.height
                                                ],
                                                offset: [
                                                    spriteImageData$1.x,
                                                    spriteImageData$1.y
                                                ],
                                                rotateWithView: iconRotationAlignment === "map",
                                                scale: iconSize / spriteImageData$1.pixelRatio,
                                                displacement: displacement,
                                                declutterMode: declutterMode
                                            });
                                        }
                                        iconImageCache[icon_cache_key$1] = iconImg;
                                    }
                                }
                                if (iconImg) {
                                    ++stylesLength;
                                    style = styles[stylesLength];
                                    if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                                        style = new (0, _styleJsDefault.default)();
                                        styles[stylesLength] = style;
                                    }
                                    style.setGeometry(styleGeom);
                                    iconImg.setRotation(placementAngle + deg2rad(getValue(layer, "layout", "icon-rotate", zoom, f, functionCache, featureState)));
                                    iconImg.setOpacity(getValue(layer, "paint", "icon-opacity", zoom, f, functionCache, featureState));
                                    iconImg.setAnchor(anchor[getValue(layer, "layout", "icon-anchor", zoom, f, functionCache, featureState)]);
                                    style.setImage(iconImg);
                                    text = style.getText();
                                    style.setText(undefined);
                                    style.setZIndex(index);
                                    hasImage = true;
                                    skipLabel = false;
                                }
                            } else skipLabel = true;
                        }
                    }
                }
                if (type == 1 && layer.type === "circle") {
                    ++stylesLength;
                    style = styles[stylesLength];
                    if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                        style = new (0, _styleJsDefault.default)();
                        styles[stylesLength] = style;
                    }
                    var circleRadius = "circle-radius" in paint ? getValue(layer, "paint", "circle-radius", zoom, f, functionCache, featureState) : 5;
                    var circleStrokeColor = colorWithOpacity(getValue(layer, "paint", "circle-stroke-color", zoom, f, functionCache, featureState), getValue(layer, "paint", "circle-stroke-opacity", zoom, f, functionCache, featureState));
                    var circleColor = colorWithOpacity(getValue(layer, "paint", "circle-color", zoom, f, functionCache, featureState), getValue(layer, "paint", "circle-opacity", zoom, f, functionCache, featureState));
                    var circleStrokeWidth = getValue(layer, "paint", "circle-stroke-width", zoom, f, functionCache, featureState);
                    var cache_key = circleRadius + "." + circleStrokeColor + "." + circleColor + "." + circleStrokeWidth;
                    iconImg = iconImageCache[cache_key];
                    if (!iconImg) {
                        iconImg = new (0, _circleJsDefault.default)({
                            radius: circleRadius,
                            stroke: circleStrokeColor && circleStrokeWidth > 0 ? new (0, _strokeJsDefault.default)({
                                width: circleStrokeWidth,
                                color: circleStrokeColor
                            }) : undefined,
                            fill: circleColor ? new (0, _fillJsDefault.default)({
                                color: circleColor
                            }) : undefined,
                            declutterMode: "none"
                        });
                        iconImageCache[cache_key] = iconImg;
                    }
                    style.setImage(iconImg);
                    text = style.getText();
                    style.setText(undefined);
                    style.setGeometry(undefined);
                    style.setZIndex(index);
                    hasImage = true;
                }
                var label = void 0, font = void 0, textLineHeight = void 0, textSize = void 0, letterSpacing = void 0, maxTextWidth = void 0;
                if ("text-field" in layout) {
                    textSize = Math.round(getValue(layer, "layout", "text-size", zoom, f, functionCache, featureState));
                    var fontArray = getValue(layer, "layout", "text-font", zoom, f, functionCache, featureState);
                    textLineHeight = getValue(layer, "layout", "text-line-height", zoom, f, functionCache, featureState);
                    font = mapboxToCssFont(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);
                    if (!font.includes("sans-serif")) font += ",sans-serif";
                    letterSpacing = getValue(layer, "layout", "text-letter-spacing", zoom, f, functionCache, featureState);
                    maxTextWidth = getValue(layer, "layout", "text-max-width", zoom, f, functionCache, featureState);
                    var textField = getValue(layer, "layout", "text-field", zoom, f, functionCache, featureState);
                    if (typeof textField === "object" && textField.sections) {
                        if (textField.sections.length === 1) label = textField.toString();
                        else label = textField.sections.reduce(function(acc, chunk, i) {
                            var fonts = chunk.fontStack ? chunk.fontStack.split(",") : fontArray;
                            var chunkFont = mapboxToCssFont(getFonts ? getFonts(fonts) : fonts, textSize * (chunk.scale || 1), textLineHeight);
                            var text = chunk.text;
                            if (text === "\n") {
                                acc.push("\n", "");
                                return acc;
                            }
                            if (type == 2) {
                                acc.push(applyLetterSpacing(text, letterSpacing), chunkFont);
                                return;
                            }
                            text = wrapText(text, chunkFont, maxTextWidth, letterSpacing).split("\n");
                            for(var i$1 = 0, ii = text.length; i$1 < ii; ++i$1){
                                if (i$1 > 0) acc.push("\n", "");
                                acc.push(text[i$1], chunkFont);
                            }
                            return acc;
                        }, []);
                    } else label = fromTemplate(textField, properties).trim();
                    opacity = getValue(layer, "paint", "text-opacity", zoom, f, functionCache, featureState);
                }
                if (label && opacity && !skipLabel) {
                    if (!hasImage) {
                        ++stylesLength;
                        style = styles[stylesLength];
                        if (!style || !style.getText() || style.getFill() || style.getStroke()) {
                            style = new (0, _styleJsDefault.default)();
                            styles[stylesLength] = style;
                        }
                        style.setImage(undefined);
                        style.setGeometry(undefined);
                    }
                    if (!style.getText()) style.setText(text || new (0, _textJsDefault.default)({
                        padding: [
                            2,
                            2,
                            2,
                            2
                        ]
                    }));
                    text = style.getText();
                    var textTransform = layout["text-transform"];
                    if (textTransform == "uppercase") label = Array.isArray(label) ? label.map(function(t, i) {
                        return i % 2 ? t : t.toUpperCase();
                    }) : label.toUpperCase();
                    else if (textTransform == "lowercase") label = Array.isArray(label) ? label.map(function(t, i) {
                        return i % 2 ? t : t.toLowerCase();
                    }) : label.toLowerCase();
                    var wrappedLabel = Array.isArray(label) ? label : type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);
                    text.setText(wrappedLabel);
                    text.setFont(font);
                    text.setRotation(deg2rad(getValue(layer, "layout", "text-rotate", zoom, f, functionCache, featureState)));
                    var textAnchor = getValue(layer, "layout", "text-anchor", zoom, f, functionCache, featureState);
                    var placement$1 = hasImage || type == 1 ? "point" : getValue(layer, "layout", "symbol-placement", zoom, f, functionCache, featureState);
                    text.setPlacement(placement$1);
                    text.setOverflow(placement$1 === "point");
                    var textHaloWidth = getValue(layer, "paint", "text-halo-width", zoom, f, functionCache, featureState);
                    var textOffset = getValue(layer, "layout", "text-offset", zoom, f, functionCache, featureState);
                    var textTranslate = getValue(layer, "paint", "text-translate", zoom, f, functionCache, featureState);
                    // Text offset has to take halo width and line height into account
                    var vOffset = 0;
                    var hOffset = 0;
                    if (placement$1 == "point") {
                        var textAlign = "center";
                        if (textAnchor.indexOf("left") !== -1) {
                            textAlign = "left";
                            hOffset = textHaloWidth;
                        } else if (textAnchor.indexOf("right") !== -1) {
                            textAlign = "right";
                            hOffset = -textHaloWidth;
                        }
                        text.setTextAlign(textAlign);
                        var textRotationAlignment = getValue(layer, "layout", "text-rotation-alignment", zoom, f, functionCache, featureState);
                        text.setRotateWithView(textRotationAlignment == "map");
                    } else {
                        text.setMaxAngle(deg2rad(getValue(layer, "layout", "text-max-angle", zoom, f, functionCache, featureState)) * label.length / wrappedLabel.length);
                        text.setTextAlign();
                        text.setRotateWithView(false);
                    }
                    var textBaseline = "middle";
                    if (textAnchor.indexOf("bottom") == 0) {
                        textBaseline = "bottom";
                        vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
                    } else if (textAnchor.indexOf("top") == 0) {
                        textBaseline = "top";
                        vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
                    }
                    text.setTextBaseline(textBaseline);
                    var textJustify = getValue(layer, "layout", "text-justify", zoom, f, functionCache, featureState);
                    text.setJustify(textJustify === "auto" ? undefined : textJustify);
                    text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);
                    text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);
                    textColor.setColor(colorWithOpacity(getValue(layer, "paint", "text-color", zoom, f, functionCache, featureState), opacity));
                    text.setFill(textColor);
                    var haloColor = colorWithOpacity(getValue(layer, "paint", "text-halo-color", zoom, f, functionCache, featureState), opacity);
                    if (haloColor) {
                        textHalo.setColor(haloColor);
                        // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width
                        // Halo width must be doubled because it is applied around the center of the text outline
                        textHaloWidth *= 2;
                        // 1/4 of text size (spec) x 2
                        var halfTextSize = 0.5 * textSize;
                        textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);
                        text.setStroke(textHalo);
                    } else text.setStroke(undefined);
                    var textPadding = getValue(layer, "layout", "text-padding", zoom, f, functionCache, featureState);
                    var padding = text.getPadding();
                    if (textPadding !== padding[0]) {
                        padding[0] = textPadding;
                        padding[1] = textPadding;
                        padding[2] = textPadding;
                        padding[3] = textPadding;
                    }
                    style.setZIndex(index);
                }
            }
        }
        if (stylesLength > -1) {
            styles.length = stylesLength + 1;
            if (recordLayer) {
                if (typeof feature.set === "function") // ol/Feature
                feature.set("mapbox-layer", featureBelongsToLayer);
                else // ol/render/Feature
                feature.getProperties()["mapbox-layer"] = featureBelongsToLayer;
            }
            return styles;
        }
    };
    olLayer.setStyle(styleFunction);
    olLayer.set("mapbox-source", mapboxSource);
    olLayer.set("mapbox-layers", mapboxLayers);
    olLayer.set("mapbox-featurestate", {});
    return styleFunction;
}
/**
 * Generates a shaded relief image given elevation data.  Uses a 3x3
 * neighborhood for determining slope and aspect.
 * @param {Array<ImageData>} inputs Array of input images.
 * @param {Object} data Data added in the "beforeoperations" event.
 * @return {ImageData} Output image.
 */ function hillshade(inputs, data) {
    var elevationImage = inputs[0];
    var width = elevationImage.width;
    var height = elevationImage.height;
    var elevationData = elevationImage.data;
    var shadeData = new Uint8ClampedArray(elevationData.length);
    var dp = data.resolution * 2;
    var maxX = width - 1;
    var maxY = height - 1;
    var pixel = [
        0,
        0,
        0,
        0
    ];
    var twoPi = 2 * Math.PI;
    var halfPi = Math.PI / 2;
    var sunEl = Math.PI * data.sunEl / 180;
    var sunAz = Math.PI * data.sunAz / 180;
    var cosSunEl = Math.cos(sunEl);
    var sinSunEl = Math.sin(sunEl);
    var pixelX, pixelY, x0, x1, y0, y1, offset, z0, z1, dzdx, dzdy, slope, aspect, cosIncidence, scaled;
    function calculateElevation(pixel) {
        // The method used to extract elevations from the DEM.
        // In this case the format used is
        // red + green * 2 + blue * 3
        //
        // Other frequently used methods include the Mapbox format
        // (red * 256 * 256 + green * 256 + blue) * 0.1 - 10000
        // and the Terrarium format
        // (red * 256 + green + blue / 256) - 32768
        //
        return (pixel[0] * 65536 + pixel[1] * 256 + pixel[2]) * 0.1 - 10000;
    }
    for(pixelY = 0; pixelY <= maxY; ++pixelY){
        y0 = pixelY === 0 ? 0 : pixelY - 1;
        y1 = pixelY === maxY ? maxY : pixelY + 1;
        for(pixelX = 0; pixelX <= maxX; ++pixelX){
            x0 = pixelX === 0 ? 0 : pixelX - 1;
            x1 = pixelX === maxX ? maxX : pixelX + 1;
            // determine elevation for (x0, pixelY)
            offset = (pixelY * width + x0) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z0 = data.vert * calculateElevation(pixel);
            // determine elevation for (x1, pixelY)
            offset = (pixelY * width + x1) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z1 = data.vert * calculateElevation(pixel);
            dzdx = (z1 - z0) / dp;
            // determine elevation for (pixelX, y0)
            offset = (y0 * width + pixelX) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z0 = data.vert * calculateElevation(pixel);
            // determine elevation for (pixelX, y1)
            offset = (y1 * width + pixelX) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z1 = data.vert * calculateElevation(pixel);
            dzdy = (z1 - z0) / dp;
            slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));
            aspect = Math.atan2(dzdy, -dzdx);
            if (aspect < 0) aspect = halfPi - aspect;
            else if (aspect > halfPi) aspect = twoPi - aspect + halfPi;
            else aspect = halfPi - aspect;
            cosIncidence = sinSunEl * Math.cos(slope) + cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);
            offset = (pixelY * width + pixelX) * 4;
            scaled = 255 * cosIncidence;
            shadeData[offset] = scaled;
            shadeData[offset + 1] = scaled;
            shadeData[offset + 2] = scaled;
            shadeData[offset + 3] = elevationData[offset + 3] * data.opacity;
        }
    }
    return new ImageData(shadeData, width, height);
}
/*
ol-mapbox-style - Use Mapbox Style objects with OpenLayers
Copyright 2016-present ol-mapbox-style contributors
License: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE
*/ /** @typedef {import("ol/layer/Group.js").default} LayerGroup */ /**
 * @typedef {Object} FeatureIdentifier
 * @property {string|number} id The feature id.
 * @property {string} source The source id.
 */ /**
 * @typedef {Object} Options
 * @property {string} [accessToken] Access token for 'mapbox://' urls.
 * @property {function(string, ResourceType): (Request|void)} [transformRequest]
 * Function for controlling how `ol-mapbox-style` fetches resources. Can be used for modifying
 * the url, adding headers or setting credentials options. Called with the url and the resource
 * type as arguments, this function is supposed to return a `Request` object. Without a return value,
 * the original request will not be modified. For `Tiles` and `GeoJSON` resources, only the `url` of
 * the returned request will be respected.
 * @property {Array<number>} [resolutions] Resolutions for mapping resolution to zoom level.
 * Only needed when working with non-standard tile grids or projections.
 * @property {string} [styleUrl] URL of the Mapbox GL style. Required for styles that were provided
 * as object, when they contain a relative sprite url, or sources referencing data by relative url.
 * @property {string} [accessTokenParam='access_token'] Access token param. For internal use.
 * @property {function(VectorLayer|VectorTileLayer, string):HTMLImageElement|HTMLCanvasElement|string|undefined} [getImage=undefined]
 * Function that returns an image for an icon name. If the result is an HTMLImageElement, it must already be
 * loaded. The layer can be used to call layer.changed() when the loading and processing of the image has finished.
 * This function be used for icons not in the sprite or to override sprite icons.
 */ /**
 * @typedef {Object} ApplyStyleOptions
 * @property {string} [source=''] Source. Default is `''`, which causes the first source in the
 * style to be used.
 * @property {Array<string>} [layers] Layers. If no source is provided, the layers with the
 * provided ids will be used from the style's `layers` array. All layers need to use the same source.
 */ /** @typedef {'Style'|'Source'|'Sprite'|'SpriteImage'|'Tiles'|'GeoJSON'} ResourceType */ /** @typedef {import("ol/layer/Layer").default} Layer */ /** @typedef {import("ol/source/Source").default} Source */ /**
 * @param {string} styleUrl Style URL.
 * @param {Options} options Options.
 * @return {Options} Completed options with accessToken and accessTokenParam.
 */ function completeOptions(styleUrl, options) {
    if (!options.accessToken) {
        options = Object.assign({}, options);
        var searchParams = new URL(styleUrl).searchParams;
        // The last search parameter is the access token
        searchParams.forEach(function(value, key) {
            options.accessToken = value;
            options.accessTokenParam = key;
        });
    }
    return options;
}
/**
 * Applies a style function to an `ol/layer/VectorTile` or `ol/layer/Vector`
 * with an `ol/source/VectorTile` or an `ol/source/Vector`. If the layer does not have a source
 * yet, it will be created and populated from the information in the `glStyle`.
 *
 * **Example:**
 * ```js
 * import {applyStyle} from 'ol-mapbox-style';
 * import {VectorTile} from 'ol/layer.js';
 *
 * const layer = new VectorTile({declutter: true});
 * applyStyle(layer, 'https://api.maptiler.com/maps/basic/style.json?key=YOUR_OPENMAPTILES_TOKEN');
 * ```
 *
 * The style function will render all layers from the `glStyle` object that use the source
 * of the first layer, the specified `source`, or a subset of layers from the same source. The
 * source needs to be a `"type": "vector"` or `"type": "geojson"` source.
 *
 * Two additional properties will be set on the provided layer:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer. When the layer has a source configured,
 * it will be modified to use the configuration from the glStyle's `source`. Options specified on the
 * layer's source will override those from the glStyle's `source`, except for `url`,
 * `tileUrlFunction` and `tileGrid` (exception: when the source projection is not `EPSG:3857`).
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>|Options&ApplyStyleOptions} [sourceOrLayersOrOptions] Options or
 * `source` key or an array of layer `id`s from the Mapbox Style object. When a `source` key is
 * provided, all layers for the specified source will be included in the style function. When layer
 * `id`s are provided, they must be from layers that use the same source. When not provided or a falsey
 * value, all layers using the first source specified in the glStyle will be rendered.
 * @param {Options|string} [optionsOrPath] **Deprecated**. Options. Alternatively the path of the style file
 * (only required when a relative path is used for the `"sprite"` property of the style).
 * @param {Array<number>} [resolutions] **Deprecated**. Resolutions for mapping resolution to zoom level.
 * Only needed when working with non-standard tile grids or projections, can also be supplied with
 * options.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */ function applyStyle(layer, glStyle, sourceOrLayersOrOptions, optionsOrPath, resolutions) {
    if (sourceOrLayersOrOptions === void 0) sourceOrLayersOrOptions = "";
    if (optionsOrPath === void 0) optionsOrPath = {};
    if (resolutions === void 0) resolutions = undefined;
    var styleUrl, sourceId;
    /** @type {Options&ApplyStyleOptions} */ var options;
    var sourceOrLayers;
    if (typeof sourceOrLayersOrOptions !== "string" && !Array.isArray(sourceOrLayersOrOptions)) {
        options = sourceOrLayersOrOptions;
        sourceOrLayers = options.source || options.layers;
        optionsOrPath = options;
    } else sourceOrLayers = sourceOrLayersOrOptions;
    if (typeof optionsOrPath === "string") {
        styleUrl = optionsOrPath;
        options = {};
    } else {
        styleUrl = optionsOrPath.styleUrl;
        options = optionsOrPath;
    }
    if (!resolutions) resolutions = options.resolutions;
    if (!styleUrl && typeof glStyle === "string" && !glStyle.trim().startsWith("{")) styleUrl = glStyle;
    if (styleUrl) {
        styleUrl = styleUrl.startsWith("data:") ? location.href : normalizeStyleUrl(styleUrl, options.accessToken);
        options = completeOptions(styleUrl, options);
    }
    return new Promise(function(resolve, reject) {
        // TODO: figure out where best place to check source type is
        // Note that the source arg is an array of gl layer ids and each must be
        // dereferenced to get source type to validate
        getGlStyle(glStyle, options).then(function(glStyle) {
            if (glStyle.version != 8) return reject(new Error("glStyle version 8 required."));
            if (!(layer instanceof (0, _vectorJsDefault.default) || layer instanceof (0, _vectorTileJsDefault.default))) return reject(new Error("Can only apply to VectorLayer or VectorTileLayer"));
            var type = layer instanceof (0, _vectorTileJsDefault.default) ? "vector" : "geojson";
            if (!sourceOrLayers) {
                sourceId = Object.keys(glStyle.sources).find(function(key) {
                    return glStyle.sources[key].type === type;
                });
                sourceOrLayers = sourceId;
            } else if (Array.isArray(sourceOrLayers)) sourceId = glStyle.layers.find(function(layer) {
                return layer.id === sourceOrLayers[0];
            }).source;
            else sourceId = sourceOrLayers;
            if (!sourceId) return reject(new Error("No " + type + " source found in the glStyle."));
            function assignSource() {
                if (layer instanceof (0, _vectorTileJsDefault.default)) return setupVectorSource(glStyle.sources[sourceId], styleUrl, options).then(function(source) {
                    var targetSource = layer.getSource();
                    if (!targetSource) layer.setSource(source);
                    else if (source !== targetSource) {
                        targetSource.setTileUrlFunction(source.getTileUrlFunction());
                        //@ts-ignore
                        if (!targetSource.format_) //@ts-ignore
                        targetSource.format_ = source.format_;
                        if (!targetSource.getAttributions()) targetSource.setAttributions(source.getAttributions());
                        if (targetSource.getTileLoadFunction() === (0, _vectorTileJs1.defaultLoadFunction)) targetSource.setTileLoadFunction(source.getTileLoadFunction());
                        if ((0, _projJs.equivalent)(targetSource.getProjection(), source.getProjection())) targetSource.tileGrid = source.getTileGrid();
                    }
                    if (!isFinite(layer.getMaxResolution()) && !isFinite(layer.getMinZoom())) {
                        var tileGrid = layer.getSource().getTileGrid();
                        layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));
                    }
                });
                var glSource = glStyle.sources[sourceId];
                var source = layer.getSource();
                if (!source || source.get("mapbox-source") !== glSource) source = setupGeoJSONSource(glSource, styleUrl, options);
                var targetSource = layer.getSource();
                if (!targetSource) layer.setSource(source);
                else if (source !== targetSource) {
                    if (!targetSource.getAttributions()) targetSource.setAttributions(source.getAttributions());
                    //@ts-ignore
                    if (!targetSource.format_) //@ts-ignore
                    targetSource.format_ = source.getFormat();
                    //@ts-ignore
                    targetSource.url_ = source.getUrl();
                }
                return Promise.resolve();
            }
            var spriteScale, spriteData, spriteImageUrl, style;
            function onChange() {
                if (!style && (!glStyle.sprite || spriteData)) {
                    style = stylefunction(layer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, options.getImage);
                    if (!layer.getStyle()) reject(new Error("Nothing to show for source [" + sourceId + "]"));
                    else assignSource().then(resolve).catch(reject);
                } else if (style) {
                    layer.setStyle(style);
                    assignSource().then(resolve).catch(reject);
                } else reject(new Error("Something went wrong trying to apply style."));
            }
            if (glStyle.sprite) {
                var sprite = new URL(normalizeSpriteUrl(glStyle.sprite, options.accessToken, styleUrl || location.href));
                spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
                var sizeFactor = spriteScale == 0.5 ? "@2x" : "";
                var spriteUrl = sprite.origin + sprite.pathname + sizeFactor + ".json" + sprite.search;
                new Promise(function(resolve, reject) {
                    fetchResource("Sprite", spriteUrl, options).then(resolve).catch(function(error) {
                        spriteUrl = sprite.origin + sprite.pathname + ".json" + sprite.search;
                        fetchResource("Sprite", spriteUrl, options).then(resolve).catch(reject);
                    });
                }).then(function(spritesJson) {
                    if (spritesJson === undefined) reject(new Error("No sprites found."));
                    spriteData = spritesJson;
                    spriteImageUrl = sprite.origin + sprite.pathname + sizeFactor + ".png" + sprite.search;
                    if (options.transformRequest) {
                        var transformed = options.transformRequest(spriteImageUrl, "SpriteImage");
                        if (transformed instanceof Request) spriteImageUrl = encodeURI(transformed.url);
                    }
                    onChange();
                }).catch(function(err) {
                    reject(new Error("Sprites cannot be loaded: " + spriteUrl + ": " + err.message));
                });
            } else onChange();
        }).catch(reject);
    });
}
var emptyObj = {};
function setBackground(mapOrLayer, layer, options) {
    var background = {
        id: layer.id,
        type: layer.type
    };
    var functionCache = {};
    function getBackgroundColor(resolution) {
        var layout = layer.layout || {};
        var paint = layer.paint || {};
        background["paint"] = paint;
        var zoom = getZoomForResolution(resolution, options.resolutions || defaultResolutions);
        var bg, opacity;
        if (paint["background-color"] !== undefined) bg = getValue(background, "paint", "background-color", zoom, emptyObj, functionCache);
        if (paint["background-opacity"] !== undefined) opacity = getValue(background, "paint", "background-opacity", zoom, emptyObj, functionCache);
        return layout.visibility == "none" ? undefined : colorWithOpacity(bg, opacity);
    }
    var lastRenderTime = 0;
    var backgroundRendered = false;
    /**
   * @param {import("ol/render/Event.js").default} e Render event
   */ function renderBackground(e) {
        if (e.frameState.time !== lastRenderTime) {
            lastRenderTime = e.frameState.time;
            backgroundRendered = false;
        }
        if (backgroundRendered) return;
        if (!(e.context instanceof CanvasRenderingContext2D)) throw new Error("Cannot apply background to WebGL context");
        var resolution = e.frameState.viewState.resolution;
        var color = getBackgroundColor(resolution);
        if (color) {
            var context = e.context;
            var alpha = context.globalAlpha;
            var gobalCompositeOperation = context.globalCompositeOperation;
            context.globalAlpha = 1;
            context.globalCompositeOperation = "destination-over";
            context.fillStyle = color;
            context.fillRect(0, 0, e.context.canvas.width, e.context.canvas.height);
            context.globalAlpha = alpha;
            context.globalCompositeOperation = gobalCompositeOperation;
        }
        backgroundRendered = true;
    }
    if (typeof mapOrLayer.getLayers === "function") {
        // map or layer group
        var layers = mapOrLayer.getLayers();
        layers.forEach(function(layer) {
            layer.on("postrender", renderBackground);
        });
        layers.on("add", function(e) {
            e.element.on("postrender", renderBackground);
        });
        layers.on("remove", function(e) {
            e.element.un("postrender", renderBackground);
        });
    } else mapOrLayer.on("postrender", renderBackground);
}
function setFirstBackground(mapOrLayer, glStyle, options) {
    glStyle.layers.some(function(layer) {
        if (layer.type === "background") {
            setBackground(mapOrLayer, layer, options);
            return true;
        }
    });
}
/**
 * Applies properties of the Mapbox Style's first `background` layer to the
 * provided map or VectorTile layer.
 *
 * **Example:**
 * ```js
 * import {applyBackground} from 'ol-mapbox-style';
 * import {Map} from 'ol';
 *
 * const map = new Map({target: 'map'});
 * applyBackground(map, 'https://api.maptiler.com/maps/basic/style.json?key=YOUR_OPENMAPTILES_TOKEN');
 * ```
 * @param {Map|VectorTileLayer} mapOrLayer OpenLayers Map or VectorTile layer.
 * @param {Object|string} glStyle Mapbox Style object or url.
 * @param {Options} options Options.
 * @return {Promise} Promise that resolves when the background is applied.
 */ function applyBackground(mapOrLayer, glStyle, options) {
    if (options === void 0) options = {};
    if (typeof glStyle === "object") {
        setFirstBackground(mapOrLayer, glStyle, options);
        return Promise.resolve();
    }
    return getGlStyle(glStyle, options).then(function(glStyle) {
        setFirstBackground(mapOrLayer, glStyle, options);
    });
}
function getSourceIdByRef(layers, ref) {
    var sourceId;
    layers.some(function(layer) {
        if (layer.id == ref) {
            sourceId = layer.source;
            return true;
        }
    });
    return sourceId;
}
function extentFromTileJSON(tileJSON) {
    var bounds = tileJSON.bounds;
    if (bounds) {
        var ll = (0, _projJs.fromLonLat)([
            bounds[0],
            bounds[1]
        ]);
        var tr = (0, _projJs.fromLonLat)([
            bounds[2],
            bounds[3]
        ]);
        return [
            ll[0],
            ll[1],
            tr[0],
            tr[1]
        ];
    }
}
/**
 * Creates an OpenLayers VectorTile source for a gl source entry.
 * @param {Object} glSource "source" entry from a Mapbox Style object.
 * @param {string|undefined} styleUrl URL to use for the source. This is expected to be the complete http(s) url,
 * with access key applied.
 * @param {Options} options Options.
 * @return {Promise<import("ol/source/VectorTile").default>} Promise resolving to a VectorTile source.
 * @private
 */ function setupVectorSource(glSource, styleUrl, options) {
    return new Promise(function(resolve, reject) {
        getTileJson(glSource, styleUrl, options).then(function(tileJSON) {
            var tileJSONSource = new (0, _tileJSONJsDefault.default)({
                tileJSON: tileJSON
            });
            var tileJSONDoc = tileJSONSource.getTileJSON();
            var tileGrid = tileJSONSource.getTileGrid();
            var extent = extentFromTileJSON(tileJSONDoc);
            var minZoom = tileJSONDoc.minzoom || 0;
            var maxZoom = tileJSONDoc.maxzoom || 22;
            var sourceOptions = {
                attributions: tileJSONSource.getAttributions(),
                format: new (0, _mvtJsDefault.default)(),
                tileGrid: new (0, _tileGridJsDefault.default)({
                    origin: tileGrid.getOrigin(0),
                    extent: extent || tileGrid.getExtent(),
                    minZoom: minZoom,
                    resolutions: defaultResolutions.slice(0, maxZoom + 1),
                    tileSize: 512
                })
            };
            if (Array.isArray(tileJSONDoc.tiles)) sourceOptions.urls = tileJSONDoc.tiles;
            else sourceOptions.url = tileJSONDoc.tiles;
            if (tileJSON.olSourceOptions) Object.assign(sourceOptions, tileJSON.olSourceOptions);
            resolve(new (0, _vectorTileJsDefault1.default)(sourceOptions));
        }).catch(reject);
    });
}
function setupVectorLayer(glSource, styleUrl, options) {
    var layer = new (0, _vectorTileJsDefault.default)({
        declutter: true,
        visible: false
    });
    setupVectorSource(glSource, styleUrl, options).then(function(source) {
        source.set("mapbox-source", glSource);
        layer.setSource(source);
    }).catch(function(error) {
        layer.setSource(undefined);
    });
    return layer;
}
function setupRasterLayer(glSource, styleUrl, options) {
    var layer = new (0, _tileJsDefault.default)();
    getTileJson(glSource, styleUrl, options).then(function(tileJson) {
        var source = new (0, _tileJSONJsDefault.default)({
            interpolate: options.interpolate === undefined ? true : options.interpolate,
            transition: 0,
            crossOrigin: "anonymous",
            tileJSON: tileJson
        });
        var extent = extentFromTileJSON(tileJson);
        var tileGrid = source.getTileGrid();
        var tileSize = glSource.tileSize || tileJson.tileSize || 512;
        var minZoom = tileJson.minzoom || 0;
        var maxZoom = tileJson.maxzoom || 22;
        //@ts-ignore
        source.tileGrid = new (0, _tileGridJsDefault.default)({
            origin: tileGrid.getOrigin(0),
            extent: extent || tileGrid.getExtent(),
            minZoom: minZoom,
            resolutions: (0, _tilegridJs.createXYZ)({
                maxZoom: maxZoom,
                tileSize: tileSize
            }).getResolutions(),
            tileSize: tileSize
        });
        var getTileUrl = source.getTileUrlFunction();
        source.setTileUrlFunction(function(tileCoord, pixelRatio, projection) {
            var src = getTileUrl(tileCoord, pixelRatio, projection);
            if (src.indexOf("{bbox-epsg-3857}") != -1) {
                var bbox = source.getTileGrid().getTileCoordExtent(tileCoord);
                src = src.replace("{bbox-epsg-3857}", bbox.toString());
            }
            return src;
        });
        source.set("mapbox-source", glSource);
        layer.setSource(source);
    }).catch(function(error) {
        layer.setSource(undefined);
    });
    return layer;
}
/**
 *
 * @param {Object} glSource "source" entry from a Mapbox Style object.
 * @param {string} styleUrl Style url
 * @param {Options} options ol-mapbox-style options.
 * @return {ImageLayer<Raster>} The raster layer
 */ function setupHillshadeLayer(glSource, styleUrl, options) {
    var tileLayer = setupRasterLayer(glSource, styleUrl, options);
    /** @type {ImageLayer<Raster>} */ var layer = new (0, _imageJsDefault.default)({
        source: new (0, _rasterJsDefault.default)({
            operationType: "image",
            operation: hillshade,
            sources: [
                tileLayer
            ]
        })
    });
    return layer;
}
var geoJsonFormat = new (0, _geoJSONJsDefault.default)();
/**
 * @param {Object} glSource glStyle source.
 * @param {string} styleUrl Style URL.
 * @param {Options} options Options.
 * @return {VectorSource} Configured vector source.
 */ function setupGeoJSONSource(glSource, styleUrl, options) {
    var data = glSource.data;
    var sourceOptions = {};
    if (typeof data == "string") {
        var geoJsonUrl = normalizeSourceUrl(data, options.accessToken, options.accessTokenParam || "access_token", styleUrl || location.href);
        if (options.transformRequest) {
            var transformed = options.transformRequest(geoJsonUrl, "GeoJSON");
            if (transformed instanceof Request) geoJsonUrl = encodeURI(transformed.url);
        }
        if (geoJsonUrl.indexOf("{bbox-epsg-3857}") != -1) {
            var extentUrl = function(extent) {
                return geoJsonUrl.replace("{bbox-epsg-3857}", extent.join(",") + ",EPSG:3857");
            };
            var source$1 = new (0, _vectorJsDefault1.default)({
                attributions: glSource.attribution,
                format: geoJsonFormat,
                url: extentUrl,
                strategy: (0, _loadingstrategyJs.bbox)
            });
            source$1.set("mapbox-source", glSource);
            return source$1;
        }
        return new (0, _vectorJsDefault1.default)({
            attributions: glSource.attribution,
            format: geoJsonFormat,
            url: geoJsonUrl
        });
    }
    sourceOptions.features = geoJsonFormat.readFeatures(data, {
        featureProjection: (0, _projJs.getUserProjection)() || "EPSG:3857"
    });
    var source = new (0, _vectorJsDefault1.default)(Object.assign({
        attributions: glSource.attribution,
        format: geoJsonFormat
    }, sourceOptions));
    source.set("mapbox-source", glSource);
    return source;
}
function setupGeoJSONLayer(glSource, styleUrl, options) {
    return new (0, _vectorJsDefault.default)({
        declutter: true,
        source: setupGeoJSONSource(glSource, styleUrl, options),
        visible: false
    });
}
function prerenderRasterLayer(glLayer, layer, functionCache) {
    var zoom = null;
    return function(event) {
        if (glLayer.paint && "raster-opacity" in glLayer.paint && event.frameState.viewState.zoom !== zoom) {
            zoom = event.frameState.viewState.zoom;
            delete functionCache[glLayer.id];
            updateRasterLayerProperties(glLayer, layer, zoom, functionCache);
        }
    };
}
function updateRasterLayerProperties(glLayer, layer, zoom, functionCache) {
    var opacity = getValue(glLayer, "paint", "raster-opacity", zoom, emptyObj, functionCache);
    layer.setOpacity(opacity);
}
function processStyle(glStyle, mapOrGroup, styleUrl, options) {
    var promises = [];
    var view = null;
    if (mapOrGroup instanceof (0, _mapJsDefault.default)) {
        view = mapOrGroup.getView();
        if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {
            view = new (0, _viewJsDefault.default)(Object.assign(view.getProperties(), {
                maxResolution: defaultResolutions[0]
            }));
            mapOrGroup.setView(view);
        }
        if ("center" in glStyle && !view.getCenter()) view.setCenter((0, _projJs.fromLonLat)(glStyle.center));
        if ("zoom" in glStyle && view.getZoom() === undefined) view.setResolution(defaultResolutions[0] / Math.pow(2, glStyle.zoom));
        if (!view.getCenter() || view.getZoom() === undefined) view.fit(view.getProjection().getExtent(), {
            nearest: true,
            size: mapOrGroup.getSize()
        });
    }
    var glLayers = glStyle.layers;
    var layerIds = [];
    var layer, glSource, glSourceId, id;
    var loop = function(i, ii) {
        var glLayer = glLayers[i];
        var type = glLayer.type;
        if (type == "heatmap") //FIXME Unsupported layer type
        throw new Error(type + " layers are not supported");
        else if (type == "background") setBackground(mapOrGroup, glLayer, options);
        else {
            id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
            // this technique assumes gl layers will be in a particular order
            if (id != glSourceId) {
                if (layerIds.length) {
                    promises.push(finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options));
                    layerIds = [];
                }
                glSource = glStyle.sources[id];
                var functionCache = {};
                if (glSource.type == "vector") layer = setupVectorLayer(glSource, styleUrl, options);
                else if (glSource.type == "raster") {
                    layer = setupRasterLayer(glSource, styleUrl, options);
                    layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== "none" : true);
                    layer.on("prerender", prerenderRasterLayer(glLayer, layer, functionCache));
                } else if (glSource.type == "geojson") layer = setupGeoJSONLayer(glSource, styleUrl, options);
                else if (glSource.type == "raster-dem" && glLayer.type == "hillshade") {
                    var hillshadeLayer = setupHillshadeLayer(glSource, styleUrl, options);
                    layer = hillshadeLayer;
                    hillshadeLayer.getSource().on("beforeoperations", function(event) {
                        var data = event.data;
                        data.resolution = event.resolution;
                        var zoom = getZoomForResolution(event.resolution, options.resolutions || defaultResolutions);
                        data.vert = 5 * getValue(glLayer, "paint", "hillshade-exaggeration", zoom, emptyObj, functionCache);
                        data.sunAz = getValue(glLayer, "paint", "hillshade-illumination-direction", zoom, emptyObj, functionCache);
                        data.sunEl = 35;
                        data.opacity = 0.15;
                    });
                    layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== "none" : true);
                }
                glSourceId = id;
                if (layer) layer.set("mapbox-source", glSourceId);
            }
            layerIds.push(glLayer.id);
        }
    };
    for(var i = 0, ii = glLayers.length; i < ii; ++i)loop(i);
    promises.push(finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options));
    mapOrGroup.set("mapbox-style", glStyle);
    return Promise.all(promises);
}
/**
 * Loads and applies a Mapbox Style object into an OpenLayers Map or LayerGroup.
 * This includes the map background, the layers, and for Map instances that did not
 * have a View defined yet also the center and the zoom.
 *
 * **Example:**
 * ```js
 * import apply from 'ol-mapbox-style';
 *
 * apply('map', 'mapbox://styles/mapbox/bright-v9', {accessToken: 'YOUR_MAPBOX_TOKEN'});
 * ```
 *
 * The center and zoom will only be set if present in the Mapbox Style document,
 * and if not already set on the OpenLayers map.
 *
 * Layers will be added to the OpenLayers map, without affecting any layers that
 * might already be set on the map.
 *
 * Layers added by `apply()` will have two additional properties:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * This function sets an additional `mapbox-style` property on the OpenLayers
 * Map or LayerGroup instance, which holds the Mapbox Style object.
 *
 * @param {Map|HTMLElement|string|LayerGroup} mapOrGroup Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map, or a layer group. If layer group, styles
 * releated to the map and view will be ignored.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url is the `styleUrl`
 * shown in Mapbox Studio's "share" panel. In addition, the `accessToken` option
 * (see below) must be set.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @param {Options} options Options.
 * @return {Promise<Map|LayerGroup>} A promise that resolves after all layers have been added to
 * the OpenLayers Map instance or LayerGroup, their sources set, and their styles applied. The
 * `resolve` callback will be called with the OpenLayers Map instance or LayerGroup as
 * argument.
 */ function apply(mapOrGroup, style, options) {
    if (options === void 0) options = {};
    var promise;
    if (typeof mapOrGroup === "string" || mapOrGroup instanceof HTMLElement) mapOrGroup = new (0, _mapJsDefault.default)({
        target: mapOrGroup
    });
    if (typeof style === "string") {
        var styleUrl = style.startsWith("data:") ? location.href : normalizeStyleUrl(style, options.accessToken);
        options = completeOptions(styleUrl, options);
        promise = new Promise(function(resolve, reject) {
            getGlStyle(style, options).then(function(glStyle) {
                processStyle(glStyle, mapOrGroup, styleUrl, options).then(function() {
                    resolve(mapOrGroup);
                }).catch(reject);
            }).catch(function(err) {
                reject(new Error("Could not load " + style + ": " + err.message));
            });
        });
    } else promise = new Promise(function(resolve, reject) {
        processStyle(style, mapOrGroup, !options.styleUrl || options.styleUrl.startsWith("data:") ? location.href : normalizeStyleUrl(options.styleUrl, options.accessToken), options).then(function() {
            resolve(mapOrGroup);
        }).catch(reject);
    });
    return promise;
}
/**
 * If layerIds is not empty, applies the style specified in glStyle to the layer,
 * and adds the layer to the map.
 *
 * The layer may not yet have a source when the function is called.  If so, the style
 * is applied to the layer via a once listener on the 'change:source' event.
 *
 * @param {Layer} layer An OpenLayers layer instance.
 * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.
 * @param {Object} glStyle Style as a JSON object.
 * @param {string|undefined} styleUrl The original style URL. Only required
 * when a relative path is used with the `"sprite"` property of the style.
 * @param {Map|LayerGroup} mapOrGroup OpenLayers Map.
 * @param {Options} options Options.
 * @return {Promise} Returns a promise that resolves after the source has
 * been set on the specified layer, and the style has been applied.
 * @private
 */ function finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options) {
    if (options === void 0) options = {};
    var minZoom = 24;
    var maxZoom = 0;
    var glLayers = glStyle.layers;
    for(var i = 0, ii = glLayers.length; i < ii; ++i){
        var glLayer = glLayers[i];
        if (layerIds.indexOf(glLayer.id) !== -1) {
            minZoom = Math.min("minzoom" in glLayer ? glLayer.minzoom : 0, minZoom);
            maxZoom = Math.max("maxzoom" in glLayer ? glLayer.maxzoom : 24, maxZoom);
        }
    }
    return new Promise(function(resolve, reject) {
        var setStyle = function() {
            var source = layer.getSource();
            if (!source || source.getState() === "error") {
                reject(new Error("Error accessing data for source " + layer.get("mapbox-source")));
                return;
            }
            if ("getTileGrid" in source) {
                var tileGrid = /** @type {import("ol/source/Tile.js").default|import("ol/source/VectorTile.js").default} */ source.getTileGrid();
                if (tileGrid) {
                    var sourceMinZoom = tileGrid.getMinZoom();
                    if (minZoom > 0 || sourceMinZoom > 0) layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);
                    if (maxZoom < 24) layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);
                }
            } else if (minZoom > 0) layer.setMaxResolution(defaultResolutions[minZoom] + 1e-9);
            if (source instanceof (0, _vectorJsDefault1.default) || source instanceof (0, _vectorTileJsDefault1.default)) applyStyle(layer, glStyle, layerIds, Object.assign({
                styleUrl: styleUrl
            }, options)).then(function() {
                layer.setVisible(true);
                resolve();
            }).catch(reject);
            else resolve();
        };
        layer.set("mapbox-layers", layerIds);
        var layers = mapOrGroup.getLayers();
        if (layers.getArray().indexOf(layer) === -1) layers.push(layer);
        if (layer.getSource()) setStyle();
        else layer.once("change:source", setStyle);
    });
}
/**
 * Get the OpenLayers layer instance that contains the provided Mapbox Style
 * `layer`. Note that multiple Mapbox Style layers are combined in a single
 * OpenLayers layer instance when they use the same Mapbox Style `source`.
 * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.
 * @param {string} layerId Mapbox Style layer id.
 * @return {Layer} OpenLayers layer instance.
 */ function getLayer(map, layerId) {
    var layers = map.getLayers().getArray();
    for(var i = 0, ii = layers.length; i < ii; ++i){
        var mapboxLayers = layers[i].get("mapbox-layers");
        if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) return layers[i];
    }
}
/**
 * Get the OpenLayers layer instances for the provided Mapbox Style `source`.
 * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.
 * @param {string} sourceId Mapbox Style source id.
 * @return {Array<Layer>} OpenLayers layer instances.
 */ function getLayers(map, sourceId) {
    var result = [];
    var layers = map.getLayers().getArray();
    for(var i = 0, ii = layers.length; i < ii; ++i)if (layers[i].get("mapbox-source") === sourceId) result.push(layers[i]);
    return result;
}
/**
 * Get the OpenLayers source instance for the provided Mapbox Style `source`.
 * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.
 * @param {string} sourceId Mapbox Style source id.
 * @return {Source} OpenLayers source instance.
 */ function getSource(map, sourceId) {
    var layers = map.getLayers().getArray();
    for(var i = 0, ii = layers.length; i < ii; ++i){
        var source = /** @type {Layer} */ layers[i].getSource();
        if (layers[i].get("mapbox-source") === sourceId) return source;
    }
}
/**
 * Sets or removes a feature state. The feature state is taken into account for styling,
 * just like the feature's properties, and can be used e.g. to conditionally render selected
 * features differently.
 *
 * The feature state will be stored on the OpenLayers layer matching the feature identifier, in the
 * `mapbox-featurestate` property.
 * @param {Map|VectorLayer|VectorTileLayer} mapOrLayer OpenLayers Map or layer to set the feature
 * state on.
 * @param {FeatureIdentifier} feature Feature identifier.
 * @param {Object|null} state Feature state. Set to `null` to remove the feature state.
 */ function setFeatureState(mapOrLayer, feature, state) {
    var layers = "getLayers" in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [
        mapOrLayer
    ];
    for(var i = 0, ii = layers.length; i < ii; ++i){
        var featureState = layers[i].get("mapbox-featurestate");
        if (featureState) {
            if (state) featureState[feature.id] = state;
            else delete featureState[feature.id];
            layers[i].changed();
        } else throw new Error('Map or layer for source "' + feature.source + '" not found.');
    }
}
/**
 * Sets or removes a feature state. The feature state is taken into account for styling,
 * just like the feature's properties, and can be used e.g. to conditionally render selected
 * features differently.
 * @param {Map|VectorLayer|VectorTileLayer} mapOrLayer Map or layer to set the feature state on.
 * @param {FeatureIdentifier} feature Feature identifier.
 * @return {Object|null} Feature state or `null` when no feature state is set for the given
 * feature identifier.
 */ function getFeatureState(mapOrLayer, feature) {
    var layers = "getLayers" in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [
        mapOrLayer
    ];
    for(var i = 0, ii = layers.length; i < ii; ++i){
        var featureState = layers[i].get("mapbox-featurestate");
        if (featureState && featureState[feature.id]) return featureState[feature.id];
    }
    return null;
}

},{"ol/style/Circle.js":"cSS3Y","ol/style/Fill.js":"4fB56","ol/style/Icon.js":"dJiIs","ol/render/Feature.js":"3Oc3i","ol/style/Stroke.js":"5Cq04","ol/style/Style.js":"fW7vC","ol/style/Text.js":"dwGM6","ol/render/canvas.js":"e85iQ","ol/tileurlfunction.js":"gOwFC","ol/format/GeoJSON.js":"1bsdX","ol/layer/Image.js":"4sfDX","ol/format/MVT.js":"jelpD","ol/Map.js":"14YFC","ol/source/Raster.js":"aRX8V","ol/tilegrid/TileGrid.js":"cZOJJ","ol/source/TileJSON.js":"g0paj","ol/layer/Tile.js":"3ytzs","ol/layer/Vector.js":"iTrAy","ol/source/Vector.js":"9w7Fr","ol/layer/VectorTile.js":"6rnkA","ol/source/VectorTile.js":"4Tarl","ol/View.js":"8xbkS","ol/loadingstrategy.js":"i1BBH","ol/tilegrid.js":"1Yr4i","ol/proj.js":"SznqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cSS3Y":[function(require,module,exports) {
/**
 * @module ol/style/Circle
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regularShapeJs = require("./RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode
 */ /**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */ class CircleStyle extends (0, _regularShapeJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {
            radius: 5
        };
        super({
            points: Infinity,
            fill: options.fill,
            radius: options.radius,
            stroke: options.stroke,
            scale: options.scale !== undefined ? options.scale : 1,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            declutterMode: options.declutterMode
        });
    }
    /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        const style = new CircleStyle({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            radius: this.getRadius(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
    }
    /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */ setRadius(radius) {
        this.radius_ = radius;
        this.render();
    }
}
exports.default = CircleStyle;

},{"./RegularShape.js":"44xDg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44xDg":[function(require,module,exports) {
/**
 * @module ol/style/RegularShape
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _colorlikeJs = require("../colorlike.js");
var _domJs = require("../dom.js");
var _canvasJs = require("../render/canvas.js");
/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */ /**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */ /**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */ class RegularShape extends (0, _imageJsDefault.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        /**
     * @type {boolean}
     */ const rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        super({
            opacity: 1,
            rotateWithView: rotateWithView,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            scale: options.scale !== undefined ? options.scale : 1,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            declutterMode: options.declutterMode
        });
        /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */ this.canvas_ = undefined;
        /**
     * @private
     * @type {HTMLCanvasElement}
     */ this.hitDetectionCanvas_ = null;
        /**
     * @private
     * @type {import("./Fill.js").default}
     */ this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
     * @private
     * @type {Array<number>}
     */ this.origin_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {number}
     */ this.points_ = options.points;
        /**
     * @protected
     * @type {number}
     */ this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
        /**
     * @private
     * @type {number|undefined}
     */ this.radius2_ = options.radius2;
        /**
     * @private
     * @type {number}
     */ this.angle_ = options.angle !== undefined ? options.angle : 0;
        /**
     * @private
     * @type {import("./Stroke.js").default}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.size_ = null;
        /**
     * @private
     * @type {RenderOptions}
     */ this.renderOptions_ = null;
        this.render();
    }
    /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        const style = new RegularShape({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            points: this.getPoints(),
            radius: this.getRadius(),
            radius2: this.getRadius2(),
            angle: this.getAngle(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */ getAnchor() {
        const size = this.size_;
        if (!size) return null;
        const displacement = this.getDisplacement();
        const scale = this.getScaleArray();
        // anchor is scaled by renderer but displacement should not be scaled
        // so divide by scale here
        return [
            size[0] / 2 - displacement[0] / scale[0],
            size[1] / 2 + displacement[1] / scale[1]
        ];
    }
    /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */ getAngle() {
        return this.angle_;
    }
    /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
        this.render();
    }
    /**
   * @return {HTMLCanvasElement} Image element.
   */ getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) this.createHitDetectionCanvas_(this.renderOptions_);
        return this.hitDetectionCanvas_;
    }
    /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */ getImage(pixelRatio) {
        let image = this.canvas_[pixelRatio];
        if (!image) {
            const renderOptions = this.renderOptions_;
            const context = (0, _domJs.createCanvasContext2D)(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
            this.draw_(renderOptions, context, pixelRatio);
            image = context.canvas;
            this.canvas_[pixelRatio] = image;
        }
        return image;
    }
    /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */ getPixelRatio(pixelRatio) {
        return pixelRatio;
    }
    /**
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return this.size_;
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return (0, _imageStateJsDefault.default).LOADED;
    }
    /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */ getOrigin() {
        return this.origin_;
    }
    /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */ getPoints() {
        return this.points_;
    }
    /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */ getRadius() {
        return this.radius_;
    }
    /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */ getRadius2() {
        return this.radius2_;
    }
    /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */ getSize() {
        return this.size_;
    }
    /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {}
    /**
   * Load not yet loaded URI.
   */ load() {}
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {}
    /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */ calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") return strokeWidth;
        // m  | ^
        // i  | |\                  .
        // t >|  #\
        // e  | |\ \              .
        // r      \s\
        //      |  \t\          .                 .
        //          \r\                      .   .
        //      |    \o\      .          .  . . .
        //          e \k\            .  .    . .
        //      |      \e\  .    .  .       . .
        //       d      \ \  .  .          . .
        //      | _ _a_ _\#  .            . .
        //   r1          / `             . .
        //      |                       . .
        //       b     /               . .
        //      |                     . .
        //           / r2            . .
        //      |                        .   .
        //         /                           .   .
        //      |α                                   .   .
        //       /                                         .   .
        //      ° center
        let r1 = this.radius_;
        let r2 = this.radius2_ === undefined ? r1 : this.radius2_;
        if (r1 < r2) {
            const tmp = r1;
            r1 = r2;
            r2 = tmp;
        }
        const points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a = r2 * Math.sin(alpha);
        const b = Math.sqrt(r2 * r2 - a * a);
        const d = r1 - b;
        const e = Math.sqrt(a * a + d * d);
        const miterRatio = e / a;
        if (lineJoin === "miter" && miterRatio <= miterLimit) return miterRatio * strokeWidth;
        // Calculate the distnce from center to the stroke corner where
        // it was cut short because of the miter limit.
        //              l
        //        ----+---- <= distance from center to here is maxr
        //       /####|k ##\
        //      /#####^#####\
        //     /#### /+\# s #\
        //    /### h/+++\# t #\
        //   /### t/+++++\# r #\
        //  /### a/+++++++\# o #\
        // /### p/++ fill +\# k #\
        ///#### /+++++^+++++\# e #\
        //#####/+++++/+\+++++\#####\
        const k = strokeWidth / 2 / miterRatio;
        const l = strokeWidth / 2 * (d / e);
        const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === undefined || lineJoin === "bevel") return bevelAdd * 2;
        // If outer miter is over the miter limit the inner miter may reach through the
        // center and be longer than the bevel, same calculation as above but swap r1 / r2.
        const aa = r1 * Math.sin(alpha);
        const bb = Math.sqrt(r1 * r1 - aa * aa);
        const dd = r2 - bb;
        const ee = Math.sqrt(aa * aa + dd * dd);
        const innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
            const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
            return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
    }
    /**
   * @return {RenderOptions}  The render options
   * @protected
   */ createRenderOptions() {
        let lineJoin = (0, _canvasJs.defaultLineJoin);
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
            strokeStyle = this.stroke_.getColor();
            if (strokeStyle === null) strokeStyle = (0, _canvasJs.defaultStrokeStyle);
            strokeStyle = (0, _colorlikeJs.asColorLike)(strokeStyle);
            strokeWidth = this.stroke_.getWidth();
            if (strokeWidth === undefined) strokeWidth = (0, _canvasJs.defaultLineWidth);
            lineDash = this.stroke_.getLineDash();
            lineDashOffset = this.stroke_.getLineDashOffset();
            lineJoin = this.stroke_.getLineJoin();
            if (lineJoin === undefined) lineJoin = (0, _canvasJs.defaultLineJoin);
            miterLimit = this.stroke_.getMiterLimit();
            if (miterLimit === undefined) miterLimit = (0, _canvasJs.defaultMiterLimit);
        }
        const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add);
        return {
            strokeStyle: strokeStyle,
            strokeWidth: strokeWidth,
            size: size,
            lineDash: lineDash,
            lineDashOffset: lineDashOffset,
            lineJoin: lineJoin,
            miterLimit: miterLimit
        };
    }
    /**
   * @protected
   */ render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.canvas_ = {};
        this.size_ = [
            size,
            size
        ];
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */ draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
            let color = this.fill_.getColor();
            if (color === null) color = (0, _canvasJs.defaultFillStyle);
            context.fillStyle = (0, _colorlikeJs.asColorLike)(color);
            context.fill();
        }
        if (this.stroke_) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */ createHitDetectionCanvas_(renderOptions) {
        if (this.fill_) {
            let color = this.fill_.getColor();
            // determine if fill is transparent (or pattern or gradient)
            let opacity = 0;
            if (typeof color === "string") color = (0, _colorJs.asArray)(color);
            if (color === null) opacity = 1;
            else if (Array.isArray(color)) opacity = color.length === 4 ? color[3] : 1;
            if (opacity === 0) {
                // if a transparent fill style is set, create an extra hit-detection image
                // with a default fill style
                const context = (0, _domJs.createCanvasContext2D)(renderOptions.size, renderOptions.size);
                this.hitDetectionCanvas_ = context.canvas;
                this.drawHitDetectionCanvas_(renderOptions, context);
            }
        }
        if (!this.hitDetectionCanvas_) this.hitDetectionCanvas_ = this.getImage(1);
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */ createPath_(context) {
        let points = this.points_;
        const radius = this.radius_;
        if (points === Infinity) context.arc(0, 0, radius, 0, 2 * Math.PI);
        else {
            const radius2 = this.radius2_ === undefined ? radius : this.radius2_;
            if (this.radius2_ !== undefined) points *= 2;
            const startAngle = this.angle_ - Math.PI / 2;
            const step = 2 * Math.PI / points;
            for(let i = 0; i < points; i++){
                const angle0 = startAngle + i * step;
                const radiusC = i % 2 === 0 ? radius : radius2;
                context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
            }
            context.closePath();
        }
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */ drawHitDetectionCanvas_(renderOptions, context) {
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = (0, _canvasJs.defaultFillStyle);
        context.fill();
        if (this.stroke_) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    }
}
exports.default = RegularShape;

},{"../ImageState.js":"c4jJS","./Image.js":"eyoR9","../color.js":"4tahz","../colorlike.js":"ftcFo","../dom.js":"84QzQ","../render/canvas.js":"e85iQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c4jJS":[function(require,module,exports) {
/**
 * @module ol/ImageState
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"eyoR9":[function(require,module,exports) {
/**
 * @module ol/style/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilJs = require("../util.js");
var _sizeJs = require("../size.js");
/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, 'none */ /**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */ class ImageStyle {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        /**
     * @private
     * @type {number}
     */ this.opacity_ = options.opacity;
        /**
     * @private
     * @type {boolean}
     */ this.rotateWithView_ = options.rotateWithView;
        /**
     * @private
     * @type {number}
     */ this.rotation_ = options.rotation;
        /**
     * @private
     * @type {number|import("../size.js").Size}
     */ this.scale_ = options.scale;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.scaleArray_ = (0, _sizeJs.toSize)(options.scale);
        /**
     * @private
     * @type {Array<number>}
     */ this.displacement_ = options.displacement;
        /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */ this.declutterMode_ = options.declutterMode;
    }
    /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        return new ImageStyle({
            opacity: this.getOpacity(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
    }
    /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */ getOpacity() {
        return this.opacity_;
    }
    /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */ getRotateWithView() {
        return this.rotateWithView_;
    }
    /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */ getRotation() {
        return this.rotation_;
    }
    /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */ getScale() {
        return this.scale_;
    }
    /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */ getScaleArray() {
        return this.scaleArray_;
    }
    /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */ getDisplacement() {
        return this.displacement_;
    }
    /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */ getDeclutterMode() {
        return this.declutterMode_;
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */ getAnchor() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */ getImage(pixelRatio) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */ getHitDetectionImage() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */ getPixelRatio(pixelRatio) {
        return 1;
    }
    /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */ getOrigin() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */ getSize() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */ setDisplacement(displacement) {
        this.displacement_ = displacement;
    }
    /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */ setOpacity(opacity) {
        this.opacity_ = opacity;
    }
    /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */ setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    }
    /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */ setRotation(rotation) {
        this.rotation_ = rotation;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */ setScale(scale) {
        this.scale_ = scale;
        this.scaleArray_ = (0, _sizeJs.toSize)(scale);
    }
    /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {
        (0, _utilJs.abstract)();
    }
    /**
   * Load not yet loaded URI.
   * @abstract
   */ load() {
        (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {
        (0, _utilJs.abstract)();
    }
}
exports.default = ImageStyle;

},{"../util.js":"pLBjQ","../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"pLBjQ":[function(require,module,exports) {
/**
 * @module ol/util
 */ /**
 * @return {never} Any return.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "abstract", ()=>abstract);
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */ parcelHelpers.export(exports, "getUid", ()=>getUid);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
function abstract() {
    throw new Error("Unimplemented abstract method.");
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */ let uidCounter_ = 0;
function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
const VERSION = "7.1.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lKEPe":[function(require,module,exports) {
/**
 * @module ol/size
 */ /**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */ /**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buffer", ()=>buffer);
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */ parcelHelpers.export(exports, "hasArea", ()=>hasArea);
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */ parcelHelpers.export(exports, "toSize", ()=>toSize);
function buffer(size, num, dest) {
    if (dest === undefined) dest = [
        0,
        0
    ];
    dest[0] = size[0] + 2 * num;
    dest[1] = size[1] + 2 * num;
    return dest;
}
function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, dest) {
    if (dest === undefined) dest = [
        0,
        0
    ];
    dest[0] = size[0] * ratio + 0.5 | 0;
    dest[1] = size[1] * ratio + 0.5 | 0;
    return dest;
}
function toSize(size, dest) {
    if (Array.isArray(size)) return size;
    else {
        if (dest === undefined) dest = [
            size,
            size
        ];
        else {
            dest[0] = size;
            dest[1] = size;
        }
        return dest;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4tahz":[function(require,module,exports) {
/**
 * @module ol/color
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */ parcelHelpers.export(exports, "asString", ()=>asString);
parcelHelpers.export(exports, "fromString", ()=>fromString);
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */ parcelHelpers.export(exports, "asArray", ()=>asArray);
/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */ parcelHelpers.export(exports, "normalize", ()=>normalize);
/**
 * @param {Color} color Color.
 * @return {string} String.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */ parcelHelpers.export(exports, "isStringColor", ()=>isStringColor);
var _assertsJs = require("./asserts.js");
var _mathJs = require("./math.js");
/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */ /**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */ const HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */ const NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString(color) {
    if (typeof color === "string") return color;
    else return toString(color);
}
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */ function fromNamed(color) {
    const el = document.createElement("div");
    el.style.color = color;
    if (el.style.color !== "") {
        document.body.appendChild(el);
        const rgb = getComputedStyle(el).color;
        document.body.removeChild(el);
        return rgb;
    } else return "";
}
const fromString = function() {
    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.
    /**
   * @const
   * @type {number}
   */ const MAX_CACHE_SIZE = 1024;
    /**
   * @type {Object<string, Color>}
   */ const cache = {};
    /**
   * @type {number}
   */ let cacheSize = 0;
    return(/**
     * @param {string} s String.
     * @return {Color} Color.
     */ function(s) {
        let color;
        if (cache.hasOwnProperty(s)) color = cache[s];
        else {
            if (cacheSize >= MAX_CACHE_SIZE) {
                let i = 0;
                for(const key in cache)if ((i++ & 3) === 0) {
                    delete cache[key];
                    --cacheSize;
                }
            }
            color = fromStringInternal_(s);
            cache[s] = color;
            ++cacheSize;
        }
        return color;
    });
}();
function asArray(color) {
    if (Array.isArray(color)) return color;
    else return fromString(color);
}
/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */ function fromStringInternal_(s) {
    let r, g, b, a, color;
    if (NAMED_COLOR_RE_.exec(s)) s = fromNamed(s);
    if (HEX_COLOR_RE_.exec(s)) {
        // hex
        const n = s.length - 1; // number of hex digits
        let d; // number of digits per channel
        if (n <= 4) d = 1;
        else d = 2;
        const hasAlpha = n === 4 || n === 8;
        r = parseInt(s.substr(1 + 0 * d, d), 16);
        g = parseInt(s.substr(1 + 1 * d, d), 16);
        b = parseInt(s.substr(1 + 2 * d, d), 16);
        if (hasAlpha) a = parseInt(s.substr(1 + 3 * d, d), 16);
        else a = 255;
        if (d == 1) {
            r = (r << 4) + r;
            g = (g << 4) + g;
            b = (b << 4) + b;
            if (hasAlpha) a = (a << 4) + a;
        }
        color = [
            r,
            g,
            b,
            a / 255
        ];
    } else if (s.startsWith("rgba(")) {
        // rgba()
        color = s.slice(5, -1).split(",").map(Number);
        normalize(color);
    } else if (s.startsWith("rgb(")) {
        // rgb()
        color = s.slice(4, -1).split(",").map(Number);
        color.push(1);
        normalize(color);
    } else (0, _assertsJs.assert)(false, 14); // Invalid color
    return color;
}
function normalize(color) {
    color[0] = (0, _mathJs.clamp)(color[0] + 0.5 | 0, 0, 255);
    color[1] = (0, _mathJs.clamp)(color[1] + 0.5 | 0, 0, 255);
    color[2] = (0, _mathJs.clamp)(color[2] + 0.5 | 0, 0, 255);
    color[3] = (0, _mathJs.clamp)(color[3], 0, 1);
    return color;
}
function toString(color) {
    let r = color[0];
    if (r != (r | 0)) r = r + 0.5 | 0;
    let g = color[1];
    if (g != (g | 0)) g = g + 0.5 | 0;
    let b = color[2];
    if (b != (b | 0)) b = b + 0.5 | 0;
    const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}
function isStringColor(s) {
    if (NAMED_COLOR_RE_.test(s)) s = fromNamed(s);
    return HEX_COLOR_RE_.test(s) || s.startsWith("rgba(") || s.startsWith("rgb(");
}

},{"./asserts.js":"e4TiF","./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4TiF":[function(require,module,exports) {
/**
 * @module ol/asserts
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */ parcelHelpers.export(exports, "assert", ()=>assert);
var _assertionErrorJs = require("./AssertionError.js");
var _assertionErrorJsDefault = parcelHelpers.interopDefault(_assertionErrorJs);
function assert(assertion, errorCode) {
    if (!assertion) throw new (0, _assertionErrorJsDefault.default)(errorCode);
}

},{"./AssertionError.js":"1MBbN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1MBbN":[function(require,module,exports) {
/**
 * @module ol/AssertionError
 */ /** @type {Object<number, string>} */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const messages = {
    1: "The view center is not defined",
    2: "The view resolution is not defined",
    3: "The view rotation is not defined",
    4: "`image` and `src` cannot be provided at the same time",
    5: "`imgSize` must be set when `image` is provided",
    7: "`format` must be set when `url` is set",
    8: "Unknown `serverType` configured",
    9: "`url` must be configured or set using `#setUrl()`",
    10: "The default `geometryFunction` can only handle `Point` geometries",
    11: "`options.featureTypes` must be an Array",
    12: "`options.geometryName` must also be provided when `options.bbox` is set",
    13: "Invalid corner",
    14: "Invalid color",
    15: "Tried to get a value for a key that does not exist in the cache",
    16: "Tried to set a value for a key that is used already",
    17: "`resolutions` must be sorted in descending order",
    18: "Either `origin` or `origins` must be configured, never both",
    19: "Number of `tileSizes` and `resolutions` must be equal",
    20: "Number of `origins` and `resolutions` must be equal",
    22: "Either `tileSize` or `tileSizes` must be configured, never both",
    24: "Invalid extent or geometry provided as `geometry`",
    25: "Cannot fit empty extent provided as `geometry`",
    26: "Features must have an id set",
    27: "Features must have an id set",
    28: '`renderMode` must be `"hybrid"` or `"vector"`',
    30: "The passed `feature` was already added to the source",
    31: "Tried to enqueue an `element` that was already added to the queue",
    32: "Transformation matrix cannot be inverted",
    33: "Invalid units",
    34: "Invalid geometry layout",
    36: "Unknown SRS type",
    37: "Unknown geometry type found",
    38: "`styleMapValue` has an unknown type",
    39: "Unknown geometry type",
    40: "Expected `feature` to have a geometry",
    41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
    42: "Question unknown, the answer is 42",
    43: "Expected `layers` to be an array or a `Collection`",
    47: "Expected `controls` to be an array or an `ol/Collection`",
    48: "Expected `interactions` to be an array or an `ol/Collection`",
    49: "Expected `overlays` to be an array or an `ol/Collection`",
    50: "`options.featureTypes` should be an Array",
    51: "Either `url` or `tileJSON` options must be provided",
    52: "Unknown `serverType` configured",
    53: "Unknown `tierSizeCalculation` configured",
    55: "The {-y} placeholder requires a tile grid with extent",
    56: "mapBrowserEvent must originate from a pointer event",
    57: "At least 2 conditions are required",
    59: "Invalid command found in the PBF",
    60: "Missing or invalid `size`",
    61: "Cannot determine IIIF Image API version from provided image information JSON",
    62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
    64: "Layer opacity must be a number",
    66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
    67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
    68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection"
};
/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */ class AssertionError extends Error {
    /**
   * @param {number} code Error code.
   */ constructor(code){
        const message = messages[code];
        super(message);
        /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @deprecated ol/AssertionError and error codes will be removed in v8.0
     * @api
     */ this.code = code;
        /**
     * @type {string}
     */ this.name = "AssertionError";
        // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
        this.message = message;
    }
}
exports.default = AssertionError;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5jEFr":[function(require,module,exports) {
/**
 * @module ol/math
 */ /**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clamp", ()=>clamp);
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredSegmentDistance", ()=>squaredSegmentDistance);
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance);
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */ parcelHelpers.export(exports, "solveLinearSystem", ()=>solveLinearSystem);
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */ parcelHelpers.export(exports, "toDegrees", ()=>toDegrees);
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */ parcelHelpers.export(exports, "toRadians", ()=>toRadians);
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */ parcelHelpers.export(exports, "modulo", ()=>modulo);
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */ parcelHelpers.export(exports, "lerp", ()=>lerp);
/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */ parcelHelpers.export(exports, "toFixed", ()=>toFixed);
/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */ parcelHelpers.export(exports, "round", ()=>round);
/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */ parcelHelpers.export(exports, "floor", ()=>floor);
/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */ parcelHelpers.export(exports, "ceil", ()=>ceil);
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x1 = x2;
            y1 = y2;
        } else if (t > 0) {
            x1 += dx * t;
            y1 += dy * t;
        }
    }
    return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
    const n = mat.length;
    for(let i = 0; i < n; i++){
        // Find max in the i-th column (ignoring i - 1 first rows)
        let maxRow = i;
        let maxEl = Math.abs(mat[i][i]);
        for(let r = i + 1; r < n; r++){
            const absValue = Math.abs(mat[r][i]);
            if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
            }
        }
        if (maxEl === 0) return null; // matrix is singular
        // Swap max row with i-th (current) row
        const tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;
        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for(let j = i + 1; j < n; j++){
            const coef = -mat[j][i] / mat[i][i];
            for(let k = i; k < n + 1; k++)if (i == k) mat[j][k] = 0;
            else mat[j][k] += coef * mat[i][k];
        }
    }
    // Solve Ax=b for upper triangular matrix A (mat)
    const x = new Array(n);
    for(let l = n - 1; l >= 0; l--){
        x[l] = mat[l][n] / mat[l][l];
        for(let m = l - 1; m >= 0; m--)mat[m][n] -= mat[m][l] * x[l];
    }
    return x;
}
function toDegrees(angleInRadians) {
    return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
    const r = a % b;
    return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
    return a + x * (b - a);
}
function toFixed(n, decimals) {
    const factor = Math.pow(10, decimals);
    return Math.round(n * factor) / factor;
}
function round(n, decimals) {
    return Math.round(toFixed(n, decimals));
}
function floor(n, decimals) {
    return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
    return Math.ceil(toFixed(n, decimals));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftcFo":[function(require,module,exports) {
/**
 * @module ol/colorlike
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */ /**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */ parcelHelpers.export(exports, "asColorLike", ()=>asColorLike);
var _colorJs = require("./color.js");
function asColorLike(color) {
    if (Array.isArray(color)) return (0, _colorJs.toString)(color);
    else return color;
}

},{"./color.js":"4tahz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"84QzQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/dom
 */ //FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */ parcelHelpers.export(exports, "createCanvasContext2D", ()=>createCanvasContext2D);
/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */ parcelHelpers.export(exports, "releaseCanvas", ()=>releaseCanvas);
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */ parcelHelpers.export(exports, "outerWidth", ()=>outerWidth);
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */ parcelHelpers.export(exports, "outerHeight", ()=>outerHeight);
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */ parcelHelpers.export(exports, "replaceNode", ()=>replaceNode);
/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */ parcelHelpers.export(exports, "removeNode", ()=>removeNode);
/**
 * @param {Node} node The node to remove the children from.
 */ parcelHelpers.export(exports, "removeChildren", ()=>removeChildren);
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */ parcelHelpers.export(exports, "replaceChildren", ()=>replaceChildren);
var _hasJs = require("./has.js");
function createCanvasContext2D(width, height, canvasPool, settings) {
    /** @type {HTMLCanvasElement|OffscreenCanvas} */ let canvas;
    if (canvasPool && canvasPool.length) canvas = canvasPool.shift();
    else if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) canvas = new OffscreenCanvas(width || 300, height || 300);
    else canvas = document.createElement("canvas");
    if (width) canvas.width = width;
    if (height) canvas.height = height;
    //FIXME Allow OffscreenCanvasRenderingContext2D as return type
    return /** @type {CanvasRenderingContext2D} */ canvas.getContext("2d", settings);
}
function releaseCanvas(context) {
    const canvas = context.canvas;
    canvas.width = 1;
    canvas.height = 1;
    context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
    return width;
}
function outerHeight(element) {
    let height = element.offsetHeight;
    const style = getComputedStyle(element);
    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    return height;
}
function replaceNode(newNode, oldNode) {
    const parent = oldNode.parentNode;
    if (parent) parent.replaceChild(newNode, oldNode);
}
function removeNode(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
    while(node.lastChild)node.removeChild(node.lastChild);
}
function replaceChildren(node, children) {
    const oldChildren = node.childNodes;
    for(let i = 0;; ++i){
        const oldChild = oldChildren[i];
        const newChild = children[i];
        // check if our work is done
        if (!oldChild && !newChild) break;
        // check if children match
        if (oldChild === newChild) continue;
        // check if a new child needs to be added
        if (!oldChild) {
            node.appendChild(newChild);
            continue;
        }
        // check if an old child needs to be removed
        if (!newChild) {
            node.removeChild(oldChild);
            --i;
            continue;
        }
        // reorder
        node.insertBefore(newChild, oldChild);
    }
}

},{"./has.js":"6BDNi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6BDNi":[function(require,module,exports) {
/**
 * @module ol/has
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FIREFOX", ()=>FIREFOX);
parcelHelpers.export(exports, "SAFARI", ()=>SAFARI);
parcelHelpers.export(exports, "SAFARI_BUG_237906", ()=>SAFARI_BUG_237906);
parcelHelpers.export(exports, "WEBKIT", ()=>WEBKIT);
parcelHelpers.export(exports, "MAC", ()=>MAC);
parcelHelpers.export(exports, "DEVICE_PIXEL_RATIO", ()=>DEVICE_PIXEL_RATIO);
parcelHelpers.export(exports, "WORKER_OFFSCREEN_CANVAS", ()=>WORKER_OFFSCREEN_CANVAS);
parcelHelpers.export(exports, "IMAGE_DECODE", ()=>IMAGE_DECODE);
parcelHelpers.export(exports, "PASSIVE_EVENT_LISTENERS", ()=>PASSIVE_EVENT_LISTENERS);
const ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
const FIREFOX = ua.includes("firefox");
const SAFARI = ua.includes("safari") && !ua.includes("chrom");
const SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
const WEBKIT = ua.includes("webkit") && !ua.includes("edge");
const MAC = ua.includes("macintosh");
const DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
const WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope; //eslint-disable-line
const IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
const PASSIVE_EVENT_LISTENERS = function() {
    let passive = false;
    try {
        const options = Object.defineProperty({}, "passive", {
            get: function() {
                passive = true;
            }
        });
        window.addEventListener("_", null, options);
        window.removeEventListener("_", null, options);
    } catch (error) {
    // passive not supported
    }
    return passive;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e85iQ":[function(require,module,exports) {
/**
 * @module ol/render/canvas
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultFont", ()=>defaultFont);
parcelHelpers.export(exports, "defaultFillStyle", ()=>defaultFillStyle);
parcelHelpers.export(exports, "defaultLineCap", ()=>defaultLineCap);
parcelHelpers.export(exports, "defaultLineDash", ()=>defaultLineDash);
parcelHelpers.export(exports, "defaultLineDashOffset", ()=>defaultLineDashOffset);
parcelHelpers.export(exports, "defaultLineJoin", ()=>defaultLineJoin);
parcelHelpers.export(exports, "defaultMiterLimit", ()=>defaultMiterLimit);
parcelHelpers.export(exports, "defaultStrokeStyle", ()=>defaultStrokeStyle);
parcelHelpers.export(exports, "defaultTextAlign", ()=>defaultTextAlign);
parcelHelpers.export(exports, "defaultTextBaseline", ()=>defaultTextBaseline);
parcelHelpers.export(exports, "defaultPadding", ()=>defaultPadding);
parcelHelpers.export(exports, "defaultLineWidth", ()=>defaultLineWidth);
parcelHelpers.export(exports, "checkedFonts", ()=>checkedFonts);
parcelHelpers.export(exports, "textHeights", ()=>textHeights);
parcelHelpers.export(exports, "registerFont", ()=>registerFont);
parcelHelpers.export(exports, "measureTextHeight", ()=>measureTextHeight);
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */ parcelHelpers.export(exports, "measureTextWidth", ()=>measureTextWidth);
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */ parcelHelpers.export(exports, "measureAndCacheTextWidth", ()=>measureAndCacheTextWidth);
/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */ parcelHelpers.export(exports, "getTextDimensions", ()=>getTextDimensions);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */ parcelHelpers.export(exports, "rotateAtOffset", ()=>rotateAtOffset);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */ parcelHelpers.export(exports, "drawImageOrLabel", ()=>drawImageOrLabel);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _hasJs = require("../has.js");
var _objJs = require("../obj.js");
var _domJs = require("../dom.js");
var _cssJs = require("../css.js");
const defaultFont = "10px sans-serif";
const defaultFillStyle = "#000";
const defaultLineCap = "round";
const defaultLineDash = [];
const defaultLineDashOffset = 0;
const defaultLineJoin = "round";
const defaultMiterLimit = 10;
const defaultStrokeStyle = "#000";
const defaultTextAlign = "center";
const defaultTextBaseline = "middle";
const defaultPadding = [
    0,
    0,
    0,
    0
];
const defaultLineWidth = 1;
const checkedFonts = new (0, _objectJsDefault.default)();
/**
 * @type {CanvasRenderingContext2D}
 */ let measureContext = null;
/**
 * @type {string}
 */ let measureFont;
const textHeights = {};
const registerFont = function() {
    const retries = 100;
    const size = "32px ";
    const referenceFonts = [
        "monospace",
        "serif"
    ];
    const len = referenceFonts.length;
    const text = "wmytzilWMYTZIL@#/&?$%10";
    let interval, referenceWidth;
    /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */ function isAvailable(fontStyle, fontWeight, fontFamily) {
        let available = true;
        for(let i = 0; i < len; ++i){
            const referenceFont = referenceFonts[i];
            referenceWidth = measureTextWidth(fontStyle + " " + fontWeight + " " + size + referenceFont, text);
            if (fontFamily != referenceFont) {
                const width = measureTextWidth(fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont, text);
                // If width and referenceWidth are the same, then the fallback was used
                // instead of the font we wanted, so the font is not available.
                available = available && width != referenceWidth;
            }
        }
        if (available) return true;
        return false;
    }
    function check() {
        let done = true;
        const fonts = checkedFonts.getKeys();
        for(let i = 0, ii = fonts.length; i < ii; ++i){
            const font = fonts[i];
            if (checkedFonts.get(font) < retries) {
                if (isAvailable.apply(this, font.split("\n"))) {
                    (0, _objJs.clear)(textHeights);
                    // Make sure that loaded fonts are picked up by Safari
                    measureContext = null;
                    measureFont = undefined;
                    checkedFonts.set(font, retries);
                } else {
                    checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                    done = false;
                }
            }
        }
        if (done) {
            clearInterval(interval);
            interval = undefined;
        }
    }
    return function(fontSpec) {
        const font = (0, _cssJs.getFontParameters)(fontSpec);
        if (!font) return;
        const families = font.families;
        for(let i = 0, ii = families.length; i < ii; ++i){
            const family = families[i];
            const key = font.style + "\n" + font.weight + "\n" + family;
            if (checkedFonts.get(key) === undefined) {
                checkedFonts.set(key, retries, true);
                if (!isAvailable(font.style, font.weight, family)) {
                    checkedFonts.set(key, 0, true);
                    if (interval === undefined) interval = setInterval(check, 32);
                }
            }
        }
    };
}();
const measureTextHeight = function() {
    /**
   * @type {HTMLDivElement}
   */ let measureElement;
    return function(fontSpec) {
        let height = textHeights[fontSpec];
        if (height == undefined) {
            if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) {
                const font = (0, _cssJs.getFontParameters)(fontSpec);
                const metrics = measureText(fontSpec, "Žg");
                const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
                height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
            } else {
                if (!measureElement) {
                    measureElement = document.createElement("div");
                    measureElement.innerHTML = "M";
                    measureElement.style.minHeight = "0";
                    measureElement.style.maxHeight = "none";
                    measureElement.style.height = "auto";
                    measureElement.style.padding = "0";
                    measureElement.style.border = "none";
                    measureElement.style.position = "absolute";
                    measureElement.style.display = "block";
                    measureElement.style.left = "-99999px";
                }
                measureElement.style.font = fontSpec;
                document.body.appendChild(measureElement);
                height = measureElement.offsetHeight;
                document.body.removeChild(measureElement);
            }
            textHeights[fontSpec] = height;
        }
        return height;
    };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */ function measureText(font, text) {
    if (!measureContext) measureContext = (0, _domJs.createCanvasContext2D)(1, 1);
    if (font != measureFont) {
        measureContext.font = font;
        measureFont = measureContext.font;
    }
    return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
    return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache) {
    if (text in cache) return cache[text];
    const width = text.split("\n").reduce((prev, curr)=>Math.max(prev, measureTextWidth(font, curr)), 0);
    cache[text] = width;
    return width;
}
function getTextDimensions(baseStyle, chunks) {
    const widths = [];
    const heights = [];
    const lineWidths = [];
    let width = 0;
    let lineWidth = 0;
    let height = 0;
    let lineHeight = 0;
    for(let i = 0, ii = chunks.length; i <= ii; i += 2){
        const text = chunks[i];
        if (text === "\n" || i === ii) {
            width = Math.max(width, lineWidth);
            lineWidths.push(lineWidth);
            lineWidth = 0;
            height += lineHeight;
            continue;
        }
        const font = chunks[i + 1] || baseStyle.font;
        const currentWidth = measureTextWidth(font, text);
        widths.push(currentWidth);
        lineWidth += currentWidth;
        const currentHeight = measureTextHeight(font);
        heights.push(currentHeight);
        lineHeight = Math.max(lineHeight, currentHeight);
    }
    return {
        width,
        height,
        widths,
        heights,
        lineWidths
    };
}
function rotateAtOffset(context, rotation, offsetX, offsetY) {
    if (rotation !== 0) {
        context.translate(offsetX, offsetY);
        context.rotate(rotation);
        context.translate(-offsetX, -offsetY);
    }
}
function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
    context.save();
    if (opacity !== 1) context.globalAlpha *= opacity;
    if (transform) context.setTransform.apply(context, transform);
    if (/** @type {*} */ labelOrImage.contextInstructions) {
        // label
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        executeLabelInstructions(/** @type {Label} */ labelOrImage, context);
    } else if (scale[0] < 0 || scale[1] < 0) {
        // flipped image
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        context.drawImage(/** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ labelOrImage, originX, originY, w, h, 0, 0, w, h);
    } else // if image not flipped translate and scale can be avoided
    context.drawImage(/** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
    context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */ function executeLabelInstructions(label, context) {
    const contextInstructions = label.contextInstructions;
    for(let i = 0, ii = contextInstructions.length; i < ii; i += 2)if (Array.isArray(contextInstructions[i + 1])) context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    else context[contextInstructions[i]] = contextInstructions[i + 1];
}

},{"../Object.js":"1zG8z","../has.js":"6BDNi","../obj.js":"3ssAG","../dom.js":"84QzQ","../css.js":"lDlNi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1zG8z":[function(require,module,exports) {
/**
 * @module ol/Object
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */ parcelHelpers.export(exports, "ObjectEvent", ()=>ObjectEvent);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _objectEventTypeJs = require("./ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _observableJs = require("./Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _utilJs = require("./util.js");
var _objJs = require("./obj.js");
class ObjectEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */ constructor(type, key, oldValue){
        super(type);
        /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */ this.key = key;
        /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */ this.oldValue = oldValue;
    }
}
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */ class BaseObject extends (0, _observableJsDefault.default) {
    /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */ constructor(values){
        super();
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ObjectOnSignature<void>}
     */ this.un;
        // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
        // the same as the order in which they were created.  This also helps to
        // ensure that object properties are always added in the same order, which
        // helps many JavaScript engines generate faster code.
        (0, _utilJs.getUid)(this);
        /**
     * @private
     * @type {Object<string, *>}
     */ this.values_ = null;
        if (values !== undefined) this.setProperties(values);
    }
    /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */ get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) value = this.values_[key];
        return value;
    }
    /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */ getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
    }
    /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */ getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
   * @return {boolean} The object has properties.
   */ hasProperties() {
        return !!this.values_;
    }
    /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */ notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        eventType = (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE;
        if (this.hasListener(eventType)) this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
    }
    /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) values[key] = value;
        else {
            const oldValue = values[key];
            values[key] = value;
            if (oldValue !== value) this.notify(key, oldValue);
        }
    }
    /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ setProperties(values, silent) {
        for(const key in values)this.set(key, values[key], silent);
    }
    /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */ applyProperties(source) {
        if (!source.values_) return;
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
    }
    /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */ unset(key, silent) {
        if (this.values_ && key in this.values_) {
            const oldValue = this.values_[key];
            delete this.values_[key];
            if ((0, _objJs.isEmpty)(this.values_)) this.values_ = null;
            if (!silent) this.notify(key, oldValue);
        }
    }
}
exports.default = BaseObject;

},{"./events/Event.js":"hwXQP","./ObjectEventType.js":"f2U6i","./Observable.js":"cQ2uI","./util.js":"pLBjQ","./obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwXQP":[function(require,module,exports) {
/**
 * @module ol/events/Event
 */ /**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "stopPropagation", ()=>stopPropagation);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "preventDefault", ()=>preventDefault);
class BaseEvent {
    /**
   * @param {string} type Type.
   */ constructor(type){
        /**
     * @type {boolean}
     */ this.propagationStopped;
        /**
     * @type {boolean}
     */ this.defaultPrevented;
        /**
     * The event type.
     * @type {string}
     * @api
     */ this.type = type;
        /**
     * The event target.
     * @type {Object}
     * @api
     */ this.target = null;
    }
    /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */ preventDefault() {
        this.defaultPrevented = true;
    }
    /**
   * Stop event propagation.
   * @api
   */ stopPropagation() {
        this.propagationStopped = true;
    }
}
function stopPropagation(evt) {
    evt.stopPropagation();
}
function preventDefault(evt) {
    evt.preventDefault();
}
exports.default = BaseEvent;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f2U6i":[function(require,module,exports) {
/**
 * @module ol/ObjectEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */ PROPERTYCHANGE: "propertychange"
}; /**
 * @typedef {'propertychange'} Types
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQ2uI":[function(require,module,exports) {
/**
 * @module ol/Observable
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */ parcelHelpers.export(exports, "unByKey", ()=>unByKey);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _eventsJs = require("./events.js");
/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */ /***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */ /**
 * @typedef {'change'|'error'} EventTypes
 */ /***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */ class Observable extends (0, _targetJsDefault.default) {
    constructor(){
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */ this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */ this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */ this.unInternal;
        /**
     * @private
     * @type {number}
     */ this.revision_ = 0;
    }
    /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */ changed() {
        ++this.revision_;
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */ getRevision() {
        return this.revision_;
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onInternal(type, listener) {
        if (Array.isArray(type)) {
            const len = type.length;
            const keys = new Array(len);
            for(let i = 0; i < len; ++i)keys[i] = (0, _eventsJs.listen)(this, type[i], listener);
            return keys;
        } else return (0, _eventsJs.listen)(this, /** @type {string} */ type, listener);
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
            const len = type.length;
            key = new Array(len);
            for(let i = 0; i < len; ++i)key[i] = (0, _eventsJs.listenOnce)(this, type[i], listener);
        } else key = (0, _eventsJs.listenOnce)(this, /** @type {string} */ type, listener);
        /** @type {Object} */ listener.ol_key = key;
        return key;
    }
    /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */ unInternal(type, listener) {
        const key = /** @type {Object} */ listener.ol_key;
        if (key) unByKey(key);
        else if (Array.isArray(type)) for(let i = 0, ii = type.length; i < ii; ++i)this.removeEventListener(type[i], listener);
        else this.removeEventListener(type, listener);
    }
}
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */ Observable.prototype.un;
function unByKey(key) {
    if (Array.isArray(key)) for(let i = 0, ii = key.length; i < ii; ++i)(0, _eventsJs.unlistenByKey)(key[i]);
    else (0, _eventsJs.unlistenByKey)(/** @type {import("./events.js").EventsKey} */ key);
}
exports.default = Observable;

},{"./events/Target.js":"7T5Yi","./events/EventType.js":"hrQJ6","./events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7T5Yi":[function(require,module,exports) {
/**
 * @module ol/events/Target
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _eventJs = require("./Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _functionsJs = require("../functions.js");
var _objJs = require("../obj.js");
/**
 * @typedef {EventTarget|Target} EventTargetLike
 */ /**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */ class Target extends (0, _disposableJsDefault.default) {
    /**
   * @param {*} [target] Default event target for dispatched events.
   */ constructor(target){
        super();
        /**
     * @private
     * @type {*}
     */ this.eventTarget_ = target;
        /**
     * @private
     * @type {Object<string, number>}
     */ this.pendingRemovals_ = null;
        /**
     * @private
     * @type {Object<string, number>}
     */ this.dispatching_ = null;
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>}
     */ this.listeners_ = null;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ addEventListener(type, listener) {
        if (!type || !listener) return;
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) listenersForType.push(listener);
    }
    /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */ dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) return;
        const evt = isString ? new (0, _eventJsDefault.default)(event) : /** @type {Event} */ event;
        if (!evt.target) evt.target = this.eventTarget_ || this;
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
            dispatching[type] = 0;
            pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for(let i = 0, ii = listeners.length; i < ii; ++i){
            if ("handleEvent" in listeners[i]) propagate = /** @type {import("../events.js").ListenerObject} */ listeners[i].handleEvent(evt);
            else propagate = /** @type {import("../events.js").ListenerFunction} */ listeners[i].call(this, evt);
            if (propagate === false || evt.propagationStopped) {
                propagate = false;
                break;
            }
        }
        if (--dispatching[type] === 0) {
            let pr = pendingRemovals[type];
            delete pendingRemovals[type];
            while(pr--)this.removeEventListener(type, (0, _functionsJs.VOID));
            delete dispatching[type];
        }
        return propagate;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.listeners_ && (0, _objJs.clear)(this.listeners_);
    }
    /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */ getListeners(type) {
        return this.listeners_ && this.listeners_[type] || undefined;
    }
    /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */ hasListener(type) {
        if (!this.listeners_) return false;
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ removeEventListener(type, listener) {
        const listeners = this.listeners_ && this.listeners_[type];
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
                if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                    // make listener a no-op, and remove later in #dispatchEvent()
                    listeners[index] = (0, _functionsJs.VOID);
                    ++this.pendingRemovals_[type];
                } else {
                    listeners.splice(index, 1);
                    if (listeners.length === 0) delete this.listeners_[type];
                }
            }
        }
    }
}
exports.default = Target;

},{"../Disposable.js":"c0oTM","./Event.js":"hwXQP","../functions.js":"iqv8I","../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c0oTM":[function(require,module,exports) {
/**
 * @module ol/Disposable
 */ /**
 * @classdesc
 * Objects that need to clean up after themselves.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Disposable {
    constructor(){
        /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */ this.disposed = false;
    }
    /**
   * Clean up.
   */ dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this.disposeInternal();
        }
    }
    /**
   * Extension point for disposable objects.
   * @protected
   */ disposeInternal() {}
}
exports.default = Disposable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iqv8I":[function(require,module,exports) {
/**
 * @module ol/functions
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Always returns true.
 * @return {boolean} true.
 */ parcelHelpers.export(exports, "TRUE", ()=>TRUE);
/**
 * Always returns false.
 * @return {boolean} false.
 */ parcelHelpers.export(exports, "FALSE", ()=>FALSE);
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */ parcelHelpers.export(exports, "VOID", ()=>VOID);
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */ parcelHelpers.export(exports, "memoizeOne", ()=>memoizeOne);
/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */ parcelHelpers.export(exports, "toPromise", ()=>toPromise);
var _arrayJs = require("./array.js");
function TRUE() {
    return true;
}
function FALSE() {
    return false;
}
function VOID() {}
function memoizeOne(fn) {
    let called = false;
    /** @type {ReturnType} */ let lastResult;
    /** @type {Array<any>} */ let lastArgs;
    let lastThis;
    return function() {
        const nextArgs = Array.prototype.slice.call(arguments);
        if (!called || this !== lastThis || !(0, _arrayJs.equals)(nextArgs, lastArgs)) {
            called = true;
            lastThis = this;
            lastArgs = nextArgs;
            lastResult = fn.apply(this, arguments);
        }
        return lastResult;
    };
}
function toPromise(getter) {
    function promiseGetter() {
        let value;
        try {
            value = getter();
        } catch (err) {
            return Promise.reject(err);
        }
        if (value instanceof Promise) return value;
        return Promise.resolve(value);
    }
    return promiseGetter();
}

},{"./array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Fbic":[function(require,module,exports) {
/**
 * @module ol/array
 */ /**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "binarySearch", ()=>binarySearch);
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */ parcelHelpers.export(exports, "numberSafeCompareFunction", ()=>numberSafeCompareFunction);
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */ /**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */ parcelHelpers.export(exports, "linearFindNearest", ()=>linearFindNearest);
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */ parcelHelpers.export(exports, "reverseSubArray", ()=>reverseSubArray);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */ parcelHelpers.export(exports, "extend", ()=>extend);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */ parcelHelpers.export(exports, "remove", ()=>remove);
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */ parcelHelpers.export(exports, "stableSort", ()=>stableSort);
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */ parcelHelpers.export(exports, "isSorted", ()=>isSorted);
function binarySearch(haystack, needle, comparator) {
    let mid, cmp;
    comparator = comparator || numberSafeCompareFunction;
    let low = 0;
    let high = haystack.length;
    let found = false;
    while(low < high){
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */ mid = low + (high - low >> 1);
        cmp = +comparator(haystack[mid], needle);
        if (cmp < 0.0) /* Too low. */ low = mid + 1;
        else {
            /* Key found or too high */ high = mid;
            found = !cmp;
        }
    }
    /* Key not found. */ return found ? low : ~low;
}
function numberSafeCompareFunction(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
    const n = arr.length;
    if (arr[0] <= target) return 0;
    else if (target <= arr[n - 1]) return n - 1;
    else {
        let i;
        if (direction > 0) for(i = 1; i < n; ++i){
            if (arr[i] < target) return i - 1;
        }
        else if (direction < 0) for(i = 1; i < n; ++i){
            if (arr[i] <= target) return i;
        }
        else for(i = 1; i < n; ++i){
            if (arr[i] == target) return i;
            else if (arr[i] < target) {
                if (typeof direction === "function") {
                    if (direction(target, arr[i - 1], arr[i]) > 0) return i - 1;
                    else return i;
                } else if (arr[i - 1] - target < target - arr[i]) return i - 1;
                else return i;
            }
        }
        return n - 1;
    }
}
function reverseSubArray(arr, begin, end) {
    while(begin < end){
        const tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
    }
}
function extend(arr, data) {
    const extension = Array.isArray(data) ? data : [
        data
    ];
    const length = extension.length;
    for(let i = 0; i < length; i++)arr[arr.length] = extension[i];
}
function remove(arr, obj) {
    const i = arr.indexOf(obj);
    const found = i > -1;
    if (found) arr.splice(i, 1);
    return found;
}
function equals(arr1, arr2) {
    const len1 = arr1.length;
    if (len1 !== arr2.length) return false;
    for(let i = 0; i < len1; i++){
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
function stableSort(arr, compareFnc) {
    const length = arr.length;
    const tmp = Array(arr.length);
    let i;
    for(i = 0; i < length; i++)tmp[i] = {
        index: i,
        value: arr[i]
    };
    tmp.sort(function(a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
    });
    for(i = 0; i < arr.length; i++)arr[i] = tmp[i].value;
}
function isSorted(arr, func, strict) {
    const compare = func || numberSafeCompareFunction;
    return arr.every(function(currentVal, index) {
        if (index === 0) return true;
        const res = compare(arr[index - 1], currentVal);
        return !(res > 0 || strict && res === 0);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ssAG":[function(require,module,exports) {
/**
 * @module ol/obj
 */ /**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
function clear(object) {
    for(const property in object)delete object[property];
}
function isEmpty(object) {
    let property;
    for(property in object)return false;
    return !property;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hrQJ6":[function(require,module,exports) {
/**
 * @module ol/events/EventType
 */ /**
 * @enum {string}
 * @const
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */ CHANGE: "change",
    /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */ ERROR: "error",
    BLUR: "blur",
    CLEAR: "clear",
    CONTEXTMENU: "contextmenu",
    CLICK: "click",
    DBLCLICK: "dblclick",
    DRAGENTER: "dragenter",
    DRAGOVER: "dragover",
    DROP: "drop",
    FOCUS: "focus",
    KEYDOWN: "keydown",
    KEYPRESS: "keypress",
    LOAD: "load",
    RESIZE: "resize",
    TOUCHMOVE: "touchmove",
    WHEEL: "wheel"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dcspA":[function(require,module,exports) {
/**
 * @module ol/events
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */ /**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */ /**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */ /**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */ /**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */ parcelHelpers.export(exports, "listen", ()=>listen);
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */ parcelHelpers.export(exports, "listenOnce", ()=>listenOnce);
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */ parcelHelpers.export(exports, "unlistenByKey", ()=>unlistenByKey);
var _objJs = require("./obj.js");
function listen(target, type, listener, thisArg, once) {
    if (thisArg && thisArg !== target) listener = listener.bind(thisArg);
    if (once) {
        const originalListener = listener;
        listener = function() {
            target.removeEventListener(type, listener);
            originalListener.apply(this, arguments);
        };
    }
    const eventsKey = {
        target: target,
        type: type,
        listener: listener
    };
    target.addEventListener(type, listener);
    return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
    return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
    if (key && key.target) {
        key.target.removeEventListener(key.type, key.listener);
        (0, _objJs.clear)(key);
    }
}

},{"./obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lDlNi":[function(require,module,exports) {
/**
 * @module ol/css
 */ /**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */ /**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CLASS_HIDDEN", ()=>CLASS_HIDDEN);
parcelHelpers.export(exports, "CLASS_SELECTABLE", ()=>CLASS_SELECTABLE);
parcelHelpers.export(exports, "CLASS_UNSELECTABLE", ()=>CLASS_UNSELECTABLE);
parcelHelpers.export(exports, "CLASS_UNSUPPORTED", ()=>CLASS_UNSUPPORTED);
parcelHelpers.export(exports, "CLASS_CONTROL", ()=>CLASS_CONTROL);
parcelHelpers.export(exports, "CLASS_COLLAPSED", ()=>CLASS_COLLAPSED);
parcelHelpers.export(exports, "getFontParameters", ()=>getFontParameters);
const CLASS_HIDDEN = "ol-hidden";
const CLASS_SELECTABLE = "ol-selectable";
const CLASS_UNSELECTABLE = "ol-unselectable";
const CLASS_UNSUPPORTED = "ol-unsupported";
const CLASS_CONTROL = "ol-control";
const CLASS_COLLAPSED = "ol-collapsed";
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */ const fontRegEx = new RegExp([
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    "?\\s*([-,\\\"\\'\\sa-z]+?)\\s*$"
].join(""), "i");
const fontRegExMatchIndex = [
    "style",
    "variant",
    "weight",
    "size",
    "lineHeight",
    "family"
];
const getFontParameters = function(fontSpec) {
    const match = fontSpec.match(fontRegEx);
    if (!match) return null;
    const style = /** @type {FontParameters} */ {
        lineHeight: "normal",
        size: "1.2em",
        style: "normal",
        weight: "normal",
        variant: "normal"
    };
    for(let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i){
        const value = match[i + 1];
        if (value !== undefined) style[fontRegExMatchIndex[i]] = value;
    }
    style.families = style.family.split(/,\s?/);
    return style;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fB56":[function(require,module,exports) {
/**
 * @module ol/style/Fill
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */ /**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Fill {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */ this.color_ = options.color !== undefined ? options.color : null;
    }
    /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */ clone() {
        const color = this.getColor();
        return new Fill({
            color: Array.isArray(color) ? color.slice() : color || undefined
        });
    }
    /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */ setColor(color) {
        this.color_ = color;
    }
}
exports.default = Fill;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dJiIs":[function(require,module,exports) {
/**
 * @module ol/style/Icon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _assertsJs = require("../asserts.js");
var _iconImageJs = require("./IconImage.js");
var _utilJs = require("../util.js");
/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */ /**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */ /**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not.
 * The provided `imgSize` needs to match the actual size of the image.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */ /**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */ class Icon extends (0, _imageJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @type {number}
     */ const opacity = options.opacity !== undefined ? options.opacity : 1;
        /**
     * @type {number}
     */ const rotation = options.rotation !== undefined ? options.rotation : 0;
        /**
     * @type {number|import("../size.js").Size}
     */ const scale = options.scale !== undefined ? options.scale : 1;
        /**
     * @type {boolean}
     */ const rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        super({
            opacity: opacity,
            rotation: rotation,
            scale: scale,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            rotateWithView: rotateWithView,
            declutterMode: options.declutterMode
        });
        /**
     * @private
     * @type {Array<number>}
     */ this.anchor_ = options.anchor !== undefined ? options.anchor : [
            0.5,
            0.5
        ];
        /**
     * @private
     * @type {Array<number>}
     */ this.normalizedAnchor_ = null;
        /**
     * @private
     * @type {IconOrigin}
     */ this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : "top-left";
        /**
     * @private
     * @type {IconAnchorUnits}
     */ this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : "fraction";
        /**
     * @private
     * @type {IconAnchorUnits}
     */ this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : "fraction";
        /**
     * @private
     * @type {?string}
     */ this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
        /**
     * @type {HTMLImageElement|HTMLCanvasElement}
     */ const image = options.img !== undefined ? options.img : null;
        /**
     * @private
     * @type {import("../size.js").Size|undefined}
     */ this.imgSize_ = options.imgSize;
        /**
     * @type {string|undefined}
     */ let src = options.src;
        (0, _assertsJs.assert)(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
        (0, _assertsJs.assert)(!image || image && this.imgSize_, 5); // `imgSize` must be set when `image` is provided
        if ((src === undefined || src.length === 0) && image) src = /** @type {HTMLImageElement} */ image.src || (0, _utilJs.getUid)(image);
        (0, _assertsJs.assert)(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided
        /**
     * @type {import("../ImageState.js").default}
     */ const imageState = options.src !== undefined ? (0, _imageStateJsDefault.default).IDLE : (0, _imageStateJsDefault.default).LOADED;
        /**
     * @private
     * @type {import("../color.js").Color}
     */ this.color_ = options.color !== undefined ? (0, _colorJs.asArray)(options.color) : null;
        /**
     * @private
     * @type {import("./IconImage.js").default}
     */ this.iconImage_ = (0, _iconImageJs.get)(image, /** @type {string} */ src, this.imgSize_ !== undefined ? this.imgSize_ : null, this.crossOrigin_, imageState, this.color_);
        /**
     * @private
     * @type {Array<number>}
     */ this.offset_ = options.offset !== undefined ? options.offset : [
            0,
            0
        ];
        /**
     * @private
     * @type {IconOrigin}
     */ this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : "top-left";
        /**
     * @private
     * @type {Array<number>}
     */ this.origin_ = null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.size_ = options.size !== undefined ? options.size : null;
    }
    /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        return new Icon({
            anchor: this.anchor_.slice(),
            anchorOrigin: this.anchorOrigin_,
            anchorXUnits: this.anchorXUnits_,
            anchorYUnits: this.anchorYUnits_,
            color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
            crossOrigin: this.crossOrigin_,
            imgSize: this.imgSize_,
            offset: this.offset_.slice(),
            offsetOrigin: this.offsetOrigin_,
            opacity: this.getOpacity(),
            rotateWithView: this.getRotateWithView(),
            rotation: this.getRotation(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            size: this.size_ !== null ? this.size_.slice() : undefined,
            src: this.getSrc(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */ getAnchor() {
        let anchor = this.normalizedAnchor_;
        if (!anchor) {
            anchor = this.anchor_;
            const size = this.getSize();
            if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
                if (!size) return null;
                anchor = this.anchor_.slice();
                if (this.anchorXUnits_ == "fraction") anchor[0] *= size[0];
                if (this.anchorYUnits_ == "fraction") anchor[1] *= size[1];
            }
            if (this.anchorOrigin_ != "top-left") {
                if (!size) return null;
                if (anchor === this.anchor_) anchor = this.anchor_.slice();
                if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") anchor[0] = -anchor[0] + size[0];
                if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") anchor[1] = -anchor[1] + size[1];
            }
            this.normalizedAnchor_ = anchor;
        }
        const displacement = this.getDisplacement();
        const scale = this.getScaleArray();
        // anchor is scaled by renderer but displacement should not be scaled
        // so divide by scale here
        return [
            anchor[0] - displacement[0] / scale[0],
            anchor[1] + displacement[1] / scale[1]
        ];
    }
    /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */ setAnchor(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
    }
    /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */ getImage(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
    }
    /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */ getPixelRatio(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
    }
    /**
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return this.iconImage_.getSize();
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return this.iconImage_.getImageState();
    }
    /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */ getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
    }
    /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */ getOrigin() {
        if (this.origin_) return this.origin_;
        let offset = this.offset_;
        if (this.offsetOrigin_ != "top-left") {
            const size = this.getSize();
            const iconImageSize = this.iconImage_.getSize();
            if (!size || !iconImageSize) return null;
            offset = offset.slice();
            if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") offset[0] = iconImageSize[0] - size[0] - offset[0];
            if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") offset[1] = iconImageSize[1] - size[1] - offset[1];
        }
        this.origin_ = offset;
        return this.origin_;
    }
    /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */ getSrc() {
        return this.iconImage_.getSrc();
    }
    /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */ getSize() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {
        this.iconImage_.addEventListener((0, _eventTypeJsDefault.default).CHANGE, listener);
    }
    /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */ load() {
        this.iconImage_.load();
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {
        this.iconImage_.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, listener);
    }
}
exports.default = Icon;

},{"../events/EventType.js":"hrQJ6","../ImageState.js":"c4jJS","./Image.js":"eyoR9","../color.js":"4tahz","../asserts.js":"e4TiF","./IconImage.js":"8WrYM","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8WrYM":[function(require,module,exports) {
/**
 * @module ol/style/IconImage
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */ parcelHelpers.export(exports, "get", ()=>get);
var _targetJs = require("../events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _colorJs = require("../color.js");
var _domJs = require("../dom.js");
var _iconImageCacheJs = require("./IconImageCache.js");
var _imageJs = require("../Image.js");
/**
 * @type {CanvasRenderingContext2D}
 */ let taintedTestContext = null;
class IconImage extends (0, _targetJsDefault.default) {
    /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */ constructor(image, src, size, crossOrigin, imageState, color){
        super();
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */ this.hitDetectionImage_ = null;
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */ this.image_ = image;
        /**
     * @private
     * @type {string|null}
     */ this.crossOrigin_ = crossOrigin;
        /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */ this.canvas_ = {};
        /**
     * @private
     * @type {import("../color.js").Color}
     */ this.color_ = color;
        /**
     * @private
     * @type {?function():void}
     */ this.unlisten_ = null;
        /**
     * @private
     * @type {import("../ImageState.js").default}
     */ this.imageState_ = imageState;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.size_ = size;
        /**
     * @private
     * @type {string|undefined}
     */ this.src_ = src;
        /**
     * @private
     */ this.tainted_;
    }
    /**
   * @private
   */ initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) this.image_.crossOrigin = this.crossOrigin_;
    }
    /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */ isTainted_() {
        if (this.tainted_ === undefined && this.imageState_ === (0, _imageStateJsDefault.default).LOADED) {
            if (!taintedTestContext) taintedTestContext = (0, _domJs.createCanvasContext2D)(1, 1);
            taintedTestContext.drawImage(this.image_, 0, 0);
            try {
                taintedTestContext.getImageData(0, 0, 1, 1);
                this.tainted_ = false;
            } catch (e) {
                taintedTestContext = null;
                this.tainted_ = true;
            }
        }
        return this.tainted_ === true;
    }
    /**
   * @private
   */ dispatchChangeEvent_() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * @private
   */ handleImageError_() {
        this.imageState_ = (0, _imageStateJsDefault.default).ERROR;
        this.unlistenImage_();
        this.dispatchChangeEvent_();
    }
    /**
   * @private
   */ handleImageLoad_() {
        this.imageState_ = (0, _imageStateJsDefault.default).LOADED;
        if (this.size_) {
            this.image_.width = this.size_[0];
            this.image_.height = this.size_[1];
        } else this.size_ = [
            this.image_.width,
            this.image_.height
        ];
        this.unlistenImage_();
        this.dispatchChangeEvent_();
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */ getImage(pixelRatio) {
        if (!this.image_) this.initializeImage_();
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */ getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return this.imageState_;
    }
    /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */ getHitDetectionImage() {
        if (!this.image_) this.initializeImage_();
        if (!this.hitDetectionImage_) {
            if (this.isTainted_()) {
                const width = this.size_[0];
                const height = this.size_[1];
                const context = (0, _domJs.createCanvasContext2D)(width, height);
                context.fillRect(0, 0, width, height);
                this.hitDetectionImage_ = context.canvas;
            } else this.hitDetectionImage_ = this.image_;
        }
        return this.hitDetectionImage_;
    }
    /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */ getSize() {
        return this.size_;
    }
    /**
   * @return {string|undefined} Image src.
   */ getSrc() {
        return this.src_;
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.imageState_ !== (0, _imageStateJsDefault.default).IDLE) return;
        if (!this.image_) this.initializeImage_();
        this.imageState_ = (0, _imageStateJsDefault.default).LOADING;
        try {
            /** @type {HTMLImageElement} */ this.image_.src = this.src_;
        } catch (e) {
            this.handleImageError_();
        }
        this.unlisten_ = (0, _imageJs.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */ replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== (0, _imageStateJsDefault.default).LOADED) return;
        const image = this.image_;
        const canvas = document.createElement("canvas");
        canvas.width = Math.ceil(image.width * pixelRatio);
        canvas.height = Math.ceil(image.height * pixelRatio);
        const ctx = canvas.getContext("2d");
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = (0, _colorJs.asString)(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
    }
    /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */ unlistenImage_() {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    }
}
function get(image, src, size, crossOrigin, imageState, color) {
    let iconImage = (0, _iconImageCacheJs.shared).get(src, crossOrigin, color);
    if (!iconImage) {
        iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
        (0, _iconImageCacheJs.shared).set(src, crossOrigin, color, iconImage);
    }
    return iconImage;
}
exports.default = IconImage;

},{"../events/Target.js":"7T5Yi","../events/EventType.js":"hrQJ6","../ImageState.js":"c4jJS","../color.js":"4tahz","../dom.js":"84QzQ","./IconImageCache.js":"2uEpE","../Image.js":"c0Egp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2uEpE":[function(require,module,exports) {
/**
 * @module ol/style/IconImageCache
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shared", ()=>shared);
var _colorJs = require("../color.js");
/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */ class IconImageCache {
    constructor(){
        /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */ this.cache_ = {};
        /**
     * @type {number}
     * @private
     */ this.cacheSize_ = 0;
        /**
     * @type {number}
     * @private
     */ this.maxCacheSize_ = 32;
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.cache_ = {};
        this.cacheSize_ = 0;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
   * FIXME empty description for jsdoc
   */ expire() {
        if (this.canExpireCache()) {
            let i = 0;
            for(const key in this.cache_){
                const iconImage = this.cache_[key];
                if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                    delete this.cache_[key];
                    --this.cacheSize_;
                }
            }
        }
    }
    /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */ get(src, crossOrigin, color) {
        const key = getKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
    }
    /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */ set(src, crossOrigin, color, iconImage) {
        const key = getKey(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
    }
    /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */ setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
    }
}
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */ function getKey(src, crossOrigin, color) {
    const colorString = color ? (0, _colorJs.asString)(color) : "null";
    return crossOrigin + ":" + src + ":" + colorString;
}
exports.default = IconImageCache;
const shared = new IconImageCache();

},{"../color.js":"4tahz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c0Egp":[function(require,module,exports) {
/**
 * @module ol/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */ parcelHelpers.export(exports, "listenImage", ()=>listenImage);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageBaseJs = require("./ImageBase.js");
var _imageBaseJsDefault = parcelHelpers.interopDefault(_imageBaseJs);
var _imageStateJs = require("./ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _hasJs = require("./has.js");
var _extentJs = require("./extent.js");
var _eventsJs = require("./events.js");
/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */ class ImageWrapper extends (0, _imageBaseJsDefault.default) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   */ constructor(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction){
        super(extent, resolution, pixelRatio, (0, _imageStateJsDefault.default).IDLE);
        /**
     * @private
     * @type {string}
     */ this.src_ = src;
        /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */ this.image_ = new Image();
        if (crossOrigin !== null) this.image_.crossOrigin = crossOrigin;
        /**
     * @private
     * @type {?function():void}
     */ this.unlisten_ = null;
        /**
     * @protected
     * @type {import("./ImageState.js").default}
     */ this.state = (0, _imageStateJsDefault.default).IDLE;
        /**
     * @private
     * @type {LoadFunction}
     */ this.imageLoadFunction_ = imageLoadFunction;
    }
    /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */ getImage() {
        return this.image_;
    }
    /**
   * Tracks loading or read errors.
   *
   * @private
   */ handleImageError_() {
        this.state = (0, _imageStateJsDefault.default).ERROR;
        this.unlistenImage_();
        this.changed();
    }
    /**
   * Tracks successful image load.
   *
   * @private
   */ handleImageLoad_() {
        if (this.resolution === undefined) this.resolution = (0, _extentJs.getHeight)(this.extent) / this.image_.height;
        this.state = (0, _imageStateJsDefault.default).LOADED;
        this.unlistenImage_();
        this.changed();
    }
    /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */ load() {
        if (this.state == (0, _imageStateJsDefault.default).IDLE || this.state == (0, _imageStateJsDefault.default).ERROR) {
            this.state = (0, _imageStateJsDefault.default).LOADING;
            this.changed();
            this.imageLoadFunction_(this, this.src_);
            this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    }
    /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */ setImage(image) {
        this.image_ = image;
        this.resolution = (0, _extentJs.getHeight)(this.extent) / this.image_.height;
    }
    /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */ unlistenImage_() {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    }
}
function listenImage(image, loadHandler, errorHandler) {
    const img = /** @type {HTMLImageElement} */ image;
    let listening = true;
    let decoding = false;
    let loaded = false;
    const listenerKeys = [
        (0, _eventsJs.listenOnce)(img, (0, _eventTypeJsDefault.default).LOAD, function() {
            loaded = true;
            if (!decoding) loadHandler();
        })
    ];
    if (img.src && (0, _hasJs.IMAGE_DECODE)) {
        decoding = true;
        img.decode().then(function() {
            if (listening) loadHandler();
        }).catch(function(error) {
            if (listening) {
                if (loaded) loadHandler();
                else errorHandler();
            }
        });
    } else listenerKeys.push((0, _eventsJs.listenOnce)(img, (0, _eventTypeJsDefault.default).ERROR, errorHandler));
    return function unlisten() {
        listening = false;
        listenerKeys.forEach((0, _eventsJs.unlistenByKey));
    };
}
exports.default = ImageWrapper;

},{"./events/EventType.js":"hrQJ6","./ImageBase.js":"2yGE2","./ImageState.js":"c4jJS","./has.js":"6BDNi","./extent.js":"6YrVc","./events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2yGE2":[function(require,module,exports) {
/**
 * @module ol/ImageBase
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _utilJs = require("./util.js");
/**
 * @abstract
 */ class ImageBase extends (0, _targetJsDefault.default) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */ constructor(extent, resolution, pixelRatio, state){
        super();
        /**
     * @protected
     * @type {import("./extent.js").Extent}
     */ this.extent = extent;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @protected
     * @type {number|undefined}
     */ this.resolution = resolution;
        /**
     * @protected
     * @type {import("./ImageState.js").default}
     */ this.state = state;
    }
    /**
   * @protected
   */ changed() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * @return {import("./extent.js").Extent} Extent.
   */ getExtent() {
        return this.extent;
    }
    /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */ getImage() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @return {number} PixelRatio.
   */ getPixelRatio() {
        return this.pixelRatio_;
    }
    /**
   * @return {number} Resolution.
   */ getResolution() {
        return /** @type {number} */ this.resolution;
    }
    /**
   * @return {import("./ImageState.js").default} State.
   */ getState() {
        return this.state;
    }
    /**
   * Load not yet loaded URI.
   * @abstract
   */ load() {
        (0, _utilJs.abstract)();
    }
}
exports.default = ImageBase;

},{"./events/Target.js":"7T5Yi","./events/EventType.js":"hrQJ6","./util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YrVc":[function(require,module,exports) {
/**
 * @module ol/extent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */ /**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */ /**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */ parcelHelpers.export(exports, "boundingExtent", ()=>boundingExtent);
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "buffer", ()=>buffer);
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */ parcelHelpers.export(exports, "clone", ()=>clone);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */ parcelHelpers.export(exports, "closestSquaredDistanceXY", ()=>closestSquaredDistanceXY);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsCoordinate", ()=>containsCoordinate);
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */ parcelHelpers.export(exports, "containsExtent", ()=>containsExtent);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsXY", ()=>containsXY);
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */ parcelHelpers.export(exports, "coordinateRelationship", ()=>coordinateRelationship);
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */ parcelHelpers.export(exports, "createEmpty", ()=>createEmpty);
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate);
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateEmpty", ()=>createOrUpdateEmpty);
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinate", ()=>createOrUpdateFromCoordinate);
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinates", ()=>createOrUpdateFromCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromFlatCoordinates", ()=>createOrUpdateFromFlatCoordinates);
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromRings", ()=>createOrUpdateFromRings);
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */ parcelHelpers.export(exports, "approximatelyEquals", ()=>approximatelyEquals);
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */ parcelHelpers.export(exports, "extend", ()=>extend);
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */ parcelHelpers.export(exports, "extendCoordinate", ()=>extendCoordinate);
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendCoordinates", ()=>extendCoordinates);
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendFlatCoordinates", ()=>extendFlatCoordinates);
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendRings", ()=>extendRings);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */ parcelHelpers.export(exports, "extendXY", ()=>extendXY);
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */ parcelHelpers.export(exports, "forEachCorner", ()=>forEachCorner);
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea);
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomLeft", ()=>getBottomLeft);
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomRight", ()=>getBottomRight);
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */ parcelHelpers.export(exports, "getCenter", ()=>getCenter);
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */ parcelHelpers.export(exports, "getCorner", ()=>getCorner);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */ parcelHelpers.export(exports, "getEnlargedArea", ()=>getEnlargedArea);
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "getForViewAndSize", ()=>getForViewAndSize);
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */ parcelHelpers.export(exports, "getRotatedViewport", ()=>getRotatedViewport);
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */ parcelHelpers.export(exports, "getHeight", ()=>getHeight);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */ parcelHelpers.export(exports, "getIntersectionArea", ()=>getIntersectionArea);
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */ parcelHelpers.export(exports, "getIntersection", ()=>getIntersection);
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */ parcelHelpers.export(exports, "getMargin", ()=>getMargin);
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */ parcelHelpers.export(exports, "getSize", ()=>getSize);
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopLeft", ()=>getTopLeft);
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopRight", ()=>getTopRight);
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */ parcelHelpers.export(exports, "getWidth", ()=>getWidth);
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */ parcelHelpers.export(exports, "intersects", ()=>intersects);
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "returnOrUpdate", ()=>returnOrUpdate);
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */ parcelHelpers.export(exports, "scaleFromCenter", ()=>scaleFromCenter);
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */ parcelHelpers.export(exports, "intersectsSegment", ()=>intersectsSegment);
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "applyTransform", ()=>applyTransform);
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Array<Extent>} The extent within the real world extent.
 */ parcelHelpers.export(exports, "wrapAndSliceX", ()=>wrapAndSliceX);
var _relationshipJs = require("./extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
var _assertsJs = require("./asserts.js");
function boundingExtent(coordinates) {
    const extent = createEmpty();
    for(let i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */ function _boundingExtentXYs(xs, ys, dest) {
    const minX = Math.min.apply(null, xs);
    const minY = Math.min.apply(null, ys);
    const maxX = Math.max.apply(null, xs);
    const maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
    if (dest) {
        dest[0] = extent[0] - value;
        dest[1] = extent[1] - value;
        dest[2] = extent[2] + value;
        dest[3] = extent[3] + value;
        return dest;
    } else return [
        extent[0] - value,
        extent[1] - value,
        extent[2] + value,
        extent[3] + value
    ];
}
function clone(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    } else return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
    let dx, dy;
    if (x < extent[0]) dx = extent[0] - x;
    else if (extent[2] < x) dx = x - extent[2];
    else dx = 0;
    if (y < extent[1]) dy = extent[1] - y;
    else if (extent[3] < y) dy = y - extent[3];
    else dy = 0;
    return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const x = coordinate[0];
    const y = coordinate[1];
    let relationship = (0, _relationshipJsDefault.default).UNKNOWN;
    if (x < minX) relationship = relationship | (0, _relationshipJsDefault.default).LEFT;
    else if (x > maxX) relationship = relationship | (0, _relationshipJsDefault.default).RIGHT;
    if (y < minY) relationship = relationship | (0, _relationshipJsDefault.default).BELOW;
    else if (y > maxY) relationship = relationship | (0, _relationshipJsDefault.default).ABOVE;
    if (relationship === (0, _relationshipJsDefault.default).UNKNOWN) relationship = (0, _relationshipJsDefault.default).INTERSECTING;
    return relationship;
}
function createEmpty() {
    return [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
    if (dest) {
        dest[0] = minX;
        dest[1] = minY;
        dest[2] = maxX;
        dest[3] = maxY;
        return dest;
    } else return [
        minX,
        minY,
        maxX,
        maxY
    ];
}
function createOrUpdateEmpty(dest) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
    const x = coordinate[0];
    const y = coordinate[1];
    return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromCoordinates(coordinates, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendCoordinates(extent, coordinates);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function createOrUpdateFromRings(rings, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendRings(extent, rings);
}
function equals(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
    return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) extent1[0] = extent2[0];
    if (extent2[2] > extent1[2]) extent1[2] = extent2[2];
    if (extent2[1] < extent1[1]) extent1[1] = extent2[1];
    if (extent2[3] > extent1[3]) extent1[3] = extent2[3];
    return extent1;
}
function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) extent[0] = coordinate[0];
    if (coordinate[0] > extent[2]) extent[2] = coordinate[0];
    if (coordinate[1] < extent[1]) extent[1] = coordinate[1];
    if (coordinate[1] > extent[3]) extent[3] = coordinate[1];
}
function extendCoordinates(extent, coordinates) {
    for(let i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for(; offset < end; offset += stride)extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    return extent;
}
function extendRings(extent, rings) {
    for(let i = 0, ii = rings.length; i < ii; ++i)extendCoordinates(extent, rings[i]);
    return extent;
}
function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
    let val;
    val = callback(getBottomLeft(extent));
    if (val) return val;
    val = callback(getBottomRight(extent));
    if (val) return val;
    val = callback(getTopRight(extent));
    if (val) return val;
    val = callback(getTopLeft(extent));
    if (val) return val;
    return false;
}
function getArea(extent) {
    let area = 0;
    if (!isEmpty(extent)) area = getWidth(extent) * getHeight(extent);
    return area;
}
function getBottomLeft(extent) {
    return [
        extent[0],
        extent[1]
    ];
}
function getBottomRight(extent) {
    return [
        extent[2],
        extent[1]
    ];
}
function getCenter(extent) {
    return [
        (extent[0] + extent[2]) / 2,
        (extent[1] + extent[3]) / 2
    ];
}
function getCorner(extent, corner) {
    let coordinate;
    if (corner === "bottom-left") coordinate = getBottomLeft(extent);
    else if (corner === "bottom-right") coordinate = getBottomRight(extent);
    else if (corner === "top-left") coordinate = getTopLeft(extent);
    else if (corner === "top-right") coordinate = getTopRight(extent);
    else (0, _assertsJs.assert)(false, 13); // Invalid corner
    return coordinate;
}
function getEnlargedArea(extent1, extent2) {
    const minX = Math.min(extent1[0], extent2[0]);
    const minY = Math.min(extent1[1], extent2[1]);
    const maxX = Math.max(extent1[2], extent2[2]);
    const maxY = Math.max(extent1[3], extent2[3]);
    return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
    const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(center, resolution, rotation, size);
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
}
function getRotatedViewport(center, resolution, rotation, size) {
    const dx = resolution * size[0] / 2;
    const dy = resolution * size[1] / 2;
    const cosRotation = Math.cos(rotation);
    const sinRotation = Math.sin(rotation);
    const xCos = dx * cosRotation;
    const xSin = dx * sinRotation;
    const yCos = dy * cosRotation;
    const ySin = dy * sinRotation;
    const x = center[0];
    const y = center[1];
    return [
        x - xCos + ySin,
        y - xSin - yCos,
        x - xCos - ySin,
        y - xSin + yCos,
        x + xCos - ySin,
        y + xSin + yCos,
        x + xCos + ySin,
        y + xSin - yCos,
        x - xCos + ySin,
        y - xSin - yCos
    ];
}
function getHeight(extent) {
    return extent[3] - extent[1];
}
function getIntersectionArea(extent1, extent2) {
    const intersection = getIntersection(extent1, extent2);
    return getArea(intersection);
}
function getIntersection(extent1, extent2, dest) {
    const intersection = dest ? dest : createEmpty();
    if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) intersection[0] = extent1[0];
        else intersection[0] = extent2[0];
        if (extent1[1] > extent2[1]) intersection[1] = extent1[1];
        else intersection[1] = extent2[1];
        if (extent1[2] < extent2[2]) intersection[2] = extent1[2];
        else intersection[2] = extent2[2];
        if (extent1[3] < extent2[3]) intersection[3] = extent1[3];
        else intersection[3] = extent2[3];
    } else createOrUpdateEmpty(intersection);
    return intersection;
}
function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
}
function getSize(extent) {
    return [
        extent[2] - extent[0],
        extent[3] - extent[1]
    ];
}
function getTopLeft(extent) {
    return [
        extent[0],
        extent[3]
    ];
}
function getTopRight(extent) {
    return [
        extent[2],
        extent[3]
    ];
}
function getWidth(extent) {
    return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    } else return extent;
}
function scaleFromCenter(extent, value) {
    const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
    const deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= deltaY;
    extent[3] += deltaY;
}
function intersectsSegment(extent, start, end) {
    let intersects = false;
    const startRel = coordinateRelationship(extent, start);
    const endRel = coordinateRelationship(extent, end);
    if (startRel === (0, _relationshipJsDefault.default).INTERSECTING || endRel === (0, _relationshipJsDefault.default).INTERSECTING) intersects = true;
    else {
        const minX = extent[0];
        const minY = extent[1];
        const maxX = extent[2];
        const maxY = extent[3];
        const startX = start[0];
        const startY = start[1];
        const endX = end[0];
        const endY = end[1];
        const slope = (endY - startY) / (endX - startX);
        let x, y;
        if (!!(endRel & (0, _relationshipJsDefault.default).ABOVE) && !(startRel & (0, _relationshipJsDefault.default).ABOVE)) {
            // potentially intersects top
            x = endX - (endY - maxY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).RIGHT) && !(startRel & (0, _relationshipJsDefault.default).RIGHT)) {
            // potentially intersects right
            y = endY - (endX - maxX) * slope;
            intersects = y >= minY && y <= maxY;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).BELOW) && !(startRel & (0, _relationshipJsDefault.default).BELOW)) {
            // potentially intersects bottom
            x = endX - (endY - minY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).LEFT) && !(startRel & (0, _relationshipJsDefault.default).LEFT)) {
            // potentially intersects left
            y = endY - (endX - minX) * slope;
            intersects = y >= minY && y <= maxY;
        }
    }
    return intersects;
}
function applyTransform(extent, transformFn, dest, stops) {
    let coordinates = [];
    if (stops > 1) {
        const width = extent[2] - extent[0];
        const height = extent[3] - extent[1];
        for(let i = 0; i < stops; ++i)coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);
    } else coordinates = [
        extent[0],
        extent[1],
        extent[2],
        extent[1],
        extent[2],
        extent[3],
        extent[0],
        extent[3]
    ];
    transformFn(coordinates, coordinates, 2);
    const xs = [];
    const ys = [];
    for(let i1 = 0, l = coordinates.length; i1 < l; i1 += 2){
        xs.push(coordinates[i1]);
        ys.push(coordinates[i1 + 1]);
    }
    return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
    const projectionExtent = projection.getExtent();
    const center = getCenter(extent);
    if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
        const worldWidth = getWidth(projectionExtent);
        const worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
        const offset = worldsAway * worldWidth;
        extent[0] -= offset;
        extent[2] -= offset;
    }
    return extent;
}
function wrapAndSliceX(extent, projection) {
    if (projection.canWrapX()) {
        const projectionExtent = projection.getExtent();
        if (!isFinite(extent[0]) || !isFinite(extent[2])) return [
            [
                projectionExtent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ]
        ];
        wrapX(extent, projection);
        const worldWidth = getWidth(projectionExtent);
        if (getWidth(extent) > worldWidth) // the extent wraps around on itself
        return [
            [
                projectionExtent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ]
        ];
        else if (extent[0] < projectionExtent[0]) // the extent crosses the anti meridian, so it needs to be sliced
        return [
            [
                extent[0] + worldWidth,
                extent[1],
                projectionExtent[2],
                extent[3]
            ],
            [
                projectionExtent[0],
                extent[1],
                extent[2],
                extent[3]
            ]
        ];
        else if (extent[2] > projectionExtent[2]) // the extent crosses the anti meridian, so it needs to be sliced
        return [
            [
                extent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ],
            [
                projectionExtent[0],
                extent[1],
                extent[2] - worldWidth,
                extent[3]
            ]
        ];
    }
    return [
        extent
    ];
}

},{"./extent/Relationship.js":"9q0e7","./asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9q0e7":[function(require,module,exports) {
/**
 * @module ol/extent/Relationship
 */ /**
 * Relationship to an extent.
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Oc3i":[function(require,module,exports) {
/**
 * @module ol/render/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a geometry from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature
 * Render Feature
 * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}
 * New geometry instance.
 * @api
 */ parcelHelpers.export(exports, "toGeometry", ()=>toGeometry);
/**
 * Create an `ol/Feature` from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature RenderFeature
 * @param {string} [geometryName='geometry'] Geometry name to use
 * when creating the Feature.
 * @return {Feature} Newly constructed `ol/Feature` with properties,
 * geometry, and id copied over.
 * @api
 */ parcelHelpers.export(exports, "toFeature", ()=>toFeature);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geomJs = require("../geom.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("../geom/flat/interiorpoint.js");
var _projJs = require("../proj.js");
var _orientJs = require("../geom/flat/orient.js");
var _interpolateJs = require("../geom/flat/interpolate.js");
var _centerJs = require("../geom/flat/center.js");
var _transformJs1 = require("../geom/flat/transform.js");
/**
 * @type {import("../transform.js").Transform}
 */ const tmpTransform = (0, _transformJs.create)();
/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */ class RenderFeature {
    /**
   * @param {import("../geom/Geometry.js").Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */ constructor(type, flatCoordinates, ends, properties, id){
        /**
     * @type {import("../style/Style.js").StyleFunction|undefined}
     */ this.styleFunction;
        /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */ this.extent_;
        /**
     * @private
     * @type {number|string|undefined}
     */ this.id_ = id;
        /**
     * @private
     * @type {import("../geom/Geometry.js").Type}
     */ this.type_ = type;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatCoordinates_ = flatCoordinates;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatInteriorPoints_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatMidpoints_ = null;
        /**
     * @private
     * @type {Array<number>|Array<Array<number>>}
     */ this.ends_ = ends;
        /**
     * @private
     * @type {Object<string, *>}
     */ this.properties_ = properties;
    }
    /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */ get(key) {
        return this.properties_[key];
    }
    /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        if (!this.extent_) this.extent_ = this.type_ === "Point" ? (0, _extentJs.createOrUpdateFromCoordinate)(this.flatCoordinates_) : (0, _extentJs.createOrUpdateFromFlatCoordinates)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
        return this.extent_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
            const flatCenter = (0, _extentJs.getCenter)(this.getExtent());
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointOfArray)(this.flatCoordinates_, 0, /** @type {Array<number>} */ this.ends_, 2, flatCenter, 0);
        }
        return this.flatInteriorPoints_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
            const flatCenters = (0, _centerJs.linearRingss)(this.flatCoordinates_, 0, /** @type {Array<Array<number>>} */ this.ends_, 2);
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointsOfMultiArray)(this.flatCoordinates_, 0, /** @type {Array<Array<number>>} */ this.ends_, 2, flatCenters);
        }
        return this.flatInteriorPoints_;
    }
    /**
   * @return {Array<number>} Flat midpoint.
   */ getFlatMidpoint() {
        if (!this.flatMidpoints_) this.flatMidpoints_ = (0, _interpolateJs.interpolatePoint)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
        return this.flatMidpoints_;
    }
    /**
   * @return {Array<number>} Flat midpoints.
   */ getFlatMidpoints() {
        if (!this.flatMidpoints_) {
            this.flatMidpoints_ = [];
            const flatCoordinates = this.flatCoordinates_;
            let offset = 0;
            const ends = /** @type {Array<number>} */ this.ends_;
            for(let i = 0, ii = ends.length; i < ii; ++i){
                const end = ends[i];
                const midpoint = (0, _interpolateJs.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);
                (0, _arrayJs.extend)(this.flatMidpoints_, midpoint);
                offset = end;
            }
        }
        return this.flatMidpoints_;
    }
    /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */ getId() {
        return this.id_;
    }
    /**
   * @return {Array<number>} Flat coordinates.
   */ getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
    }
    /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */ getGeometry() {
        return this;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        return this;
    }
    /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */ simplifyTransformed(squaredTolerance, transform) {
        return this;
    }
    /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */ getProperties() {
        return this.properties_;
    }
    /**
   * @return {number} Stride.
   */ getStride() {
        return 2;
    }
    /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */ getStyleFunction() {
        return this.styleFunction;
    }
    /**
   * Get the type of this feature's geometry.
   * @return {import("../geom/Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return this.type_;
    }
    /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */ transform(projection) {
        projection = (0, _projJs.get)(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
            const scale = (0, _extentJs.getHeight)(projectedExtent) / (0, _extentJs.getHeight)(pixelExtent);
            (0, _transformJs.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            (0, _transformJs1.transform2D)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
        }
    }
    /**
   * @return {Array<number>|Array<Array<number>>} Ends or endss.
   */ getEnds() {
        return this.ends_;
    }
}
RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
/**
 * @return {Array<number>} Flat coordinates.
 */ RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
function toGeometry(renderFeature) {
    const geometryType = renderFeature.getType();
    switch(geometryType){
        case "Point":
            return new (0, _geomJs.Point)(renderFeature.getFlatCoordinates());
        case "MultiPoint":
            return new (0, _geomJs.MultiPoint)(renderFeature.getFlatCoordinates(), "XY");
        case "LineString":
            return new (0, _geomJs.LineString)(renderFeature.getFlatCoordinates(), "XY");
        case "MultiLineString":
            return new (0, _geomJs.MultiLineString)(renderFeature.getFlatCoordinates(), "XY", /** @type {Array<number>} */ renderFeature.getEnds());
        case "Polygon":
            const flatCoordinates = renderFeature.getFlatCoordinates();
            const ends = /** @type {Array<number>} */ renderFeature.getEnds();
            const endss = (0, _orientJs.inflateEnds)(flatCoordinates, ends);
            return endss.length > 1 ? new (0, _geomJs.MultiPolygon)(flatCoordinates, "XY", endss) : new (0, _geomJs.Polygon)(flatCoordinates, "XY", ends);
        default:
            throw new Error("Invalid geometry type:" + geometryType);
    }
}
function toFeature(renderFeature, geometryName) {
    const id = renderFeature.getId();
    const geometry = toGeometry(renderFeature);
    const properties = renderFeature.getProperties();
    const feature = new (0, _featureJsDefault.default)();
    if (geometryName !== undefined) feature.setGeometryName(geometryName);
    feature.setGeometry(geometry);
    if (id !== undefined) feature.setId(id);
    feature.setProperties(properties, true);
    return feature;
}
exports.default = RenderFeature;

},{"../Feature.js":"liabO","../geom.js":"8Nc7o","../transform.js":"1BqUf","../extent.js":"6YrVc","../array.js":"1Fbic","../geom/flat/interiorpoint.js":"59VP9","../proj.js":"SznqC","../geom/flat/orient.js":"btd6s","../geom/flat/interpolate.js":"dh8ns","../geom/flat/center.js":"9OVXr","../geom/flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"liabO":[function(require,module,exports) {
/**
 * @module ol/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */ parcelHelpers.export(exports, "createStyleFunction", ()=>createStyleFunction);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _assertsJs = require("./asserts.js");
var _eventsJs = require("./events.js");
/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */ /**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */ /***
 * @template Geometry
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */ /**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */ class Feature extends (0, _objectJsDefault.default) {
    /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */ constructor(geometryOrProperties){
        super();
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {FeatureOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {number|string|undefined}
     */ this.id_ = undefined;
        /**
     * @type {string}
     * @private
     */ this.geometryName_ = "geometry";
        /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */ this.style_ = null;
        /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */ this.styleFunction_ = undefined;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
            if (typeof /** @type {?} */ geometryOrProperties.getSimplifiedGeometry === "function") {
                const geometry = /** @type {Geometry} */ geometryOrProperties;
                this.setGeometry(geometry);
            } else {
                /** @type {Object<string, *>} */ const properties = geometryOrProperties;
                this.setProperties(properties);
            }
        }
    }
    /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */ clone() {
        const clone = /** @type {Feature<Geometry>} */ new Feature(this.hasProperties() ? this.getProperties() : null);
        clone.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) clone.setGeometry(/** @type {Geometry} */ geometry.clone());
        const style = this.getStyle();
        if (style) clone.setStyle(style);
        return clone;
    }
    /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */ getGeometry() {
        return /** @type {Geometry|undefined} */ this.get(this.geometryName_);
    }
    /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */ getId() {
        return this.id_;
    }
    /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */ getGeometryName() {
        return this.geometryName_;
    }
    /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @private
   */ handleGeometryChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
            (0, _eventsJs.unlistenByKey)(this.geometryChangeKey_);
            this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) this.geometryChangeKey_ = (0, _eventsJs.listen)(geometry, (0, _eventTypeJsDefault.default).CHANGE, this.handleGeometryChange_, this);
        this.changed();
    }
    /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */ setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
    }
    /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? undefined : createStyleFunction(style);
        this.changed();
    }
    /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setId(id) {
        this.id_ = id;
        this.changed();
    }
    /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */ setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
    }
}
function createStyleFunction(obj) {
    if (typeof obj === "function") return obj;
    else {
        /**
     * @type {Array<import("./style/Style.js").default>}
     */ let styles;
        if (Array.isArray(obj)) styles = obj;
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ obj.getZIndex === "function", 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
            const style = /** @type {import("./style/Style.js").default} */ obj;
            styles = [
                style
            ];
        }
        return function() {
            return styles;
        };
    }
}
exports.default = Feature;

},{"./Object.js":"1zG8z","./events/EventType.js":"hrQJ6","./asserts.js":"e4TiF","./events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Nc7o":[function(require,module,exports) {
/**
 * @module ol/geom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Circle", ()=>(0, _circleJsDefault.default));
parcelHelpers.export(exports, "Geometry", ()=>(0, _geometryJsDefault.default));
parcelHelpers.export(exports, "GeometryCollection", ()=>(0, _geometryCollectionJsDefault.default));
parcelHelpers.export(exports, "LinearRing", ()=>(0, _linearRingJsDefault.default));
parcelHelpers.export(exports, "LineString", ()=>(0, _lineStringJsDefault.default));
parcelHelpers.export(exports, "MultiLineString", ()=>(0, _multiLineStringJsDefault.default));
parcelHelpers.export(exports, "MultiPoint", ()=>(0, _multiPointJsDefault.default));
parcelHelpers.export(exports, "MultiPolygon", ()=>(0, _multiPolygonJsDefault.default));
parcelHelpers.export(exports, "Point", ()=>(0, _pointJsDefault.default));
parcelHelpers.export(exports, "Polygon", ()=>(0, _polygonJsDefault.default));
parcelHelpers.export(exports, "SimpleGeometry", ()=>(0, _simpleGeometryJsDefault.default));
var _circleJs = require("./geom/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _geometryJs = require("./geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryCollectionJs = require("./geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _linearRingJs = require("./geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _lineStringJs = require("./geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _multiLineStringJs = require("./geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("./geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("./geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("./geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("./geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _simpleGeometryJs = require("./geom/SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);

},{"./geom/Circle.js":false,"./geom/Geometry.js":"4ya62","./geom/GeometryCollection.js":"fDMaj","./geom/LinearRing.js":"jg1hj","./geom/LineString.js":"jLUiq","./geom/MultiLineString.js":"030lt","./geom/MultiPoint.js":"k4LcJ","./geom/MultiPolygon.js":"2XIqx","./geom/Point.js":"hx2Ar","./geom/Polygon.js":"cJuQF","./geom/SimpleGeometry.js":"hLwk3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ya62":[function(require,module,exports) {
/**
 * @module ol/geom/Geometry
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _utilJs = require("../util.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _functionsJs = require("../functions.js");
var _transformJs1 = require("./flat/transform.js");
/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */ /**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */ /**
 * @type {import("../transform.js").Transform}
 */ const tmpTransform = (0, _transformJs.create)();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */ class Geometry extends (0, _objectJsDefault.default) {
    constructor(){
        super();
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {number}
     */ this.extentRevision_ = -1;
        /**
     * @protected
     * @type {number}
     */ this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        /**
     * @protected
     * @type {number}
     */ this.simplifiedGeometryRevision = 0;
        /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */ this.simplifyTransformedInternal = (0, _functionsJs.memoizeOne)(function(revision, squaredTolerance, transform) {
            if (!transform) return this.getSimplifiedGeometry(squaredTolerance);
            const clone = this.clone();
            clone.applyTransform(transform);
            return clone.getSimplifiedGeometry(squaredTolerance);
        });
    }
    /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */ simplifyTransformed(squaredTolerance, transform) {
        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);
    }
    /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */ clone() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const coord = this.getClosestPoint([
            x,
            y
        ]);
        return coord[0] === x && coord[1] === y;
    }
    /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */ getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [
            NaN,
            NaN
        ];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
    }
    /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */ intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
    }
    /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */ getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
            const extent1 = this.computeExtent(this.extent_);
            if (isNaN(extent1[0]) || isNaN(extent1[1])) (0, _extentJs.createOrUpdateEmpty)(extent1);
            this.extentRevision_ = this.getRevision();
        }
        return (0, _extentJs.returnOrUpdate)(this.extent_, extent);
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        (0, _utilJs.abstract)();
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        (0, _utilJs.abstract)();
    }
    /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */ simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */ getType() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */ applyTransform(transformFn) {
        (0, _utilJs.abstract)();
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */ intersectsExtent(extent) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        (0, _utilJs.abstract)();
    }
    /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */ transform(source, destination) {
        /** @type {import("../proj/Projection.js").default} */ const sourceProj = (0, _projJs.get)(source);
        const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
            const pixelExtent = sourceProj.getExtent();
            const projectedExtent = sourceProj.getWorldExtent();
            const scale = (0, _extentJs.getHeight)(projectedExtent) / (0, _extentJs.getHeight)(pixelExtent);
            (0, _transformJs.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            (0, _transformJs1.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
            return (0, _projJs.getTransform)(sourceProj, destination)(inCoordinates, outCoordinates, stride);
        } : (0, _projJs.getTransform)(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
    }
}
exports.default = Geometry;

},{"../Object.js":"1zG8z","../util.js":"pLBjQ","../transform.js":"1BqUf","../extent.js":"6YrVc","../proj.js":"SznqC","../functions.js":"iqv8I","./flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1BqUf":[function(require,module,exports) {
/**
 * @module ol/transform
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */ parcelHelpers.export(exports, "create", ()=>create);
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */ parcelHelpers.export(exports, "reset", ()=>reset);
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */ parcelHelpers.export(exports, "multiply", ()=>multiply);
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */ parcelHelpers.export(exports, "set", ()=>set);
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */ parcelHelpers.export(exports, "setFromArray", ()=>setFromArray);
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */ parcelHelpers.export(exports, "apply", ()=>apply);
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */ parcelHelpers.export(exports, "makeScale", ()=>makeScale);
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */ parcelHelpers.export(exports, "translate", ()=>translate);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */ parcelHelpers.export(exports, "compose", ()=>compose);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */ parcelHelpers.export(exports, "composeCssTransform", ()=>composeCssTransform);
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */ parcelHelpers.export(exports, "invert", ()=>invert);
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */ parcelHelpers.export(exports, "makeInverse", ()=>makeInverse);
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */ parcelHelpers.export(exports, "determinant", ()=>determinant);
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
var _hasJs = require("./has.js");
var _assertsJs = require("./asserts.js");
/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */ /**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */ /**
 * @private
 * @type {Transform}
 */ const tmp_ = new Array(6);
function create() {
    return [
        1,
        0,
        0,
        1,
        0,
        0
    ];
}
function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
    const a1 = transform1[0];
    const b1 = transform1[1];
    const c1 = transform1[2];
    const d1 = transform1[3];
    const e1 = transform1[4];
    const f1 = transform1[5];
    const a2 = transform2[0];
    const b2 = transform2[1];
    const c2 = transform2[2];
    const d2 = transform2[3];
    const e2 = transform2[4];
    const f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
}
function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
}
function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
}
function apply(transform, coordinate) {
    const x = coordinate[0];
    const y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
}
function rotate(transform, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
    return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
    return makeInverse(source, source);
}
function makeInverse(target, source) {
    const det = determinant(source);
    (0, _assertsJs.assert)(det !== 0, 32); // Transformation matrix cannot be inverted
    const a = source[0];
    const b = source[1];
    const c = source[2];
    const d = source[3];
    const e = source[4];
    const f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
}
function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */ let transformStringDiv;
function toString(mat) {
    const transformString = "matrix(" + mat.join(", ") + ")";
    if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) return transformString;
    const node = transformStringDiv || (transformStringDiv = document.createElement("div"));
    node.style.transform = transformString;
    return node.style.transform;
}

},{"./has.js":"6BDNi","./asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"SznqC":[function(require,module,exports) {
/**
 * @module ol/proj
 */ /**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */ /**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */ parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>(0, _unitsJs.METERS_PER_UNIT));
parcelHelpers.export(exports, "Projection", ()=>(0, _projectionJsDefault.default));
/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */ parcelHelpers.export(exports, "disableCoordinateWarning", ()=>disableCoordinateWarning);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */ parcelHelpers.export(exports, "cloneTransform", ()=>cloneTransform);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */ parcelHelpers.export(exports, "identityTransform", ()=>identityTransform);
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */ parcelHelpers.export(exports, "addProjection", ()=>addProjection);
/**
 * @param {Array<Projection>} projections Projections.
 */ parcelHelpers.export(exports, "addProjections", ()=>addProjections);
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */ parcelHelpers.export(exports, "get", ()=>get);
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */ parcelHelpers.export(exports, "getPointResolution", ()=>getPointResolution);
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */ parcelHelpers.export(exports, "addEquivalentProjections", ()=>addEquivalentProjections);
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */ parcelHelpers.export(exports, "addEquivalentTransforms", ()=>addEquivalentTransforms);
/**
 * Clear all cached projections and transforms.
 */ parcelHelpers.export(exports, "clearAllProjections", ()=>clearAllProjections);
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */ parcelHelpers.export(exports, "createProjection", ()=>createProjection);
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "createTransformFromCoordinateTransform", ()=>createTransformFromCoordinateTransform);
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */ parcelHelpers.export(exports, "addCoordinateTransforms", ()=>addCoordinateTransforms);
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */ parcelHelpers.export(exports, "fromLonLat", ()=>fromLonLat);
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */ parcelHelpers.export(exports, "toLonLat", ()=>toLonLat);
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */ parcelHelpers.export(exports, "equivalent", ()=>equivalent);
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "getTransformFromProjections", ()=>getTransformFromProjections);
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */ parcelHelpers.export(exports, "getTransform", ()=>getTransform);
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "transform", ()=>transform);
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */ parcelHelpers.export(exports, "transformExtent", ()=>transformExtent);
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */ parcelHelpers.export(exports, "transformWithProjections", ()=>transformWithProjections);
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */ parcelHelpers.export(exports, "setUserProjection", ()=>setUserProjection);
/**
 * Clear the user projection if set.
 * @api
 */ parcelHelpers.export(exports, "clearUserProjection", ()=>clearUserProjection);
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */ parcelHelpers.export(exports, "getUserProjection", ()=>getUserProjection);
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API
 * methods except for those interacting with tile grids.
 * @api
 */ parcelHelpers.export(exports, "useGeographic", ()=>useGeographic);
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */ parcelHelpers.export(exports, "toUserCoordinate", ()=>toUserCoordinate);
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */ parcelHelpers.export(exports, "fromUserCoordinate", ()=>fromUserCoordinate);
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */ parcelHelpers.export(exports, "toUserExtent", ()=>toUserExtent);
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */ parcelHelpers.export(exports, "fromUserExtent", ()=>fromUserExtent);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */ parcelHelpers.export(exports, "toUserResolution", ()=>toUserResolution);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */ parcelHelpers.export(exports, "fromUserResolution", ()=>fromUserResolution);
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
 */ parcelHelpers.export(exports, "createSafeCoordinateTransform", ()=>createSafeCoordinateTransform);
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */ parcelHelpers.export(exports, "addCommon", ()=>addCommon);
var _projectionJs = require("./proj/Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
var _epsg3857Js = require("./proj/epsg3857.js");
var _epsg4326Js = require("./proj/epsg4326.js");
var _unitsJs = require("./proj/Units.js");
var _projectionsJs = require("./proj/projections.js");
var _transformsJs = require("./proj/transforms.js");
var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _coordinateJs = require("./coordinate.js");
var _sphereJs = require("./sphere.js");
let showCoordinateWarning = true;
function disableCoordinateWarning(disable) {
    const hide = disable === undefined ? true : disable;
    showCoordinateWarning = !hide;
}
function cloneTransform(input, output, dimension) {
    if (output !== undefined) {
        for(let i = 0, ii = input.length; i < ii; ++i)output[i] = input[i];
        output;
    } else output = input.slice();
    return output;
}
function identityTransform(input, output, dimension) {
    if (output !== undefined && input !== output) {
        for(let i = 0, ii = input.length; i < ii; ++i)output[i] = input[i];
        input = output;
    }
    return input;
}
function addProjection(projection) {
    (0, _projectionsJs.add)(projection.getCode(), projection);
    (0, _transformsJs.add)(projection, projection, cloneTransform);
}
function addProjections(projections) {
    projections.forEach(addProjection);
}
function get(projectionLike) {
    return typeof projectionLike === "string" ? (0, _projectionsJs.get)(/** @type {string} */ projectionLike) : /** @type {Projection} */ projectionLike || null;
}
function getPointResolution(projection, resolution, point, units) {
    projection = get(projection);
    let pointResolution;
    const getter = projection.getPointResolutionFunc();
    if (getter) {
        pointResolution = getter(resolution, point);
        if (units && units !== projection.getUnits()) {
            const metersPerUnit = projection.getMetersPerUnit();
            if (metersPerUnit) pointResolution = pointResolution * metersPerUnit / (0, _unitsJs.METERS_PER_UNIT)[units];
        }
    } else {
        const projUnits = projection.getUnits();
        if (projUnits == "degrees" && !units || units == "degrees") pointResolution = resolution;
        else {
            // Estimate point resolution by transforming the center pixel to EPSG:4326,
            // measuring its width and height on the normal sphere, and taking the
            // average of the width and height.
            const toEPSG4326 = getTransformFromProjections(projection, get("EPSG:4326"));
            if (toEPSG4326 === identityTransform && projUnits !== "degrees") // no transform is available
            pointResolution = resolution * projection.getMetersPerUnit();
            else {
                let vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2
                ];
                vertices = toEPSG4326(vertices, vertices, 2);
                const width = (0, _sphereJs.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
                const height = (0, _sphereJs.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
            }
            const metersPerUnit1 = units ? (0, _unitsJs.METERS_PER_UNIT)[units] : projection.getMetersPerUnit();
            if (metersPerUnit1 !== undefined) pointResolution /= metersPerUnit1;
        }
    }
    return pointResolution;
}
function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function(source) {
        projections.forEach(function(destination) {
            if (source !== destination) (0, _transformsJs.add)(source, destination, cloneTransform);
        });
    });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function(projection1) {
        projections2.forEach(function(projection2) {
            (0, _transformsJs.add)(projection1, projection2, forwardTransform);
            (0, _transformsJs.add)(projection2, projection1, inverseTransform);
        });
    });
}
function clearAllProjections() {
    (0, _projectionsJs.clear)();
    (0, _transformsJs.clear)();
}
function createProjection(projection, defaultCode) {
    if (!projection) return get(defaultCode);
    else if (typeof projection === "string") return get(projection);
    else return /** @type {Projection} */ projection;
}
function createTransformFromCoordinateTransform(coordTransform) {
    return(/**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */ function(input, output, dimension) {
        const length = input.length;
        dimension = dimension !== undefined ? dimension : 2;
        output = output !== undefined ? output : new Array(length);
        for(let i = 0; i < length; i += dimension){
            const point = coordTransform(input.slice(i, i + dimension));
            const pointLength = point.length;
            for(let j = 0, jj = dimension; j < jj; ++j)output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
        return output;
    });
}
function addCoordinateTransforms(source, destination, forward, inverse) {
    const sourceProj = get(source);
    const destProj = get(destination);
    (0, _transformsJs.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
    (0, _transformsJs.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
function fromLonLat(coordinate, projection) {
    disableCoordinateWarning();
    return transform(coordinate, "EPSG:4326", projection !== undefined ? projection : "EPSG:3857");
}
function toLonLat(coordinate, projection) {
    const lonLat = transform(coordinate, projection !== undefined ? projection : "EPSG:3857", "EPSG:4326");
    const lon = lonLat[0];
    if (lon < -180 || lon > 180) lonLat[0] = (0, _mathJs.modulo)(lon + 180, 360) - 180;
    return lonLat;
}
function equivalent(projection1, projection2) {
    if (projection1 === projection2) return true;
    const equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) return equalUnits;
    else {
        const transformFunc = getTransformFromProjections(projection1, projection2);
        return transformFunc === cloneTransform && equalUnits;
    }
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
    const sourceCode = sourceProjection.getCode();
    const destinationCode = destinationProjection.getCode();
    let transformFunc = (0, _transformsJs.get)(sourceCode, destinationCode);
    if (!transformFunc) transformFunc = identityTransform;
    return transformFunc;
}
function getTransform(source, destination) {
    const sourceProjection = get(source);
    const destinationProjection = get(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
    const transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, undefined, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
    const transformFunc = getTransform(source, destination);
    return (0, _extentJs.applyTransform)(extent, transformFunc, undefined, stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
    const transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
    return transformFunc(point);
}
/**
 * @type {Projection|null}
 */ let userProjection = null;
function setUserProjection(projection) {
    userProjection = get(projection);
}
function clearUserProjection() {
    userProjection = null;
}
function getUserProjection() {
    return userProjection;
}
function useGeographic() {
    setUserProjection("EPSG:4326");
}
function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) return coordinate;
    return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) {
        if (showCoordinateWarning && !(0, _coordinateJs.equals)(coordinate, [
            0,
            0
        ]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
            showCoordinateWarning = false;
            // eslint-disable-next-line no-console
            console.warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.");
        }
        return coordinate;
    }
    return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) return resolution;
    const sourceUnits = get(sourceProjection).getUnits();
    const userUnits = userProjection.getUnits();
    return sourceUnits && userUnits ? resolution * (0, _unitsJs.METERS_PER_UNIT)[sourceUnits] / (0, _unitsJs.METERS_PER_UNIT)[userUnits] : resolution;
}
function fromUserResolution(resolution, destProjection) {
    if (!userProjection) return resolution;
    const sourceUnits = get(destProjection).getUnits();
    const userUnits = userProjection.getUnits();
    return sourceUnits && userUnits ? resolution * (0, _unitsJs.METERS_PER_UNIT)[userUnits] / (0, _unitsJs.METERS_PER_UNIT)[sourceUnits] : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
    return function(coord) {
        let transformed, worldsAway;
        if (sourceProj.canWrapX()) {
            const sourceExtent = sourceProj.getExtent();
            const sourceExtentWidth = (0, _extentJs.getWidth)(sourceExtent);
            coord = coord.slice(0);
            worldsAway = (0, _coordinateJs.getWorldsAway)(coord, sourceProj, sourceExtentWidth);
            if (worldsAway) // Move x to the real world
            coord[0] = coord[0] - worldsAway * sourceExtentWidth;
            coord[0] = (0, _mathJs.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
            coord[1] = (0, _mathJs.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
            transformed = transform(coord);
        } else transformed = transform(coord);
        if (worldsAway && destProj.canWrapX()) // Move transformed coordinate back to the offset world
        transformed[0] += worldsAway * (0, _extentJs.getWidth)(destProj.getExtent());
        return transformed;
    };
}
function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections((0, _epsg3857Js.PROJECTIONS));
    addEquivalentProjections((0, _epsg4326Js.PROJECTIONS));
    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.
    addEquivalentTransforms((0, _epsg4326Js.PROJECTIONS), (0, _epsg3857Js.PROJECTIONS), (0, _epsg3857Js.fromEPSG4326), (0, _epsg3857Js.toEPSG4326));
}
addCommon();

},{"./proj/Projection.js":"7HvLt","./proj/epsg3857.js":"3MTbx","./proj/epsg4326.js":"6Thur","./proj/Units.js":"gOgy6","./proj/projections.js":"9svUu","./proj/transforms.js":"gPHoN","./extent.js":"6YrVc","./math.js":"5jEFr","./coordinate.js":"85Vu7","./sphere.js":"eJjHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7HvLt":[function(require,module,exports) {
/**
 * @module ol/proj/Projection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _unitsJs = require("./Units.js");
/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */ /**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */ class Projection {
    /**
   * @param {Options} options Projection options.
   */ constructor(options){
        /**
     * @private
     * @type {string}
     */ this.code_ = options.code;
        /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */ this.units_ = /** @type {import("./Units.js").Units} */ options.units;
        /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = options.extent !== undefined ? options.extent : null;
        /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
        /**
     * @private
     * @type {string}
     */ this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : "enu";
        /**
     * @private
     * @type {boolean}
     */ this.global_ = options.global !== undefined ? options.global : false;
        /**
     * @private
     * @type {boolean}
     */ this.canWrapX_ = !!(this.global_ && this.extent_);
        /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */ this.getPointResolutionFunc_ = options.getPointResolution;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.defaultTileGrid_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */ canWrapX() {
        return this.canWrapX_;
    }
    /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */ getCode() {
        return this.code_;
    }
    /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        return this.extent_;
    }
    /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */ getUnits() {
        return this.units_;
    }
    /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */ getMetersPerUnit() {
        return this.metersPerUnit_ || (0, _unitsJs.METERS_PER_UNIT)[this.units_];
    }
    /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getWorldExtent() {
        return this.worldExtent_;
    }
    /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */ getAxisOrientation() {
        return this.axisOrientation_;
    }
    /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */ isGlobal() {
        return this.global_;
    }
    /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */ setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
    }
    /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */ getDefaultTileGrid() {
        return this.defaultTileGrid_;
    }
    /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */ setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
    }
    /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
    }
    /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */ setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
    }
    /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */ setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
    }
    /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */ getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
    }
}
exports.default = Projection;

},{"./Units.js":"gOgy6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gOgy6":[function(require,module,exports) {
/**
 * @module ol/proj/Units
 */ /**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */ /**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */ parcelHelpers.export(exports, "fromCode", ()=>fromCode);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT);
const unitByCode = {
    "9001": "m",
    "9002": "ft",
    "9003": "us-ft",
    "9101": "radians",
    "9102": "degrees"
};
function fromCode(code) {
    return unitByCode[code];
}
const METERS_PER_UNIT = {
    // use the radius of the Normal sphere
    "radians": 6370997 / (2 * Math.PI),
    "degrees": 2 * Math.PI * 6370997 / 360,
    "ft": 0.3048,
    "m": 1,
    "us-ft": 1200 / 3937
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MTbx":[function(require,module,exports) {
/**
 * @module ol/proj/epsg3857
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS);
parcelHelpers.export(exports, "HALF_SIZE", ()=>HALF_SIZE);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT);
parcelHelpers.export(exports, "WORLD_EXTENT", ()=>WORLD_EXTENT);
parcelHelpers.export(exports, "MAX_SAFE_Y", ()=>MAX_SAFE_Y);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS);
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "fromEPSG4326", ()=>fromEPSG4326);
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "toEPSG4326", ()=>toEPSG4326);
var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
const RADIUS = 6378137;
const HALF_SIZE = Math.PI * RADIUS;
const EXTENT = [
    -HALF_SIZE,
    -HALF_SIZE,
    HALF_SIZE,
    HALF_SIZE
];
const WORLD_EXTENT = [
    -180,
    -85,
    180,
    85
];
const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */ class EPSG3857Projection extends (0, _projectionJsDefault.default) {
    /**
   * @param {string} code Code.
   */ constructor(code){
        super({
            code: code,
            units: "m",
            extent: EXTENT,
            global: true,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function(resolution, point) {
                return resolution / Math.cosh(point[1] / RADIUS);
            }
        });
    }
}
const PROJECTIONS = [
    new EPSG3857Projection("EPSG:3857"),
    new EPSG3857Projection("EPSG:102100"),
    new EPSG3857Projection("EPSG:102113"),
    new EPSG3857Projection("EPSG:900913"),
    new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
    new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(let i = 0; i < length; i += dimension){
        output[i] = HALF_SIZE * input[i] / 180;
        let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
        if (y > MAX_SAFE_Y) y = MAX_SAFE_Y;
        else if (y < -MAX_SAFE_Y) y = -MAX_SAFE_Y;
        output[i + 1] = y;
    }
    return output;
}
function toEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(let i = 0; i < length; i += dimension){
        output[i] = 180 * input[i] / HALF_SIZE;
        output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
    }
    return output;
}

},{"./Projection.js":"7HvLt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Thur":[function(require,module,exports) {
/**
 * @module ol/proj/epsg4326
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS);
var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
const RADIUS = 6378137;
const EXTENT = [
    -180,
    -90,
    180,
    90
];
const METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */ class EPSG4326Projection extends (0, _projectionJsDefault.default) {
    /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */ constructor(code, axisOrientation){
        super({
            code: code,
            units: "degrees",
            extent: EXTENT,
            axisOrientation: axisOrientation,
            global: true,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: EXTENT
        });
    }
}
const PROJECTIONS = [
    new EPSG4326Projection("CRS:84"),
    new EPSG4326Projection("EPSG:4326", "neu"),
    new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
    new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
    new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
    new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
    new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];

},{"./Projection.js":"7HvLt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9svUu":[function(require,module,exports) {
/**
 * @module ol/proj/projections
 */ /**
 * @type {Object<string, import("./Projection.js").default>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the projections cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */ parcelHelpers.export(exports, "get", ()=>get);
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */ parcelHelpers.export(exports, "add", ()=>add);
let cache = {};
function clear() {
    cache = {};
}
function get(code) {
    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add(code, projection) {
    cache[code] = projection;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gPHoN":[function(require,module,exports) {
/**
 * @module ol/proj/transforms
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the transform cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */ parcelHelpers.export(exports, "add", ()=>add);
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */ parcelHelpers.export(exports, "remove", ()=>remove);
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */ parcelHelpers.export(exports, "get", ()=>get);
var _objJs = require("../obj.js");
/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */ let transforms = {};
function clear() {
    transforms = {};
}
function add(source, destination, transformFn) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) transforms[sourceCode] = {};
    transforms[sourceCode][destinationCode] = transformFn;
}
function remove(source, destination) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    const transform = transforms[sourceCode][destinationCode];
    delete transforms[sourceCode][destinationCode];
    if ((0, _objJs.isEmpty)(transforms[sourceCode])) delete transforms[sourceCode];
    return transform;
}
function get(sourceCode, destinationCode) {
    let transform;
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) transform = transforms[sourceCode][destinationCode];
    return transform;
}

},{"../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"85Vu7":[function(require,module,exports) {
/**
 * @module ol/coordinate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */ /**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */ /**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */ parcelHelpers.export(exports, "add", ()=>add);
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */ parcelHelpers.export(exports, "closestOnCircle", ()=>closestOnCircle);
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */ parcelHelpers.export(exports, "closestOnSegment", ()=>closestOnSegment);
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */ parcelHelpers.export(exports, "createStringXY", ()=>createStringXY);
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */ parcelHelpers.export(exports, "degreesToStringHDMS", ()=>degreesToStringHDMS);
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */ parcelHelpers.export(exports, "format", ()=>format);
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "distance", ()=>distance);
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */ parcelHelpers.export(exports, "squaredDistanceToSegment", ()=>squaredDistanceToSegment);
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */ parcelHelpers.export(exports, "toStringHDMS", ()=>toStringHDMS);
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */ parcelHelpers.export(exports, "toStringXY", ()=>toStringXY);
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */ parcelHelpers.export(exports, "getWorldsAway", ()=>getWorldsAway);
var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _stringJs = require("./string.js");
function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
}
function closestOnCircle(coordinate, circle) {
    const r = circle.getRadius();
    const center = circle.getCenter();
    const x0 = center[0];
    const y0 = center[1];
    const x1 = coordinate[0];
    const y1 = coordinate[1];
    let dx = x1 - x0;
    const dy = y1 - y0;
    if (dx === 0 && dy === 0) dx = 1;
    const d = Math.sqrt(dx * dx + dy * dy);
    const x = x0 + r * dx / d;
    const y = y0 + r * dy / d;
    return [
        x,
        y
    ];
}
function closestOnSegment(coordinate, segment) {
    const x0 = coordinate[0];
    const y0 = coordinate[1];
    const start = segment[0];
    const end = segment[1];
    const x1 = start[0];
    const y1 = start[1];
    const x2 = end[0];
    const y2 = end[1];
    const dx = x2 - x1;
    const dy = y2 - y1;
    const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    let x, y;
    if (along <= 0) {
        x = x1;
        y = y1;
    } else if (along >= 1) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return [
        x,
        y
    ];
}
function createStringXY(fractionDigits) {
    return(/**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */ function(coordinate) {
        return toStringXY(coordinate, fractionDigits);
    });
}
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
    const normalizedDegrees = (0, _mathJs.modulo)(degrees + 180, 360) - 180;
    const x = Math.abs(3600 * normalizedDegrees);
    const decimals = fractionDigits || 0;
    let deg = Math.floor(x / 3600);
    let min = Math.floor((x - deg * 3600) / 60);
    let sec = (0, _mathJs.toFixed)(x - deg * 3600 - min * 60, decimals);
    if (sec >= 60) {
        sec = 0;
        min += 1;
    }
    if (min >= 60) {
        min = 0;
        deg += 1;
    }
    let hdms = deg + "\xb0";
    if (min !== 0 || sec !== 0) hdms += " " + (0, _stringJs.padNumber)(min, 2) + "′";
    if (sec !== 0) hdms += " " + (0, _stringJs.padNumber)(sec, 2, decimals) + "″";
    if (normalizedDegrees !== 0) hdms += " " + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
    return hdms;
}
function format(coordinate, template, fractionDigits) {
    if (coordinate) return template.replace("{x}", coordinate[0].toFixed(fractionDigits)).replace("{y}", coordinate[1].toFixed(fractionDigits));
    else return "";
}
function equals(coordinate1, coordinate2) {
    let equals = true;
    for(let i = coordinate1.length - 1; i >= 0; --i)if (coordinate1[i] != coordinate2[i]) {
        equals = false;
        break;
    }
    return equals;
}
function rotate(coordinate, angle) {
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
}
function scale(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
}
function squaredDistance(coord1, coord2) {
    const dx = coord1[0] - coord2[0];
    const dy = coord1[1] - coord2[1];
    return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
function toStringHDMS(coordinate, fractionDigits) {
    if (coordinate) return degreesToStringHDMS("NS", coordinate[1], fractionDigits) + " " + degreesToStringHDMS("EW", coordinate[0], fractionDigits);
    else return "";
}
function toStringXY(coordinate, fractionDigits) {
    return format(coordinate, "{x}, {y}", fractionDigits);
}
function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
        const worldWidth = (0, _extentJs.getWidth)(projection.getExtent());
        const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
        if (worldsAway) coordinate[0] -= worldsAway * worldWidth;
    }
    return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
    const projectionExtent = projection.getExtent();
    let worldsAway = 0;
    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
        sourceExtentWidth = sourceExtentWidth || (0, _extentJs.getWidth)(projectionExtent);
        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }
    return worldsAway;
}

},{"./extent.js":"6YrVc","./math.js":"5jEFr","./string.js":"fIYwS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fIYwS":[function(require,module,exports) {
/**
 * @module ol/string
 */ /**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "padNumber", ()=>padNumber);
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */ parcelHelpers.export(exports, "compareVersions", ()=>compareVersions);
function padNumber(number, width, precision) {
    const numberString = precision !== undefined ? number.toFixed(precision) : "" + number;
    let decimal = numberString.indexOf(".");
    decimal = decimal === -1 ? numberString.length : decimal;
    return decimal > width ? numberString : new Array(1 + width - decimal).join("0") + numberString;
}
function compareVersions(v1, v2) {
    const s1 = ("" + v1).split(".");
    const s2 = ("" + v2).split(".");
    for(let i = 0; i < Math.max(s1.length, s2.length); i++){
        const n1 = parseInt(s1[i] || "0", 10);
        const n2 = parseInt(s2[i] || "0", 10);
        if (n1 > n2) return 1;
        if (n2 > n1) return -1;
    }
    return 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eJjHw":[function(require,module,exports) {
/**
 * @module ol/sphere
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_RADIUS", ()=>DEFAULT_RADIUS);
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */ parcelHelpers.export(exports, "getDistance", ()=>getDistance);
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */ parcelHelpers.export(exports, "getLength", ()=>getLength);
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea);
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */ parcelHelpers.export(exports, "offset", ()=>offset);
var _mathJs = require("./math.js");
const DEFAULT_RADIUS = 6371008.8;
function getDistance(c1, c2, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, _mathJs.toRadians)(c1[1]);
    const lat2 = (0, _mathJs.toRadians)(c2[1]);
    const deltaLatBy2 = (lat2 - lat1) / 2;
    const deltaLonBy2 = (0, _mathJs.toRadians)(c2[0] - c1[0]) / 2;
    const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */ function getLengthInternal(coordinates, radius) {
    let length = 0;
    for(let i = 0, ii = coordinates.length; i < ii - 1; ++i)length += getDistance(coordinates[i], coordinates[i + 1], radius);
    return length;
}
function getLength(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || "EPSG:3857";
    const type = geometry.getType();
    if (type !== "GeometryCollection") geometry = geometry.clone().transform(projection, "EPSG:4326");
    let length = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case "Point":
        case "MultiPoint":
            break;
        case "LineString":
        case "LinearRing":
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            length = getLengthInternal(coordinates, radius);
            break;
        case "MultiLineString":
        case "Polygon":
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i)length += getLengthInternal(coordinates[i], radius);
            break;
        case "MultiPolygon":
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                for(j = 0, jj = coords.length; j < jj; ++j)length += getLengthInternal(coords[j], radius);
            }
            break;
        case "GeometryCollection":
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i)length += getLength(geometries[i], options);
                break;
            }
        default:
            throw new Error("Unsupported geometry type: " + type);
    }
    return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */ function getAreaInternal(coordinates, radius) {
    let area = 0;
    const len = coordinates.length;
    let x1 = coordinates[len - 1][0];
    let y1 = coordinates[len - 1][1];
    for(let i = 0; i < len; i++){
        const x2 = coordinates[i][0];
        const y2 = coordinates[i][1];
        area += (0, _mathJs.toRadians)(x2 - x1) * (2 + Math.sin((0, _mathJs.toRadians)(y1)) + Math.sin((0, _mathJs.toRadians)(y2)));
        x1 = x2;
        y1 = y2;
    }
    return area * radius * radius / 2.0;
}
function getArea(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || "EPSG:3857";
    const type = geometry.getType();
    if (type !== "GeometryCollection") geometry = geometry.clone().transform(projection, "EPSG:4326");
    let area = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
        case "LinearRing":
            break;
        case "Polygon":
            coordinates = /** @type {import("./geom/Polygon.js").default} */ geometry.getCoordinates();
            area = Math.abs(getAreaInternal(coordinates[0], radius));
            for(i = 1, ii = coordinates.length; i < ii; ++i)area -= Math.abs(getAreaInternal(coordinates[i], radius));
            break;
        case "MultiPolygon":
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                area += Math.abs(getAreaInternal(coords[0], radius));
                for(j = 1, jj = coords.length; j < jj; ++j)area -= Math.abs(getAreaInternal(coords[j], radius));
            }
            break;
        case "GeometryCollection":
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i)area += getArea(geometries[i], options);
                break;
            }
        default:
            throw new Error("Unsupported geometry type: " + type);
    }
    return area;
}
function offset(c1, distance, bearing, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, _mathJs.toRadians)(c1[1]);
    const lon1 = (0, _mathJs.toRadians)(c1[0]);
    const dByR = distance / radius;
    const lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
    const lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
    return [
        (0, _mathJs.toDegrees)(lon),
        (0, _mathJs.toDegrees)(lat)
    ];
}

},{"./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cDA2L":[function(require,module,exports) {
/**
 * @module ol/geom/flat/transform
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transform2D", ()=>transform2D);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "translate", ()=>translate);
function transform2D(flatCoordinates, offset, end, stride, transform, dest) {
    dest = dest ? dest : [];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const x = flatCoordinates[j];
        const y = flatCoordinates[j + 1];
        dest[i++] = transform[0] * x + transform[2] * y + transform[4];
        dest[i++] = transform[1] * x + transform[3] * y + transform[5];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
    dest = dest ? dest : [];
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const deltaX = flatCoordinates[j] - anchorX;
        const deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + deltaX * cos - deltaY * sin;
        dest[i++] = anchorY + deltaX * sin + deltaY * cos;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
    dest = dest ? dest : [];
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const deltaX = flatCoordinates[j] - anchorX;
        const deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + sx * deltaX;
        dest[i++] = anchorY + sy * deltaY;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
    dest = dest ? dest : [];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        dest[i++] = flatCoordinates[j] + deltaX;
        dest[i++] = flatCoordinates[j + 1] + deltaY;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fDMaj":[function(require,module,exports) {
/**
 * @module ol/geom/GeometryCollection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry~Geometry} objects.
 *
 * @api
 */ class GeometryCollection extends (0, _geometryJsDefault.default) {
    /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */ constructor(geometries){
        super();
        /**
     * @private
     * @type {Array<Geometry>}
     */ this.geometries_ = geometries ? geometries : null;
        /**
     * @type {Array<import("../events.js").EventsKey>}
     */ this.changeEventsKeys_ = [];
        this.listenGeometriesChange_();
    }
    /**
   * @private
   */ unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.changeEventsKeys_.length = 0;
    }
    /**
   * @private
   */ listenGeometriesChange_() {
        if (!this.geometries_) return;
        for(let i = 0, ii = this.geometries_.length; i < ii; ++i)this.changeEventsKeys_.push((0, _eventsJs.listen)(this.geometries_[i], (0, _eventTypeJsDefault.default).CHANGE, this.changed, this));
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */ clone() {
        const geometryCollection = new GeometryCollection(null);
        geometryCollection.setGeometries(this.geometries_);
        geometryCollection.applyProperties(this);
        return geometryCollection;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
        return minSquaredDistance;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            if (geometries[i].containsXY(x, y)) return true;
        }
        return false;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        (0, _extentJs.createOrUpdateEmpty)(extent);
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)(0, _extentJs.extend)(extent, geometries[i].getExtent());
        return extent;
    }
    /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */ getGeometries() {
        return cloneGeometries(this.geometries_);
    }
    /**
   * @return {Array<Geometry>} Geometries.
   */ getGeometriesArray() {
        return this.geometries_;
    }
    /**
   * @return {Array<Geometry>} Geometries.
   */ getGeometriesArrayRecursive() {
        /** @type {Array<Geometry>} */ let geometriesArray = [];
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)if (geometries[i].getType() === this.getType()) geometriesArray = geometriesArray.concat(/** @type {GeometryCollection} */ geometries[i].getGeometriesArrayRecursive());
        else geometriesArray.push(geometries[i]);
        return geometriesArray;
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */ getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) return this;
        const simplifiedGeometries = [];
        const geometries = this.geometries_;
        let simplified = false;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            const geometry = geometries[i];
            const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
            simplifiedGeometries.push(simplifiedGeometry);
            if (simplifiedGeometry !== geometry) simplified = true;
        }
        if (simplified) {
            const simplifiedGeometryCollection = new GeometryCollection(null);
            simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
            return simplifiedGeometryCollection;
        } else {
            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
            return this;
        }
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "GeometryCollection";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            if (geometries[i].intersectsExtent(extent)) return true;
        }
        return false;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return this.geometries_.length === 0;
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].rotate(angle, anchor);
        this.changed();
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        if (!anchor) anchor = (0, _extentJs.getCenter)(this.getExtent());
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].scale(sx, sy, anchor);
        this.changed();
    }
    /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */ setGeometries(geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
    }
    /**
   * @param {Array<Geometry>} geometries Geometries.
   */ setGeometriesArray(geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */ applyTransform(transformFn) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].applyTransform(transformFn);
        this.changed();
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].translate(deltaX, deltaY);
        this.changed();
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.unlistenGeometriesChange_();
        super.disposeInternal();
    }
}
/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */ function cloneGeometries(geometries) {
    const clonedGeometries = [];
    for(let i = 0, ii = geometries.length; i < ii; ++i)clonedGeometries.push(geometries[i].clone());
    return clonedGeometries;
}
exports.default = GeometryCollection;

},{"../events/EventType.js":"hrQJ6","./Geometry.js":"4ya62","../extent.js":"6YrVc","../events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jg1hj":[function(require,module,exports) {
/**
 * @module ol/geom/LinearRing
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _inflateJs = require("./flat/inflate.js");
var _areaJs = require("./flat/area.js");
/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */ class LinearRing extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (layout !== undefined && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */ clone() {
        return new LinearRing(this.flatCoordinates.slice(), this.layout);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRing)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LinearRing(simplifiedFlatCoordinates, "XY");
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "LinearRing";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return false;
    }
    /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = LinearRing;

},{"./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","./flat/simplify.js":"jsqc5","./flat/inflate.js":"4Rpju","./flat/area.js":"7fT8A","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hLwk3":[function(require,module,exports) {
/**
 * @module ol/geom/SimpleGeometry
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */ parcelHelpers.export(exports, "getStrideForLayout", ()=>getStrideForLayout);
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */ parcelHelpers.export(exports, "transformGeom2D", ()=>transformGeom2D);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _utilJs = require("../util.js");
var _extentJs = require("../extent.js");
var _transformJs = require("./flat/transform.js");
/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */ class SimpleGeometry extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */ this.layout = "XY";
        /**
     * @protected
     * @type {number}
     */ this.stride = 2;
        /**
     * @protected
     * @type {Array<number>}
     */ this.flatCoordinates = null;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _extentJs.createOrUpdateFromFlatCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }
    /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */ getCoordinates() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */ getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
    }
    /**
   * @return {Array<number>} Flat coordinates.
   */ getFlatCoordinates() {
        return this.flatCoordinates;
    }
    /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */ getLastCoordinate() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
    }
    /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */ getLayout() {
        return this.layout;
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        // If squaredTolerance is negative or if we know that simplification will not
        // have any effect then just return this.
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) return this;
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) return simplifiedGeometry;
        else {
            // Simplification did not actually remove any coordinates.  We now know
            // that any calls to getSimplifiedGeometry with a squaredTolerance less
            // than or equal to the current squaredTolerance will also not have any
            // effect.  This allows us to short circuit simplification (saving CPU
            // cycles) and prevents the cache of simplified geometries from filling
            // up with useless identical copies of this geometry (saving memory).
            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
            return this;
        }
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
    }
    /**
   * @return {number} Stride.
   */ getStride() {
        return this.stride;
    }
    /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */ setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
    }
    /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ setCoordinates(coordinates, layout) {
        (0, _utilJs.abstract)();
    }
    /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */ setLayout(layout, coordinates, nesting) {
        /** @type {number} */ let stride;
        if (layout) stride = getStrideForLayout(layout);
        else {
            for(let i = 0; i < nesting; ++i)if (coordinates.length === 0) {
                this.layout = "XY";
                this.stride = 2;
                return;
            } else coordinates = /** @type {Array} */ coordinates[0];
            stride = coordinates.length;
            layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */ applyTransform(transformFn) {
        if (this.flatCoordinates) {
            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
            this.changed();
        }
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.rotate)(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
            this.changed();
        }
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        if (sy === undefined) sy = sx;
        if (!anchor) anchor = (0, _extentJs.getCenter)(this.getExtent());
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.scale)(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
            this.changed();
        }
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.translate)(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
            this.changed();
        }
    }
}
/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */ function getLayoutForStride(stride) {
    let layout;
    if (stride == 2) layout = "XY";
    else if (stride == 3) layout = "XYZ";
    else if (stride == 4) layout = "XYZM";
    return /** @type {import("./Geometry.js").GeometryLayout} */ layout;
}
function getStrideForLayout(layout) {
    let stride;
    if (layout == "XY") stride = 2;
    else if (layout == "XYZ" || layout == "XYM") stride = 3;
    else if (layout == "XYZM") stride = 4;
    return /** @type {number} */ stride;
}
function transformGeom2D(simpleGeometry, transform, dest) {
    const flatCoordinates = simpleGeometry.getFlatCoordinates();
    if (!flatCoordinates) return null;
    else {
        const stride = simpleGeometry.getStride();
        return (0, _transformJs.transform2D)(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);
    }
}
exports.default = SimpleGeometry;

},{"./Geometry.js":"4ya62","../util.js":"pLBjQ","../extent.js":"6YrVc","./flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fi6H5":[function(require,module,exports) {
/**
 * @module ol/geom/flat/closest
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "maxSquaredDelta", ()=>maxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "arrayMaxSquaredDelta", ()=>arrayMaxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "multiArrayMaxSquaredDelta", ()=>multiArrayMaxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestPoint", ()=>assignClosestPoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestArrayPoint", ()=>assignClosestArrayPoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestMultiArrayPoint", ()=>assignClosestMultiArrayPoint);
var _mathJs = require("../../math.js");
/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */ function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
    const x1 = flatCoordinates[offset1];
    const y1 = flatCoordinates[offset1 + 1];
    const dx = flatCoordinates[offset2] - x1;
    const dy = flatCoordinates[offset2 + 1] - y1;
    let offset;
    if (dx === 0 && dy === 0) offset = offset1;
    else {
        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) offset = offset2;
        else if (t > 0) {
            for(let i = 0; i < stride; ++i)closestPoint[i] = (0, _mathJs.lerp)(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
            closestPoint.length = stride;
            return;
        } else offset = offset1;
    }
    for(let i1 = 0; i1 < stride; ++i1)closestPoint[i1] = flatCoordinates[offset + i1];
    closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    for(offset += stride; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        const squaredDelta = (0, _mathJs.squaredDistance)(x1, y1, x2, y2);
        if (squaredDelta > max) max = squaredDelta;
        x1 = x2;
        y1 = y2;
    }
    return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
        offset = end;
    }
    return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
        offset = ends[ends.length - 1];
    }
    return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    if (offset == end) return minSquaredDistance;
    let i, squaredDistance;
    if (maxDelta === 0) {
        // All points are identical, so just test the first point.
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
        if (squaredDistance < minSquaredDistance) {
            for(i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[offset + i];
            closestPoint.length = stride;
            return squaredDistance;
        } else return minSquaredDistance;
    }
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    let index = offset + stride;
    while(index < end){
        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
            index += stride;
        } else // Skip ahead multiple points, because we know that all the skipped
        // points cannot be any closer than the closest point we have found so
        // far.  We know this because we know how close the current point is, how
        // close the closest point we have found so far is, and the maximum
        // distance between consecutive points.  For example, if we're currently
        // at distance 10, the best we've found so far is 3, and that the maximum
        // distance between consecutive points is 2, then we'll need to skip at
        // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
        // finding a closer point.  We use Math.max(..., 1) to ensure that we
        // always advance at least one point, to avoid an infinite loop.
        index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
    if (isRing) {
        // Check the closing segment.
        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
        }
    }
    return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = end;
    }
    return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = ends[ends.length - 1];
    }
    return minSquaredDistance;
}

},{"../../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3TE5l":[function(require,module,exports) {
/**
 * @module ol/geom/flat/deflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "deflateCoordinate", ()=>deflateCoordinate);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ parcelHelpers.export(exports, "deflateCoordinates", ()=>deflateCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */ parcelHelpers.export(exports, "deflateCoordinatesArray", ()=>deflateCoordinatesArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */ parcelHelpers.export(exports, "deflateMultiCoordinatesArray", ()=>deflateMultiCoordinatesArray);
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
    for(let i = 0, ii = coordinate.length; i < ii; ++i)flatCoordinates[offset++] = coordinate[i];
    return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
    for(let i = 0, ii = coordinates.length; i < ii; ++i){
        const coordinate = coordinates[i];
        for(let j = 0; j < stride; ++j)flatCoordinates[offset++] = coordinate[j];
    }
    return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
    ends = ends ? ends : [];
    let i = 0;
    for(let j = 0, jj = coordinatess.length; j < jj; ++j){
        const end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
        ends[i++] = end;
        offset = end;
    }
    ends.length = i;
    return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
    endss = endss ? endss : [];
    let i = 0;
    for(let j = 0, jj = coordinatesss.length; j < jj; ++j){
        const ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
        if (ends.length === 0) ends[0] = offset;
        endss[i++] = ends;
        offset = ends[ends.length - 1];
    }
    endss.length = i;
    return endss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jsqc5":[function(require,module,exports) {
/**
 * @module ol/geom/flat/simplify
 */ // Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */ parcelHelpers.export(exports, "simplifyLineString", ()=>simplifyLineString);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeucker", ()=>douglasPeucker);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerArray", ()=>douglasPeuckerArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerMultiArray", ()=>douglasPeuckerMultiArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "radialDistance", ()=>radialDistance);
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */ parcelHelpers.export(exports, "snap", ()=>snap);
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantize", ()=>quantize);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeArray", ()=>quantizeArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeMultiArray", ()=>quantizeMultiArray);
var _mathJs = require("../../math.js");
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
    simplifiedFlatCoordinates = simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];
    if (!highQuality) {
        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        flatCoordinates = simplifiedFlatCoordinates;
        offset = 0;
        stride = 2;
    }
    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return simplifiedFlatCoordinates;
}
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    const n = (end - offset) / stride;
    if (n < 3) {
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    /** @type {Array<number>} */ const markers = new Array(n);
    markers[0] = 1;
    markers[n - 1] = 1;
    /** @type {Array<number>} */ const stack = [
        offset,
        end - stride
    ];
    let index = 0;
    while(stack.length > 0){
        const last = stack.pop();
        const first = stack.pop();
        let maxSquaredDistance = 0;
        const x1 = flatCoordinates[first];
        const y1 = flatCoordinates[first + 1];
        const x2 = flatCoordinates[last];
        const y2 = flatCoordinates[last + 1];
        for(let i = first + stride; i < last; i += stride){
            const x = flatCoordinates[i];
            const y = flatCoordinates[i + 1];
            const squaredDistance = (0, _mathJs.squaredSegmentDistance)(x, y, x1, y1, x2, y2);
            if (squaredDistance > maxSquaredDistance) {
                index = i;
                maxSquaredDistance = squaredDistance;
            }
        }
        if (maxSquaredDistance > squaredTolerance) {
            markers[(index - offset) / stride] = 1;
            if (first + stride < index) stack.push(first, index);
            if (index + stride < last) stack.push(index, last);
        }
    }
    for(let i1 = 0; i1 < n; ++i1)if (markers[i1]) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i1 * stride];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i1 * stride + 1];
    }
    return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        const simplifiedEnds = [];
        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}
function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (end <= offset + stride) {
        // zero or one point, no simplification possible, so copy and return
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    // copy first point
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    let x2 = x1;
    let y2 = y1;
    for(offset += stride; offset < end; offset += stride){
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        if ((0, _mathJs.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
            // copy point at offset
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            x1 = x2;
            y1 = y2;
        }
    }
    if (x2 != x1 || y2 != y1) {
        // copy last point
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    }
    return simplifiedOffset;
}
function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    // do nothing if the line is empty
    if (offset == end) return simplifiedOffset;
    // snap the first coordinate (P1)
    let x1 = snap(flatCoordinates[offset], tolerance);
    let y1 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // add the first coordinate to the output
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    // find the next coordinate that does not snap to the same value as the first
    // coordinate (P2)
    let x2, y2;
    do {
        x2 = snap(flatCoordinates[offset], tolerance);
        y2 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        if (offset == end) {
            // all coordinates snap to the same value, the line collapses to a point
            // push the last snapped value anyway to ensure that the output contains
            // at least two points
            // FIXME should we really return at least two points anyway?
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            return simplifiedOffset;
        }
    }while (x2 == x1 && y2 == y1);
    while(offset < end){
        // snap the next coordinate (P3)
        const x3 = snap(flatCoordinates[offset], tolerance);
        const y3 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        // skip P3 if it is equal to P2
        if (x3 == x2 && y3 == y2) continue;
        // calculate the delta between P1 and P2
        const dx1 = x2 - x1;
        const dy1 = y2 - y1;
        // calculate the delta between P3 and P1
        const dx2 = x3 - x1;
        const dy2 = y3 - y1;
        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
        // P1 in the same direction then P2 is on the straight line between P1 and
        // P3
        if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
            // discard P2 and set P2 = P3
            x2 = x3;
            y2 = y3;
            continue;
        }
        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
        // between P3 and P1 or on the opposite half of the line to P2.  add P2,
        // and continue with P1 = P2 and P2 = P3
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        x1 = x2;
        y1 = y2;
        x2 = x3;
        y2 = y3;
    }
    // add the last point (P2)
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        const simplifiedEnds = [];
        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}

},{"../../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Rpju":[function(require,module,exports) {
/**
 * @module ol/geom/flat/inflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inflateCoordinates", ()=>inflateCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */ parcelHelpers.export(exports, "inflateCoordinatesArray", ()=>inflateCoordinatesArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */ parcelHelpers.export(exports, "inflateMultiCoordinatesArray", ()=>inflateMultiCoordinatesArray);
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates) {
    coordinates = coordinates !== undefined ? coordinates : [];
    let i = 0;
    for(let j = offset; j < end; j += stride)coordinates[i++] = flatCoordinates.slice(j, j + stride);
    coordinates.length = i;
    return coordinates;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
    coordinatess = coordinatess !== undefined ? coordinatess : [];
    let i = 0;
    for(let j = 0, jj = ends.length; j < jj; ++j){
        const end = ends[j];
        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
        offset = end;
    }
    coordinatess.length = i;
    return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
    coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
    let i = 0;
    for(let j = 0, jj = endss.length; j < jj; ++j){
        const ends = endss[j];
        coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
        offset = ends[ends.length - 1];
    }
    coordinatesss.length = i;
    return coordinatesss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7fT8A":[function(require,module,exports) {
/**
 * @module ol/geom/flat/area
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linearRing", ()=>linearRing);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRings", ()=>linearRings);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss);
function linearRing(flatCoordinates, offset, end, stride) {
    let twiceArea = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        twiceArea += y1 * x2 - x1 * y2;
        x1 = x2;
        y1 = y2;
    }
    return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
    let area = 0;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        area += linearRing(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return area;
}
function linearRingss(flatCoordinates, offset, endss, stride) {
    let area = 0;
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        area += linearRings(flatCoordinates, offset, ends, stride);
        offset = ends[ends.length - 1];
    }
    return area;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLUiq":[function(require,module,exports) {
/**
 * @module ol/geom/LineString
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _segmentsJs = require("./flat/segments.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _lengthJs = require("./flat/length.js");
/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */ class LineString extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.flatMidpoint_ = null;
        /**
     * @private
     * @type {number}
     */ this.flatMidpointRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (layout !== undefined && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */ appendCoordinate(coordinate) {
        if (!this.flatCoordinates) this.flatCoordinates = coordinate.slice();
        else (0, _arrayJs.extend)(this.flatCoordinates, coordinate);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */ clone() {
        const lineString = new LineString(this.flatCoordinates.slice(), this.layout);
        lineString.applyProperties(this);
        return lineString;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */ forEachSegment(callback) {
        return (0, _segmentsJs.forEach)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
    }
    /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */ getCoordinateAtM(m, extrapolate) {
        if (this.layout != "XYM" && this.layout != "XYZM") return null;
        extrapolate = extrapolate !== undefined ? extrapolate : false;
        return (0, _interpolateJs.lineStringCoordinateAtM)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
    }
    /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */ getCoordinateAt(fraction, dest) {
        return (0, _interpolateJs.interpolatePoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, dest, this.stride);
    }
    /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */ getLength() {
        return (0, _lengthJs.lineStringLength)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * @return {Array<number>} Flat midpoint.
   */ getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
            this.flatMidpointRevision_ = this.getRevision();
        }
        return this.flatMidpoint_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LineString(simplifiedFlatCoordinates, "XY");
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "LineString";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLineString)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }
    /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = LineString;

},{"./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","./flat/simplify.js":"jsqc5","../array.js":"1Fbic","./flat/segments.js":"e7gWa","./flat/inflate.js":"4Rpju","./flat/interpolate.js":"dh8ns","./flat/intersectsextent.js":"7x08H","./flat/length.js":"X5sUU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e7gWa":[function(require,module,exports) {
/**
 * @module ol/geom/flat/segments
 */ /**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "forEach", ()=>forEach);
function forEach(flatCoordinates, offset, end, stride, callback) {
    let ret;
    offset += stride;
    for(; offset < end; offset += stride){
        ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
        if (ret) return ret;
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dh8ns":[function(require,module,exports) {
/**
 * @module ol/geom/flat/interpolate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */ parcelHelpers.export(exports, "interpolatePoint", ()=>interpolatePoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */ parcelHelpers.export(exports, "lineStringCoordinateAtM", ()=>lineStringCoordinateAtM);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */ parcelHelpers.export(exports, "lineStringsCoordinateAtM", ()=>lineStringsCoordinateAtM);
var _arrayJs = require("../../array.js");
var _mathJs = require("../../math.js");
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
    let o, t;
    const n = (end - offset) / stride;
    if (n === 1) o = offset;
    else if (n === 2) {
        o = offset;
        t = fraction;
    } else if (n !== 0) {
        let x1 = flatCoordinates[offset];
        let y1 = flatCoordinates[offset + 1];
        let length = 0;
        const cumulativeLengths = [
            0
        ];
        for(let i = offset + stride; i < end; i += stride){
            const x2 = flatCoordinates[i];
            const y2 = flatCoordinates[i + 1];
            length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            cumulativeLengths.push(length);
            x1 = x2;
            y1 = y2;
        }
        const target = fraction * length;
        const index = (0, _arrayJs.binarySearch)(cumulativeLengths, target);
        if (index < 0) {
            t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
            o = offset + (-index - 2) * stride;
        } else o = offset + index * stride;
    }
    dimension = dimension > 1 ? dimension : 2;
    dest = dest ? dest : new Array(dimension);
    for(let i1 = 0; i1 < dimension; ++i1)dest[i1] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i1] : (0, _mathJs.lerp)(flatCoordinates[o + i1], flatCoordinates[o + stride + i1], t);
    return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) return null;
    let coordinate;
    if (m < flatCoordinates[offset + stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(offset, offset + stride);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    } else if (flatCoordinates[end - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(end - stride, end);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    }
    // FIXME use O(1) search
    if (m == flatCoordinates[offset + stride - 1]) return flatCoordinates.slice(offset, offset + stride);
    let lo = offset / stride;
    let hi = end / stride;
    while(lo < hi){
        const mid = lo + hi >> 1;
        if (m < flatCoordinates[(mid + 1) * stride - 1]) hi = mid;
        else lo = mid + 1;
    }
    const m0 = flatCoordinates[lo * stride - 1];
    if (m == m0) return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    const m1 = flatCoordinates[(lo + 1) * stride - 1];
    const t = (m - m0) / (m1 - m0);
    coordinate = [];
    for(let i = 0; i < stride - 1; ++i)coordinate.push((0, _mathJs.lerp)(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
    coordinate.push(m);
    return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    let coordinate;
    if (m < flatCoordinates[stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(0, stride);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    }
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        if (offset == end) continue;
        if (m < flatCoordinates[offset + stride - 1]) return null;
        else if (m <= flatCoordinates[end - 1]) return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
        offset = end;
    }
    return null;
}

},{"../../array.js":"1Fbic","../../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7x08H":[function(require,module,exports) {
/**
 * @module ol/geom/flat/intersectsextent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineString", ()=>intersectsLineString);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineStringArray", ()=>intersectsLineStringArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRing", ()=>intersectsLinearRing);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingArray", ()=>intersectsLinearRingArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingMultiArray", ()=>intersectsLinearRingMultiArray);
var _extentJs = require("../../extent.js");
var _segmentsJs = require("./segments.js");
var _containsJs = require("./contains.js");
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
    const coordinatesExtent = (0, _extentJs.extendFlatCoordinates)((0, _extentJs.createEmpty)(), flatCoordinates, offset, end, stride);
    if (!(0, _extentJs.intersects)(extent, coordinatesExtent)) return false;
    if ((0, _extentJs.containsExtent)(extent, coordinatesExtent)) return true;
    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) return true;
    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) return true;
    return (0, _segmentsJs.forEach)(flatCoordinates, offset, end, stride, /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */ function(point1, point2) {
        return (0, _extentJs.intersectsSegment)(extent, point1, point2);
    });
}
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) return true;
        offset = ends[i];
    }
    return false;
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[1])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[3])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[1])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[3])) return true;
    return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) return false;
    if (ends.length === 1) return true;
    for(let i = 1, ii = ends.length; i < ii; ++i)if ((0, _containsJs.linearRingContainsExtent)(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) return false;
    }
    return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"6YrVc","./segments.js":"e7gWa","./contains.js":"eArlN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eArlN":[function(require,module,exports) {
/**
 * @module ol/geom/flat/contains
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */ parcelHelpers.export(exports, "linearRingContainsExtent", ()=>linearRingContainsExtent);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingContainsXY", ()=>linearRingContainsXY);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingsContainsXY", ()=>linearRingsContainsXY);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingssContainsXY", ()=>linearRingssContainsXY);
var _extentJs = require("../../extent.js");
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
    const outside = (0, _extentJs.forEachCorner)(extent, /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */ function(coordinate) {
        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
    return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
    // https://geomalgorithms.com/a03-_inclusion.html
    // Copyright 2000 softSurfer, 2012 Dan Sunday
    // This code may be freely used and modified for any purpose
    // providing that this copyright notice is included with it.
    // SoftSurfer makes no warranty for this code, and cannot be held
    // liable for any real or imagined damage resulting from its use.
    // Users of this code must verify correctness for their application.
    let wn = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        if (y1 <= y) {
            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) wn++;
        } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) wn--;
        x1 = x2;
        y1 = y2;
    }
    return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
    if (ends.length === 0) return false;
    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) return false;
    for(let i = 1, ii = ends.length; i < ii; ++i){
        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) return false;
    }
    return true;
}
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
    if (endss.length === 0) return false;
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"6YrVc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"X5sUU":[function(require,module,exports) {
/**
 * @module ol/geom/flat/length
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lineStringLength", ()=>lineStringLength);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */ parcelHelpers.export(exports, "linearRingLength", ()=>linearRingLength);
function lineStringLength(flatCoordinates, offset, end, stride) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    for(let i = offset + stride; i < end; i += stride){
        const x2 = flatCoordinates[i];
        const y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        x1 = x2;
        y1 = y2;
    }
    return length;
}
function linearRingLength(flatCoordinates, offset, end, stride) {
    let perimeter = lineStringLength(flatCoordinates, offset, end, stride);
    const dx = flatCoordinates[end - stride] - flatCoordinates[offset];
    const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
    perimeter += Math.sqrt(dx * dx + dy * dy);
    return perimeter;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"030lt":[function(require,module,exports) {
/**
 * @module ol/geom/MultiLineString
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */ class MultiLineString extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */ constructor(coordinates, layout, ends){
        super();
        /**
     * @type {Array<number>}
     * @private
     */ this.ends_ = [];
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates[0])) this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ coordinates, layout);
        else if (layout !== undefined && ends) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.ends_ = ends;
        } else {
            let layout1 = this.getLayout();
            const lineStrings = /** @type {Array<LineString>} */ coordinates;
            const flatCoordinates = [];
            const ends1 = [];
            for(let i = 0, ii = lineStrings.length; i < ii; ++i){
                const lineString = lineStrings[i];
                if (i === 0) layout1 = lineString.getLayout();
                (0, _arrayJs.extend)(flatCoordinates, lineString.getFlatCoordinates());
                ends1.push(flatCoordinates.length);
            }
            this.setFlatCoordinates(layout1, flatCoordinates);
            this.ends_ = ends1;
        }
    }
    /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */ appendLineString(lineString) {
        if (!this.flatCoordinates) this.flatCoordinates = lineString.getFlatCoordinates().slice();
        else (0, _arrayJs.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */ clone() {
        const multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        multiLineString.applyProperties(this);
        return multiLineString;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */ getCoordinateAtM(m, extrapolate, interpolate) {
        if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) return null;
        extrapolate = extrapolate !== undefined ? extrapolate : false;
        interpolate = interpolate !== undefined ? interpolate : false;
        return (0, _interpolateJs.lineStringsCoordinateAtM)(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
    }
    /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinatesArray)(this.flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */ getLineString(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new (0, _lineStringJsDefault.default)(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */ getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        /** @type {Array<LineString>} */ const lineStrings = [];
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const lineString = new (0, _lineStringJsDefault.default)(flatCoordinates.slice(offset, end), layout);
            lineStrings.push(lineString);
            offset = end;
        }
        return lineStrings;
    }
    /**
   * @return {Array<number>} Flat midpoints.
   */ getFlatMidpoints() {
        const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const midpoint = (0, _interpolateJs.interpolatePoint)(flatCoordinates, offset, end, stride, 0.5);
            (0, _arrayJs.extend)(midpoints, midpoint);
            offset = end;
        }
        return midpoints;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeuckerArray)(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "MultiLineString";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLineStringArray)(this.flatCoordinates, 0, this.ends_, this.stride, extent);
    }
    /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const ends = (0, _deflateJs.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    }
}
exports.default = MultiLineString;

},{"./LineString.js":"jLUiq","./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","./flat/simplify.js":"jsqc5","../array.js":"1Fbic","./flat/inflate.js":"4Rpju","./flat/interpolate.js":"dh8ns","./flat/intersectsextent.js":"7x08H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k4LcJ":[function(require,module,exports) {
/**
 * @module ol/geom/MultiPoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _mathJs = require("../math.js");
/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */ class MultiPoint extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        if (layout && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */ appendPoint(point) {
        if (!this.flatCoordinates) this.flatCoordinates = point.getFlatCoordinates().slice();
        else (0, _arrayJs.extend)(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */ clone() {
        const multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
        multiPoint.applyProperties(this);
        return multiPoint;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
            if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for(let j = 0; j < stride; ++j)closestPoint[j] = flatCoordinates[i + j];
                closestPoint.length = stride;
            }
        }
        return minSquaredDistance;
    }
    /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */ getPoint(index) {
        const n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) return null;
        return new (0, _pointJsDefault.default)(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
    }
    /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */ getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        /** @type {Array<Point>} */ const points = [];
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const point = new (0, _pointJsDefault.default)(flatCoordinates.slice(i, i + stride), layout);
            points.push(point);
        }
        return points;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "MultiPoint";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const x = flatCoordinates[i];
            const y = flatCoordinates[i + 1];
            if ((0, _extentJs.containsXY)(extent, x, y)) return true;
        }
        return false;
    }
    /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = MultiPoint;

},{"./Point.js":"hx2Ar","./SimpleGeometry.js":"hLwk3","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../array.js":"1Fbic","./flat/inflate.js":"4Rpju","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hx2Ar":[function(require,module,exports) {
/**
 * @module ol/geom/Point
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _mathJs = require("../math.js");
/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */ class Point extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        this.setCoordinates(coordinates, layout);
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */ clone() {
        const point = new Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[0], flatCoordinates[1]);
        if (squaredDistance < minSquaredDistance) {
            const stride = this.stride;
            for(let i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[i];
            closestPoint.length = stride;
            return squaredDistance;
        } else return minSquaredDistance;
    }
    /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */ getCoordinates() {
        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _extentJs.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "Point";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _extentJs.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 0);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinate)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = Point;

},{"./SimpleGeometry.js":"hLwk3","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2XIqx":[function(require,module,exports) {
/**
 * @module ol/geom/MultiPolygon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _multiPointJs = require("./MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _polygonJs = require("./Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _centerJs = require("./flat/center.js");
var _containsJs = require("./flat/contains.js");
var _simplifyJs = require("./flat/simplify.js");
/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */ class MultiPolygon extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */ constructor(coordinates, layout, endss){
        super();
        /**
     * @type {Array<Array<number>>}
     * @private
     */ this.endss_ = [];
        /**
     * @private
     * @type {number}
     */ this.flatInteriorPointsRevision_ = -1;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatInteriorPoints_ = null;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.orientedRevision_ = -1;
        /**
     * @private
     * @type {Array<number>}
     */ this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates[0])) {
            let thisLayout = this.getLayout();
            const polygons = /** @type {Array<Polygon>} */ coordinates;
            const flatCoordinates = [];
            const thisEndss = [];
            for(let i = 0, ii = polygons.length; i < ii; ++i){
                const polygon = polygons[i];
                if (i === 0) thisLayout = polygon.getLayout();
                const offset = flatCoordinates.length;
                const ends = polygon.getEnds();
                for(let j = 0, jj = ends.length; j < jj; ++j)ends[j] += offset;
                (0, _arrayJs.extend)(flatCoordinates, polygon.getFlatCoordinates());
                thisEndss.push(ends);
            }
            layout = thisLayout;
            coordinates = flatCoordinates;
            endss = thisEndss;
        }
        if (layout !== undefined && endss) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.endss_ = endss;
        } else this.setCoordinates(/** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ coordinates, layout);
    }
    /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */ appendPolygon(polygon) {
        /** @type {Array<number>} */ let ends;
        if (!this.flatCoordinates) {
            this.flatCoordinates = polygon.getFlatCoordinates().slice();
            ends = polygon.getEnds().slice();
            this.endss_.push();
        } else {
            const offset = this.flatCoordinates.length;
            (0, _arrayJs.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
            ends = polygon.getEnds().slice();
            for(let i = 0, ii = ends.length; i < ii; ++i)ends[i] += offset;
        }
        this.endss_.push(ends);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */ clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for(let i = 0; i < len; ++i)newEndss[i] = this.endss_[i].slice();
        const multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
        multiPolygon.applyProperties(this);
        return multiPolygon;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        return (0, _containsJs.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
    }
    /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    }
    /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */ getCoordinates(right) {
        let flatCoordinates;
        if (right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            (0, _orientJs.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, right);
        } else flatCoordinates = this.flatCoordinates;
        return (0, _inflateJs.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
    }
    /**
   * @return {Array<Array<number>>} Endss.
   */ getEndss() {
        return this.endss_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            const flatCenters = (0, _centerJs.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
            this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return this.flatInteriorPoints_;
    }
    /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */ getInteriorPoints() {
        return new (0, _multiPointJsDefault.default)(this.getFlatInteriorPoints().slice(), "XYM");
    }
    /**
   * @return {Array<number>} Oriented flat coordinates.
   */ getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const flatCoordinates = this.flatCoordinates;
            if ((0, _orientJs.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = (0, _orientJs.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
        return new MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
    }
    /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */ getPolygon(index) {
        if (index < 0 || this.endss_.length <= index) return null;
        let offset;
        if (index === 0) offset = 0;
        else {
            const prevEnds = this.endss_[index - 1];
            offset = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index].slice();
        const end = ends[ends.length - 1];
        if (offset !== 0) for(let i = 0, ii = ends.length; i < ii; ++i)ends[i] -= offset;
        return new (0, _polygonJsDefault.default)(this.flatCoordinates.slice(offset, end), this.layout, ends);
    }
    /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */ getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset = 0;
        for(let i = 0, ii = endss.length; i < ii; ++i){
            const ends = endss[i].slice();
            const end = ends[ends.length - 1];
            if (offset !== 0) for(let j = 0, jj = ends.length; j < jj; ++j)ends[j] -= offset;
            const polygon = new (0, _polygonJsDefault.default)(flatCoordinates.slice(offset, end), layout, ends);
            polygons.push(polygon);
            offset = end;
        }
        return polygons;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "MultiPolygon";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
    }
    /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 3);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const endss = (0, _deflateJs.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
        if (endss.length === 0) this.flatCoordinates.length = 0;
        else {
            const lastEnds = endss[endss.length - 1];
            this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
    }
}
exports.default = MultiPolygon;

},{"./MultiPoint.js":"k4LcJ","./Polygon.js":"cJuQF","./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../array.js":"1Fbic","./flat/interiorpoint.js":"59VP9","./flat/inflate.js":"4Rpju","./flat/intersectsextent.js":"7x08H","./flat/orient.js":"btd6s","./flat/area.js":"7fT8A","./flat/center.js":"9OVXr","./flat/contains.js":"eArlN","./flat/simplify.js":"jsqc5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cJuQF":[function(require,module,exports) {
/**
 * @module ol/geom/Polygon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */ parcelHelpers.export(exports, "circular", ()=>circular);
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */ parcelHelpers.export(exports, "fromExtent", ()=>fromExtent);
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */ parcelHelpers.export(exports, "fromCircle", ()=>fromCircle);
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */ parcelHelpers.export(exports, "makeRegular", ()=>makeRegular);
var _linearRingJs = require("./LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _containsJs = require("./flat/contains.js");
var _mathJs = require("../math.js");
var _simplifyJs = require("./flat/simplify.js");
var _sphereJs = require("../sphere.js");
/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */ class Polygon extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */ constructor(coordinates, layout, ends){
        super();
        /**
     * @type {Array<number>}
     * @private
     */ this.ends_ = [];
        /**
     * @private
     * @type {number}
     */ this.flatInteriorPointRevision_ = -1;
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.flatInteriorPoint_ = null;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.orientedRevision_ = -1;
        /**
     * @private
     * @type {Array<number>}
     */ this.orientedFlatCoordinates_ = null;
        if (layout !== undefined && ends) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.ends_ = ends;
        } else this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ coordinates, layout);
    }
    /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */ appendLinearRing(linearRing) {
        if (!this.flatCoordinates) this.flatCoordinates = linearRing.getFlatCoordinates().slice();
        else (0, _arrayJs.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */ clone() {
        const polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        polygon.applyProperties(this);
        return polygon;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        return (0, _containsJs.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    }
    /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    }
    /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */ getCoordinates(right) {
        let flatCoordinates;
        if (right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            (0, _orientJs.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right);
        } else flatCoordinates = this.flatCoordinates;
        return (0, _inflateJs.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * @return {Array<number>} Interior point.
   */ getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const flatCenter = (0, _extentJs.getCenter)(this.getExtent());
            this.flatInteriorPoint_ = (0, _interiorpointJs.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
            this.flatInteriorPointRevision_ = this.getRevision();
        }
        return this.flatInteriorPoint_;
    }
    /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */ getInteriorPoint() {
        return new (0, _pointJsDefault.default)(this.getFlatInteriorPoint(), "XYM");
    }
    /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */ getLinearRingCount() {
        return this.ends_.length;
    }
    /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */ getLinearRing(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new (0, _linearRingJsDefault.default)(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */ getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings = [];
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const linearRing = new (0, _linearRingJsDefault.default)(flatCoordinates.slice(offset, end), layout);
            linearRings.push(linearRing);
            offset = end;
        }
        return linearRings;
    }
    /**
   * @return {Array<number>} Oriented flat coordinates.
   */ getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const flatCoordinates = this.flatCoordinates;
            if ((0, _orientJs.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = (0, _orientJs.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return "Polygon";
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    }
    /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const ends = (0, _deflateJs.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    }
}
exports.default = Polygon;
function circular(center, radius, n, sphereRadius) {
    n = n ? n : 32;
    /** @type {Array<number>} */ const flatCoordinates = [];
    for(let i = 0; i < n; ++i)(0, _arrayJs.extend)(flatCoordinates, (0, _sphereJs.offset)(center, radius, 2 * Math.PI * i / n, sphereRadius));
    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
    return new Polygon(flatCoordinates, "XY", [
        flatCoordinates.length
    ]);
}
function fromExtent(extent) {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const flatCoordinates = [
        minX,
        minY,
        minX,
        maxY,
        maxX,
        maxY,
        maxX,
        minY,
        minX,
        minY
    ];
    return new Polygon(flatCoordinates, "XY", [
        flatCoordinates.length
    ]);
}
function fromCircle(circle, sides, angle) {
    sides = sides ? sides : 32;
    const stride = circle.getStride();
    const layout = circle.getLayout();
    const center = circle.getCenter();
    const arrayLength = stride * (sides + 1);
    const flatCoordinates = new Array(arrayLength);
    for(let i = 0; i < arrayLength; i += stride){
        flatCoordinates[i] = 0;
        flatCoordinates[i + 1] = 0;
        for(let j = 2; j < stride; j++)flatCoordinates[i + j] = center[j];
    }
    const ends = [
        flatCoordinates.length
    ];
    const polygon = new Polygon(flatCoordinates, layout, ends);
    makeRegular(polygon, center, circle.getRadius(), angle);
    return polygon;
}
function makeRegular(polygon, center, radius, angle) {
    const flatCoordinates = polygon.getFlatCoordinates();
    const stride = polygon.getStride();
    const sides = flatCoordinates.length / stride - 1;
    const startAngle = angle ? angle : 0;
    for(let i = 0; i <= sides; ++i){
        const offset = i * stride;
        const angle1 = startAngle + (0, _mathJs.modulo)(i, sides) * 2 * Math.PI / sides;
        flatCoordinates[offset] = center[0] + radius * Math.cos(angle1);
        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle1);
    }
    polygon.changed();
}

},{"./LinearRing.js":"jg1hj","./Point.js":"hx2Ar","./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../array.js":"1Fbic","./flat/interiorpoint.js":"59VP9","./flat/inflate.js":"4Rpju","./flat/intersectsextent.js":"7x08H","./flat/orient.js":"btd6s","./flat/area.js":"7fT8A","./flat/contains.js":"eArlN","../math.js":"5jEFr","./flat/simplify.js":"jsqc5","../sphere.js":"eJjHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59VP9":[function(require,module,exports) {
/**
 * @module ol/geom/flat/interiorpoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointOfArray", ()=>getInteriorPointOfArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointsOfMultiArray", ()=>getInteriorPointsOfMultiArray);
var _containsJs = require("./contains.js");
var _arrayJs = require("../../array.js");
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
    let i, ii, x, x1, x2, y1, y2;
    const y = flatCenters[flatCentersOffset + 1];
    /** @type {Array<number>} */ const intersections = [];
    // Calculate intersections with the horizontal line
    for(let r = 0, rr = ends.length; r < rr; ++r){
        const end = ends[r];
        x1 = flatCoordinates[end - stride];
        y1 = flatCoordinates[end - stride + 1];
        for(i = offset; i < end; i += stride){
            x2 = flatCoordinates[i];
            y2 = flatCoordinates[i + 1];
            if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
                x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
                intersections.push(x);
            }
            x1 = x2;
            y1 = y2;
        }
    }
    // Find the longest segment of the horizontal line that has its center point
    // inside the linear ring.
    let pointX = NaN;
    let maxSegmentLength = -Infinity;
    intersections.sort((0, _arrayJs.numberSafeCompareFunction));
    x1 = intersections[0];
    for(i = 1, ii = intersections.length; i < ii; ++i){
        x2 = intersections[i];
        const segmentLength = Math.abs(x2 - x1);
        if (segmentLength > maxSegmentLength) {
            x = (x1 + x2) / 2;
            if ((0, _containsJs.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
                pointX = x;
                maxSegmentLength = segmentLength;
            }
        }
        x1 = x2;
    }
    if (isNaN(pointX)) // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
    if (dest) {
        dest.push(pointX, y, maxSegmentLength);
        return dest;
    } else return [
        pointX,
        y,
        maxSegmentLength
    ];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
    let interiorPoints = [];
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
        offset = ends[ends.length - 1];
    }
    return interiorPoints;
}

},{"./contains.js":"eArlN","../../array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"btd6s":[function(require,module,exports) {
/**
 * @module ol/geom/flat/orient
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */ parcelHelpers.export(exports, "linearRingIsClockwise", ()=>linearRingIsClockwise);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingsAreOriented", ()=>linearRingsAreOriented);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingssAreOriented", ()=>linearRingssAreOriented);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRings", ()=>orientLinearRings);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRingsArray", ()=>orientLinearRingsArray);
/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to contruct a MultiPolygon
 */ parcelHelpers.export(exports, "inflateEnds", ()=>inflateEnds);
var _reverseJs = require("./reverse.js");
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
    // https://stackoverflow.com/q/1165647/clockwise-method#1165943
    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
    let edge = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        edge += (x2 - x1) * (y2 + y1);
        x1 = x2;
        y1 = y2;
    }
    return edge === 0 ? undefined : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        if (i === 0) {
            if (right && isClockwise || !right && !isClockwise) return false;
        } else {
            if (right && !isClockwise || !right && isClockwise) return false;
        }
        offset = end;
    }
    return true;
}
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) return false;
        if (ends.length) offset = ends[ends.length - 1];
    }
    return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
        if (reverse) (0, _reverseJs.coordinates)(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return offset;
}
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
    for(let i = 0, ii = endss.length; i < ii; ++i)offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);
    return offset;
}
function inflateEnds(flatCoordinates, ends) {
    const endss = [];
    let offset = 0;
    let prevEndIndex = 0;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        // classifies an array of rings into polygons with outer rings and holes
        if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) endss.push(ends.slice(prevEndIndex, i + 1));
        else {
            if (endss.length === 0) continue;
            endss[endss.length - 1].push(ends[prevEndIndex]);
        }
        prevEndIndex = i + 1;
        offset = end;
    }
    return endss;
}

},{"./reverse.js":"hksTe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hksTe":[function(require,module,exports) {
/**
 * @module ol/geom/flat/reverse
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "coordinates", ()=>coordinates);
function coordinates(flatCoordinates, offset, end, stride) {
    while(offset < end - stride){
        for(let i = 0; i < stride; ++i){
            const tmp = flatCoordinates[offset + i];
            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
            flatCoordinates[end - stride + i] = tmp;
        }
        offset += stride;
        end -= stride;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9OVXr":[function(require,module,exports) {
/**
 * @module ol/geom/flat/center
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss);
var _extentJs = require("../../extent.js");
function linearRingss(flatCoordinates, offset, endss, stride) {
    const flatCenters = [];
    let extent = (0, _extentJs.createEmpty)();
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        extent = (0, _extentJs.createOrUpdateFromFlatCoordinates)(flatCoordinates, offset, ends[0], stride);
        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
        offset = ends[ends.length - 1];
    }
    return flatCenters;
}

},{"../../extent.js":"6YrVc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Cq04":[function(require,module,exports) {
/**
 * @module ol/style/Stroke
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */ /**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Stroke {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */ this.color_ = options.color !== undefined ? options.color : null;
        /**
     * @private
     * @type {CanvasLineCap|undefined}
     */ this.lineCap_ = options.lineCap;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
        /**
     * @private
     * @type {number|undefined}
     */ this.lineDashOffset_ = options.lineDashOffset;
        /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */ this.lineJoin_ = options.lineJoin;
        /**
     * @private
     * @type {number|undefined}
     */ this.miterLimit_ = options.miterLimit;
        /**
     * @private
     * @type {number|undefined}
     */ this.width_ = options.width;
    }
    /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */ clone() {
        const color = this.getColor();
        return new Stroke({
            color: Array.isArray(color) ? color.slice() : color || undefined,
            lineCap: this.getLineCap(),
            lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
            lineDashOffset: this.getLineDashOffset(),
            lineJoin: this.getLineJoin(),
            miterLimit: this.getMiterLimit(),
            width: this.getWidth()
        });
    }
    /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */ getLineCap() {
        return this.lineCap_;
    }
    /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */ getLineDash() {
        return this.lineDash_;
    }
    /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */ getLineDashOffset() {
        return this.lineDashOffset_;
    }
    /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */ getLineJoin() {
        return this.lineJoin_;
    }
    /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */ getMiterLimit() {
        return this.miterLimit_;
    }
    /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */ getWidth() {
        return this.width_;
    }
    /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */ setColor(color) {
        this.color_ = color;
    }
    /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */ setLineCap(lineCap) {
        this.lineCap_ = lineCap;
    }
    /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */ setLineDash(lineDash) {
        this.lineDash_ = lineDash;
    }
    /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */ setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
    }
    /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */ setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
    }
    /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */ setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
    }
    /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */ setWidth(width) {
        this.width_ = width;
    }
}
exports.default = Stroke;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fW7vC":[function(require,module,exports) {
/**
 * @module ol/style/Style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */ parcelHelpers.export(exports, "toFunction", ()=>toFunction);
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */ parcelHelpers.export(exports, "createDefaultStyle", ()=>createDefaultStyle);
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */ parcelHelpers.export(exports, "createEditingStyle", ()=>createEditingStyle);
var _circleJs = require("./Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _strokeJs = require("./Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _assertsJs = require("../asserts.js");
/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */ /**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */ /**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */ /**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void} RenderFunction
 */ /**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */ /**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */ class Style {
    /**
   * @param {Options} [options] Style options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
     */ this.geometry_ = null;
        /**
     * @private
     * @type {!GeometryFunction}
     */ this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== undefined) this.setGeometry(options.geometry);
        /**
     * @private
     * @type {import("./Fill.js").default}
     */ this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
     * @private
     * @type {import("./Image.js").default}
     */ this.image_ = options.image !== undefined ? options.image : null;
        /**
     * @private
     * @type {RenderFunction|null}
     */ this.renderer_ = options.renderer !== undefined ? options.renderer : null;
        /**
     * @private
     * @type {RenderFunction|null}
     */ this.hitDetectionRenderer_ = options.hitDetectionRenderer !== undefined ? options.hitDetectionRenderer : null;
        /**
     * @private
     * @type {import("./Stroke.js").default}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {import("./Text.js").default}
     */ this.text_ = options.text !== undefined ? options.text : null;
        /**
     * @private
     * @type {number|undefined}
     */ this.zIndex_ = options.zIndex;
    }
    /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */ clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === "object") geometry = /** @type {import("../geom/Geometry.js").default} */ geometry.clone();
        return new Style({
            geometry: geometry,
            fill: this.getFill() ? this.getFill().clone() : undefined,
            image: this.getImage() ? this.getImage().clone() : undefined,
            renderer: this.getRenderer(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            text: this.getText() ? this.getText().clone() : undefined,
            zIndex: this.getZIndex()
        });
    }
    /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */ getRenderer() {
        return this.renderer_;
    }
    /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */ setRenderer(renderer) {
        this.renderer_ = renderer;
    }
    /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */ setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
    }
    /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */ getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
    }
    /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */ getGeometry() {
        return this.geometry_;
    }
    /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */ getGeometryFunction() {
        return this.geometryFunction_;
    }
    /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
    }
    /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */ getImage() {
        return this.image_;
    }
    /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */ setImage(image) {
        this.image_ = image;
    }
    /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
    }
    /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */ getText() {
        return this.text_;
    }
    /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */ setText(text) {
        this.text_ = text;
    }
    /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */ getZIndex() {
        return this.zIndex_;
    }
    /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */ setGeometry(geometry) {
        if (typeof geometry === "function") this.geometryFunction_ = geometry;
        else if (typeof geometry === "string") this.geometryFunction_ = function(feature) {
            return /** @type {import("../geom/Geometry.js").default} */ feature.get(geometry);
        };
        else if (!geometry) this.geometryFunction_ = defaultGeometryFunction;
        else if (geometry !== undefined) this.geometryFunction_ = function() {
            return /** @type {import("../geom/Geometry.js").default} */ geometry;
        };
        this.geometry_ = geometry;
    }
    /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */ setZIndex(zIndex) {
        this.zIndex_ = zIndex;
    }
}
function toFunction(obj) {
    let styleFunction;
    if (typeof obj === "function") styleFunction = obj;
    else {
        /**
     * @type {Array<Style>}
     */ let styles;
        if (Array.isArray(obj)) styles = obj;
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ obj.getZIndex === "function", 41); // Expected an `Style` or an array of `Style`
            const style = /** @type {Style} */ obj;
            styles = [
                style
            ];
        }
        styleFunction = function() {
            return styles;
        };
    }
    return styleFunction;
}
/**
 * @type {Array<Style>|null}
 */ let defaultStyles = null;
function createDefaultStyle(feature, resolution) {
    // We don't use an immediately-invoked function
    // and a closure so we don't get an error at script evaluation time in
    // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
    // canvas.getContext('2d') at construction time, which will cause an.error
    // in such browsers.)
    if (!defaultStyles) {
        const fill = new (0, _fillJsDefault.default)({
            color: "rgba(255,255,255,0.4)"
        });
        const stroke = new (0, _strokeJsDefault.default)({
            color: "#3399CC",
            width: 1.25
        });
        defaultStyles = [
            new Style({
                image: new (0, _circleJsDefault.default)({
                    fill: fill,
                    stroke: stroke,
                    radius: 5
                }),
                fill: fill,
                stroke: stroke
            })
        ];
    }
    return defaultStyles;
}
function createEditingStyle() {
    /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */ const styles = {};
    const white = [
        255,
        255,
        255,
        1
    ];
    const blue = [
        0,
        153,
        255,
        1
    ];
    const width = 3;
    styles["Polygon"] = [
        new Style({
            fill: new (0, _fillJsDefault.default)({
                color: [
                    255,
                    255,
                    255,
                    0.5
                ]
            })
        })
    ];
    styles["MultiPolygon"] = styles["Polygon"];
    styles["LineString"] = [
        new Style({
            stroke: new (0, _strokeJsDefault.default)({
                color: white,
                width: width + 2
            })
        }),
        new Style({
            stroke: new (0, _strokeJsDefault.default)({
                color: blue,
                width: width
            })
        })
    ];
    styles["MultiLineString"] = styles["LineString"];
    styles["Circle"] = styles["Polygon"].concat(styles["LineString"]);
    styles["Point"] = [
        new Style({
            image: new (0, _circleJsDefault.default)({
                radius: width * 2,
                fill: new (0, _fillJsDefault.default)({
                    color: blue
                }),
                stroke: new (0, _strokeJsDefault.default)({
                    color: white,
                    width: width / 2
                })
            }),
            zIndex: Infinity
        })
    ];
    styles["MultiPoint"] = styles["Point"];
    styles["GeometryCollection"] = styles["Polygon"].concat(styles["LineString"], styles["Point"]);
    return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */ function defaultGeometryFunction(feature) {
    return feature.getGeometry();
}
exports.default = Style;

},{"./Circle.js":"cSS3Y","./Fill.js":"4fB56","./Stroke.js":"5Cq04","../asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dwGM6":[function(require,module,exports) {
/**
 * @module ol/style/Text
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _sizeJs = require("../size.js");
/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */ /**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */ /**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */ const DEFAULT_FILL_COLOR = "#333";
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */ /**
 * @classdesc
 * Set text style for vector features.
 * @api
 */ class Text {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {string|undefined}
     */ this.font_ = options.font;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = options.rotation;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.rotateWithView_ = options.rotateWithView;
        /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */ this.scale_ = options.scale;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.scaleArray_ = (0, _sizeJs.toSize)(options.scale !== undefined ? options.scale : 1);
        /**
     * @private
     * @type {string|Array<string>|undefined}
     */ this.text_ = options.text;
        /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */ this.textAlign_ = options.textAlign;
        /**
     * @private
     * @type {TextJustify|undefined}
     */ this.justify_ = options.justify;
        /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */ this.textBaseline_ = options.textBaseline;
        /**
     * @private
     * @type {import("./Fill.js").default}
     */ this.fill_ = options.fill !== undefined ? options.fill : new (0, _fillJsDefault.default)({
            color: DEFAULT_FILL_COLOR
        });
        /**
     * @private
     * @type {number}
     */ this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
        /**
     * @private
     * @type {TextPlacement}
     */ this.placement_ = options.placement !== undefined ? options.placement : "point";
        /**
     * @private
     * @type {boolean}
     */ this.overflow_ = !!options.overflow;
        /**
     * @private
     * @type {import("./Stroke.js").default}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {number}
     */ this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
        /**
     * @private
     * @type {number}
     */ this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
        /**
     * @private
     * @type {import("./Fill.js").default}
     */ this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        /**
     * @private
     * @type {import("./Stroke.js").default}
     */ this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.padding_ = options.padding === undefined ? null : options.padding;
    }
    /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        return new Text({
            font: this.getFont(),
            placement: this.getPlacement(),
            maxAngle: this.getMaxAngle(),
            overflow: this.getOverflow(),
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            text: this.getText(),
            textAlign: this.getTextAlign(),
            justify: this.getJustify(),
            textBaseline: this.getTextBaseline(),
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            offsetX: this.getOffsetX(),
            offsetY: this.getOffsetY(),
            backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
            backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
            padding: this.getPadding() || undefined
        });
    }
    /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */ getOverflow() {
        return this.overflow_;
    }
    /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */ getFont() {
        return this.font_;
    }
    /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */ getMaxAngle() {
        return this.maxAngle_;
    }
    /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */ getPlacement() {
        return this.placement_;
    }
    /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */ getOffsetX() {
        return this.offsetX_;
    }
    /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */ getOffsetY() {
        return this.offsetY_;
    }
    /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */ getRotateWithView() {
        return this.rotateWithView_;
    }
    /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */ getRotation() {
        return this.rotation_;
    }
    /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */ getScale() {
        return this.scale_;
    }
    /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */ getScaleArray() {
        return this.scaleArray_;
    }
    /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */ getText() {
        return this.text_;
    }
    /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */ getTextAlign() {
        return this.textAlign_;
    }
    /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */ getJustify() {
        return this.justify_;
    }
    /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */ getTextBaseline() {
        return this.textBaseline_;
    }
    /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */ getBackgroundFill() {
        return this.backgroundFill_;
    }
    /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */ getBackgroundStroke() {
        return this.backgroundStroke_;
    }
    /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */ getPadding() {
        return this.padding_;
    }
    /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */ setOverflow(overflow) {
        this.overflow_ = overflow;
    }
    /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */ setFont(font) {
        this.font_ = font;
    }
    /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */ setMaxAngle(maxAngle) {
        this.maxAngle_ = maxAngle;
    }
    /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */ setOffsetX(offsetX) {
        this.offsetX_ = offsetX;
    }
    /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */ setOffsetY(offsetY) {
        this.offsetY_ = offsetY;
    }
    /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */ setPlacement(placement) {
        this.placement_ = placement;
    }
    /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */ setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    }
    /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
    }
    /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */ setRotation(rotation) {
        this.rotation_ = rotation;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */ setScale(scale) {
        this.scale_ = scale;
        this.scaleArray_ = (0, _sizeJs.toSize)(scale !== undefined ? scale : 1);
    }
    /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
    }
    /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */ setText(text) {
        this.text_ = text;
    }
    /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */ setTextAlign(textAlign) {
        this.textAlign_ = textAlign;
    }
    /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */ setJustify(justify) {
        this.justify_ = justify;
    }
    /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */ setTextBaseline(textBaseline) {
        this.textBaseline_ = textBaseline;
    }
    /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */ setBackgroundFill(fill) {
        this.backgroundFill_ = fill;
    }
    /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */ setBackgroundStroke(stroke) {
        this.backgroundStroke_ = stroke;
    }
    /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */ setPadding(padding) {
        this.padding_ = padding;
    }
}
exports.default = Text;

},{"./Fill.js":"4fB56","../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gOwFC":[function(require,module,exports) {
/**
 * @module ol/tileurlfunction
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */ parcelHelpers.export(exports, "createFromTemplate", ()=>createFromTemplate);
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */ parcelHelpers.export(exports, "createFromTemplates", ()=>createFromTemplates);
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */ parcelHelpers.export(exports, "createFromTileUrlFunctions", ()=>createFromTileUrlFunctions);
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */ parcelHelpers.export(exports, "nullTileUrlFunction", ()=>nullTileUrlFunction);
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */ parcelHelpers.export(exports, "expandUrl", ()=>expandUrl);
var _assertsJs = require("./asserts.js");
var _mathJs = require("./math.js");
var _tilecoordJs = require("./tilecoord.js");
function createFromTemplate(template, tileGrid) {
    const zRegEx = /\{z\}/g;
    const xRegEx = /\{x\}/g;
    const yRegEx = /\{y\}/g;
    const dashYRegEx = /\{-y\}/g;
    return(/**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */ function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) return undefined;
        else return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
            const z = tileCoord[0];
            const range = tileGrid.getFullTileRange(z);
            (0, _assertsJs.assert)(range, 55); // The {-y} placeholder requires a tile grid with extent
            const y = range.getHeight() - tileCoord[2] - 1;
            return y.toString();
        });
    });
}
function createFromTemplates(templates, tileGrid) {
    const len = templates.length;
    const tileUrlFunctions = new Array(len);
    for(let i = 0; i < len; ++i)tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
    return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
    if (tileUrlFunctions.length === 1) return tileUrlFunctions[0];
    return(/**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */ function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) return undefined;
        else {
            const h = (0, _tilecoordJs.hash)(tileCoord);
            const index = (0, _mathJs.modulo)(h, tileUrlFunctions.length);
            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
        }
    });
}
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
    return undefined;
}
function expandUrl(url) {
    const urls = [];
    let match = /\{([a-z])-([a-z])\}/.exec(url);
    if (match) {
        // char range
        const startCharCode = match[1].charCodeAt(0);
        const stopCharCode = match[2].charCodeAt(0);
        let charCode;
        for(charCode = startCharCode; charCode <= stopCharCode; ++charCode)urls.push(url.replace(match[0], String.fromCharCode(charCode)));
        return urls;
    }
    match = /\{(\d+)-(\d+)\}/.exec(url);
    if (match) {
        // number range
        const stop = parseInt(match[2], 10);
        for(let i = parseInt(match[1], 10); i <= stop; i++)urls.push(url.replace(match[0], i.toString()));
        return urls;
    }
    urls.push(url);
    return urls;
}

},{"./asserts.js":"e4TiF","./math.js":"5jEFr","./tilecoord.js":"bZ2LT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bZ2LT":[function(require,module,exports) {
/**
 * @module ol/tilecoord
 */ /**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */ /**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate);
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */ parcelHelpers.export(exports, "getKeyZXY", ()=>getKeyZXY);
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */ parcelHelpers.export(exports, "getKey", ()=>getKey);
/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */ parcelHelpers.export(exports, "getCacheKeyForTileKey", ()=>getCacheKeyForTileKey);
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */ parcelHelpers.export(exports, "fromKey", ()=>fromKey);
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */ parcelHelpers.export(exports, "hash", ()=>hash);
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */ parcelHelpers.export(exports, "withinExtentAndZ", ()=>withinExtentAndZ);
function createOrUpdate(z, x, y, tileCoord) {
    if (tileCoord !== undefined) {
        tileCoord[0] = z;
        tileCoord[1] = x;
        tileCoord[2] = y;
        return tileCoord;
    } else return [
        z,
        x,
        y
    ];
}
function getKeyZXY(z, x, y) {
    return z + "/" + x + "/" + y;
}
function getKey(tileCoord) {
    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function getCacheKeyForTileKey(tileKey) {
    const [z, x, y] = tileKey.substring(tileKey.lastIndexOf("/") + 1, tileKey.length).split(",").map(Number);
    return getKeyZXY(z, x, y);
}
function fromKey(key) {
    return key.split("/").map(Number);
}
function hash(tileCoord) {
    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
    const z = tileCoord[0];
    const x = tileCoord[1];
    const y = tileCoord[2];
    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) return false;
    const tileRange = tileGrid.getFullTileRange(z);
    if (!tileRange) return true;
    else return tileRange.containsXY(x, y);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1bsdX":[function(require,module,exports) {
/**
 * @module ol/format/GeoJSON
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryCollectionJs = require("../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _jsonfeatureJs = require("./JSONFeature.js");
var _jsonfeatureJsDefault = parcelHelpers.interopDefault(_jsonfeatureJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _assertsJs = require("../asserts.js");
var _projJs = require("../proj.js");
var _objJs = require("../obj.js");
var _featureJs1 = require("./Feature.js");
/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */ /**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 */ /**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @api
 */ class GeoJSON extends (0, _jsonfeatureJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super();
        /**
     * @type {import("../proj/Projection.js").default}
     */ this.dataProjection = (0, _projJs.get)(options.dataProjection ? options.dataProjection : "EPSG:4326");
        if (options.featureProjection) /**
       * @type {import("../proj/Projection.js").default}
       */ this.defaultFeatureProjection = (0, _projJs.get)(options.featureProjection);
        /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */ this.geometryName_ = options.geometryName;
        /**
     * Look for the geometry name in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */ this.extractGeometryName_ = options.extractGeometryName;
        this.supportedMediaTypes = [
            "application/geo+json",
            "application/vnd.geo+json"
        ];
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */ readFeatureFromObject(object, options) {
        /**
     * @type {GeoJSONFeature}
     */ let geoJSONFeature = null;
        if (object["type"] === "Feature") geoJSONFeature = /** @type {GeoJSONFeature} */ object;
        else geoJSONFeature = {
            "type": "Feature",
            "geometry": /** @type {GeoJSONGeometry} */ object,
            "properties": null
        };
        const geometry = readGeometry(geoJSONFeature["geometry"], options);
        const feature = new (0, _featureJsDefault.default)();
        if (this.geometryName_) feature.setGeometryName(this.geometryName_);
        else if (this.extractGeometryName_ && true) feature.setGeometryName(geoJSONFeature["geometry_name"]);
        feature.setGeometry(geometry);
        if ("id" in geoJSONFeature) feature.setId(geoJSONFeature["id"]);
        if (geoJSONFeature["properties"]) feature.setProperties(geoJSONFeature["properties"], true);
        return feature;
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */ readFeaturesFromObject(object, options) {
        const geoJSONObject = /** @type {GeoJSONObject} */ object;
        /** @type {Array<import("../Feature.js").default>} */ let features = null;
        if (geoJSONObject["type"] === "FeatureCollection") {
            const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ object;
            features = [];
            const geoJSONFeatures = geoJSONFeatureCollection["features"];
            for(let i = 0, ii = geoJSONFeatures.length; i < ii; ++i)features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));
        } else features = [
            this.readFeatureFromObject(object, options)
        ];
        return features;
    }
    /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromObject(object, options) {
        return readGeometry(object, options);
    }
    /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromObject(object) {
        const crs = object["crs"];
        let projection;
        if (crs) {
            if (crs["type"] == "name") projection = (0, _projJs.get)(crs["properties"]["name"]);
            else if (crs["type"] === "EPSG") projection = (0, _projJs.get)("EPSG:" + crs["properties"]["code"]);
            else (0, _assertsJs.assert)(false, 36); // Unknown SRS type
        } else projection = this.dataProjection;
        return /** @type {import("../proj/Projection.js").default} */ projection;
    }
    /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */ writeFeatureObject(feature, options) {
        options = this.adaptOptions(options);
        /** @type {GeoJSONFeature} */ const object = {
            "type": "Feature",
            geometry: null,
            properties: null
        };
        const id = feature.getId();
        if (id !== undefined) object.id = id;
        if (!feature.hasProperties()) return object;
        const properties = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry) {
            object.geometry = writeGeometry(geometry, options);
            delete properties[feature.getGeometryName()];
        }
        if (!(0, _objJs.isEmpty)(properties)) object.properties = properties;
        return object;
    }
    /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */ writeFeaturesObject(features, options) {
        options = this.adaptOptions(options);
        const objects = [];
        for(let i = 0, ii = features.length; i < ii; ++i)objects.push(this.writeFeatureObject(features[i], options));
        return {
            type: "FeatureCollection",
            features: objects
        };
    }
    /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */ writeGeometryObject(geometry, options) {
        return writeGeometry(geometry, this.adaptOptions(options));
    }
}
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */ function readGeometry(object, options) {
    if (!object) return null;
    /**
   * @type {import("../geom/Geometry.js").default}
   */ let geometry;
    switch(object["type"]){
        case "Point":
            geometry = readPointGeometry(/** @type {GeoJSONPoint} */ object);
            break;
        case "LineString":
            geometry = readLineStringGeometry(/** @type {GeoJSONLineString} */ object);
            break;
        case "Polygon":
            geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ object);
            break;
        case "MultiPoint":
            geometry = readMultiPointGeometry(/** @type {GeoJSONMultiPoint} */ object);
            break;
        case "MultiLineString":
            geometry = readMultiLineStringGeometry(/** @type {GeoJSONMultiLineString} */ object);
            break;
        case "MultiPolygon":
            geometry = readMultiPolygonGeometry(/** @type {GeoJSONMultiPolygon} */ object);
            break;
        case "GeometryCollection":
            geometry = readGeometryCollectionGeometry(/** @type {GeoJSONGeometryCollection} */ object);
            break;
        default:
            throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
    return (0, _featureJs1.transformGeometryWithOptions)(geometry, false, options);
}
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {GeometryCollection} Geometry collection.
 */ function readGeometryCollectionGeometry(object, options) {
    const geometries = object["geometries"].map(/**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */ function(geometry) {
        return readGeometry(geometry, options);
    });
    return new (0, _geometryCollectionJsDefault.default)(geometries);
}
/**
 * @param {GeoJSONPoint} object Object.
 * @return {Point} Point.
 */ function readPointGeometry(object) {
    return new (0, _pointJsDefault.default)(object["coordinates"]);
}
/**
 * @param {GeoJSONLineString} object Object.
 * @return {LineString} LineString.
 */ function readLineStringGeometry(object) {
    return new (0, _lineStringJsDefault.default)(object["coordinates"]);
}
/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {MultiLineString} MultiLineString.
 */ function readMultiLineStringGeometry(object) {
    return new (0, _multiLineStringJsDefault.default)(object["coordinates"]);
}
/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {MultiPoint} MultiPoint.
 */ function readMultiPointGeometry(object) {
    return new (0, _multiPointJsDefault.default)(object["coordinates"]);
}
/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {MultiPolygon} MultiPolygon.
 */ function readMultiPolygonGeometry(object) {
    return new (0, _multiPolygonJsDefault.default)(object["coordinates"]);
}
/**
 * @param {GeoJSONPolygon} object Object.
 * @return {Polygon} Polygon.
 */ function readPolygonGeometry(object) {
    return new (0, _polygonJsDefault.default)(object["coordinates"]);
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeGeometry(geometry, options) {
    geometry = (0, _featureJs1.transformGeometryWithOptions)(geometry, true, options);
    const type = geometry.getType();
    /** @type {GeoJSONGeometry} */ let geoJSON;
    switch(type){
        case "Point":
            geoJSON = writePointGeometry(/** @type {Point} */ geometry, options);
            break;
        case "LineString":
            geoJSON = writeLineStringGeometry(/** @type {LineString} */ geometry, options);
            break;
        case "Polygon":
            geoJSON = writePolygonGeometry(/** @type {Polygon} */ geometry, options);
            break;
        case "MultiPoint":
            geoJSON = writeMultiPointGeometry(/** @type {MultiPoint} */ geometry, options);
            break;
        case "MultiLineString":
            geoJSON = writeMultiLineStringGeometry(/** @type {MultiLineString} */ geometry, options);
            break;
        case "MultiPolygon":
            geoJSON = writeMultiPolygonGeometry(/** @type {MultiPolygon} */ geometry, options);
            break;
        case "GeometryCollection":
            geoJSON = writeGeometryCollectionGeometry(/** @type {GeometryCollection} */ geometry, options);
            break;
        case "Circle":
            geoJSON = {
                type: "GeometryCollection",
                geometries: []
            };
            break;
        default:
            throw new Error("Unsupported geometry type: " + type);
    }
    return geoJSON;
}
/**
 * @param {GeometryCollection} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */ function writeGeometryCollectionGeometry(geometry, options) {
    options = Object.assign({}, options);
    delete options.featureProjection;
    const geometries = geometry.getGeometriesArray().map(function(geometry) {
        return writeGeometry(geometry, options);
    });
    return {
        type: "GeometryCollection",
        geometries: geometries
    };
}
/**
 * @param {LineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeLineStringGeometry(geometry, options) {
    return {
        type: "LineString",
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {MultiLineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiLineStringGeometry(geometry, options) {
    return {
        type: "MultiLineString",
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {MultiPoint} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPointGeometry(geometry, options) {
    return {
        type: "MultiPoint",
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {MultiPolygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPolygonGeometry(geometry, options) {
    let right;
    if (options) right = options.rightHanded;
    return {
        type: "MultiPolygon",
        coordinates: geometry.getCoordinates(right)
    };
}
/**
 * @param {Point} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePointGeometry(geometry, options) {
    return {
        type: "Point",
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {Polygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePolygonGeometry(geometry, options) {
    let right;
    if (options) right = options.rightHanded;
    return {
        type: "Polygon",
        coordinates: geometry.getCoordinates(right)
    };
}
exports.default = GeoJSON;

},{"../Feature.js":"liabO","../geom/GeometryCollection.js":"fDMaj","./JSONFeature.js":"aCFnK","../geom/LineString.js":"jLUiq","../geom/MultiLineString.js":"030lt","../geom/MultiPoint.js":"k4LcJ","../geom/MultiPolygon.js":"2XIqx","../geom/Point.js":"hx2Ar","../geom/Polygon.js":"cJuQF","../asserts.js":"e4TiF","../proj.js":"SznqC","../obj.js":"3ssAG","./Feature.js":"FZbV5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aCFnK":[function(require,module,exports) {
/**
 * @module ol/format/JSONFeature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("./Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _utilJs = require("../util.js");
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */ class JSONFeature extends (0, _featureJsDefault.default) {
    constructor(){
        super();
    }
    /**
   * @return {import("./Feature.js").Type} Format.
   */ getType() {
        return "json";
    }
    /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */ readFeature(source, options) {
        return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */ readFeatures(source, options) {
        return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */ readFeatureFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */ readGeometry(source, options) {
        return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */ readProjection(source) {
        return this.readProjectionFromObject(getObject(source));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromObject(object) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */ writeFeature(feature, options) {
        return JSON.stringify(this.writeFeatureObject(feature, options));
    }
    /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeatureObject(feature, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */ writeFeatures(features, options) {
        return JSON.stringify(this.writeFeaturesObject(features, options));
    }
    /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeaturesObject(features, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */ writeGeometry(geometry, options) {
        return JSON.stringify(this.writeGeometryObject(geometry, options));
    }
    /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeGeometryObject(geometry, options) {
        return (0, _utilJs.abstract)();
    }
}
/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */ function getObject(source) {
    if (typeof source === "string") {
        const object = JSON.parse(source);
        return object ? /** @type {Object} */ object : null;
    } else if (source !== null) return source;
    else return null;
}
exports.default = JSONFeature;

},{"./Feature.js":"FZbV5","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"FZbV5":[function(require,module,exports) {
/**
 * @module ol/format/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {import("../geom/Geometry.js").default} Transformed geometry.
 */ parcelHelpers.export(exports, "transformGeometryWithOptions", ()=>transformGeometryWithOptions);
/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions} [options] Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */ parcelHelpers.export(exports, "transformExtentWithOptions", ()=>transformExtentWithOptions);
var _utilJs = require("../util.js");
var _projJs = require("../proj.js");
/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */ /**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */ /**
 * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */ class FeatureFormat {
    constructor(){
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.dataProjection = undefined;
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.defaultFeatureProjection = undefined;
        /**
     * A list media types supported by the format in descending order of preference.
     * @type {Array<string>}
     */ this.supportedMediaTypes = null;
    }
    /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */ getReadOptions(source, options) {
        if (options) {
            let dataProjection = options.dataProjection ? (0, _projJs.get)(options.dataProjection) : this.readProjection(source);
            if (options.extent && dataProjection && dataProjection.getUnits() === "tile-pixels") {
                dataProjection = (0, _projJs.get)(dataProjection);
                dataProjection.setWorldExtent(options.extent);
            }
            options = {
                dataProjection: dataProjection,
                featureProjection: options.featureProjection
            };
        }
        return this.adaptOptions(options);
    }
    /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */ adaptOptions(options) {
        return Object.assign({
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection
        }, options);
    }
    /**
   * @abstract
   * @return {Type} The format type.
   */ getType() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */ readFeature(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */ readFeatures(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometry(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */ readProjection(source) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeature(feature, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeatures(features, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeGeometry(geometry, options) {
        return (0, _utilJs.abstract)();
    }
}
exports.default = FeatureFormat;
function transformGeometryWithOptions(geometry, write, options) {
    const featureProjection = options ? (0, _projJs.get)(options.featureProjection) : null;
    const dataProjection = options ? (0, _projJs.get)(options.dataProjection) : null;
    let transformed;
    if (featureProjection && dataProjection && !(0, _projJs.equivalent)(featureProjection, dataProjection)) transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    else transformed = geometry;
    if (write && options && /** @type {WriteOptions} */ options.decimals !== undefined) {
        const power = Math.pow(10, /** @type {WriteOptions} */ options.decimals);
        // if decimals option on write, round each coordinate appropriately
        /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */ const transform = function(coordinates) {
            for(let i = 0, ii = coordinates.length; i < ii; ++i)coordinates[i] = Math.round(coordinates[i] * power) / power;
            return coordinates;
        };
        if (transformed === geometry) transformed = geometry.clone();
        transformed.applyTransform(transform);
    }
    return transformed;
}
function transformExtentWithOptions(extent, options) {
    const featureProjection = options ? (0, _projJs.get)(options.featureProjection) : null;
    const dataProjection = options ? (0, _projJs.get)(options.dataProjection) : null;
    if (featureProjection && dataProjection && !(0, _projJs.equivalent)(featureProjection, dataProjection)) return (0, _projJs.transformExtent)(extent, dataProjection, featureProjection);
    else return extent;
}

},{"../util.js":"pLBjQ","../proj.js":"SznqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4sfDX":[function(require,module,exports) {
/**
 * @module ol/layer/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseImageJs = require("./BaseImage.js");
var _baseImageJsDefault = parcelHelpers.interopDefault(_baseImageJs);
var _imageLayerJs = require("../renderer/canvas/ImageLayer.js");
var _imageLayerJsDefault = parcelHelpers.interopDefault(_imageLayerJs);
/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}
 * @api
 */ class ImageLayer extends (0, _baseImageJsDefault.default) {
    /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */ constructor(options){
        super(options);
    }
    createRenderer() {
        return new (0, _imageLayerJsDefault.default)(this);
    }
    /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */ getData(pixel) {
        return super.getData(pixel);
    }
}
exports.default = ImageLayer;

},{"./BaseImage.js":"dIEGd","../renderer/canvas/ImageLayer.js":"b1I4K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dIEGd":[function(require,module,exports) {
/**
 * @module ol/layer/BaseImage
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
/**
 * @template {import("../source/Image.js").default} ImageSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {ImageSourceType} [source] Source for this layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<ImageSourceType, RendererType>}
 * @api
 */ class BaseImageLayer extends (0, _layerJsDefault.default) {
    /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */ constructor(options){
        options = options ? options : {};
        super(options);
    }
}
exports.default = BaseImageLayer;

},{"./Layer.js":"8J9Kf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8J9Kf":[function(require,module,exports) {
/**
 * @module ol/layer/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */ parcelHelpers.export(exports, "inView", ()=>inView);
var _baseJs = require("./Base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _eventTypeJs1 = require("../render/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _assertsJs = require("../asserts.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:source'|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */ /**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */ /**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */ class Layer extends (0, _baseJsDefault.default) {
    /**
   * @param {Options<SourceType>} options Layer options.
   */ constructor(options){
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {LayerOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapPrecomposeKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapRenderKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.sourceChangeKey_ = null;
        /**
     * @private
     * @type {RendererType}
     */ this.renderer_ = null;
        /**
     * @protected
     * @type {boolean}
     */ this.rendered = false;
        // Overwrite default render method with a custom one
        if (options.render) this.render = options.render;
        if (options.map) this.setMap(options.map);
        this.addChangeListener((0, _propertyJsDefault.default).SOURCE, this.handleSourcePropertyChange_);
        const source = options.source ? /** @type {SourceType} */ options.source : null;
        this.setSource(source);
    }
    /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
    }
    /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
    }
    /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */ getSource() {
        return /** @type {SourceType} */ this.get((0, _propertyJsDefault.default).SOURCE) || null;
    }
    /**
   * @return {SourceType|null} The source being rendered.
   */ getRenderSource() {
        return this.getSource();
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        const source = this.getSource();
        return !source ? "undefined" : source.getState();
    }
    /**
   * @private
   */ handleSourceChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
            (0, _eventsJs.unlistenByKey)(this.sourceChangeKey_);
            this.sourceChangeKey_ = null;
        }
        const source = this.getSource();
        if (source) this.sourceChangeKey_ = (0, _eventsJs.listen)(source, (0, _eventTypeJsDefault.default).CHANGE, this.handleSourceChange_, this);
        this.changed();
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        if (!this.renderer_) return new Promise((resolve)=>resolve([]));
        return this.renderer_.getFeatures(pixel);
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        if (!this.renderer_ || !this.rendered) return null;
        return this.renderer_.getData(pixel);
    }
    /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */ render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
            this.rendered = true;
            return layerRenderer.renderFrame(frameState, target);
        }
    }
    /**
   * Called when a layer is not visible during a map render.
   */ unrender() {
        this.rendered = false;
    }
    /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */ setMapInternal(map) {
        if (!map) this.unrender();
        this.set((0, _propertyJsDefault.default).MAP, map);
    }
    /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */ getMapInternal() {
        return this.get((0, _propertyJsDefault.default).MAP);
    }
    /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        if (this.mapPrecomposeKey_) {
            (0, _eventsJs.unlistenByKey)(this.mapPrecomposeKey_);
            this.mapPrecomposeKey_ = null;
        }
        if (!map) this.changed();
        if (this.mapRenderKey_) {
            (0, _eventsJs.unlistenByKey)(this.mapRenderKey_);
            this.mapRenderKey_ = null;
        }
        if (map) {
            this.mapPrecomposeKey_ = (0, _eventsJs.listen)(map, (0, _eventTypeJsDefault1.default).PRECOMPOSE, function(evt) {
                const renderEvent = /** @type {import("../render/Event.js").default} */ evt;
                const layerStatesArray = renderEvent.frameState.layerStatesArray;
                const layerState = this.getLayerState(false);
                // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.
                (0, _assertsJs.assert)(!layerStatesArray.some(function(arrayLayerState) {
                    return arrayLayerState.layer === layerState.layer;
                }), 67);
                layerStatesArray.push(layerState);
            }, this);
            this.mapRenderKey_ = (0, _eventsJs.listen)(this, (0, _eventTypeJsDefault.default).CHANGE, map.render, map);
            this.changed();
        }
    }
    /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */ setSource(source) {
        this.set((0, _propertyJsDefault.default).SOURCE, source);
    }
    /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */ getRenderer() {
        if (!this.renderer_) this.renderer_ = this.createRenderer();
        return this.renderer_;
    }
    /**
   * @return {boolean} The layer has a renderer.
   */ hasRenderer() {
        return !!this.renderer_;
    }
    /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */ createRenderer() {
        return null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.renderer_) {
            this.renderer_.dispose();
            delete this.renderer_;
        }
        this.setSource(null);
        super.disposeInternal();
    }
}
function inView(layerState, viewState) {
    if (!layerState.visible) return false;
    const resolution = viewState.resolution;
    if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) return false;
    const zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
exports.default = Layer;

},{"./Base.js":"ag0tc","../events/EventType.js":"hrQJ6","./Property.js":"kCuCK","../render/EventType.js":"5G9JA","../asserts.js":"e4TiF","../events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ag0tc":[function(require,module,exports) {
/**
 * @module ol/layer/Base
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _utilJs = require("../util.js");
var _assertsJs = require("../asserts.js");
var _mathJs = require("../math.js");
/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */ /**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */ class BaseLayer extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Layer options.
   */ constructor(options){
        super();
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {BaseLayerOnSignature<void>}
     */ this.un;
        /**
     * @type {BackgroundColor|false}
     * @private
     */ this.background_ = options.background;
        /**
     * @type {Object<string, *>}
     */ const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
            delete properties.properties;
            Object.assign(properties, options.properties);
        }
        properties[(0, _propertyJsDefault.default).OPACITY] = options.opacity !== undefined ? options.opacity : 1;
        (0, _assertsJs.assert)(typeof properties[(0, _propertyJsDefault.default).OPACITY] === "number", 64); // Layer opacity must be a number
        properties[(0, _propertyJsDefault.default).VISIBLE] = options.visible !== undefined ? options.visible : true;
        properties[(0, _propertyJsDefault.default).Z_INDEX] = options.zIndex;
        properties[(0, _propertyJsDefault.default).MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
        properties[(0, _propertyJsDefault.default).MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
        properties[(0, _propertyJsDefault.default).MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
        properties[(0, _propertyJsDefault.default).MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
        /**
     * @type {string}
     * @private
     */ this.className_ = properties.className !== undefined ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        /**
     * @type {import("./Layer.js").State}
     * @private
     */ this.state_ = null;
    }
    /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */ getBackground() {
        return this.background_;
    }
    /**
   * @return {string} CSS class name.
   */ getClassName() {
        return this.className_;
    }
    /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */ getLayerState(managed) {
        /** @type {import("./Layer.js").State} */ const state = this.state_ || /** @type {?} */ {
            layer: this,
            managed: managed === undefined ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = (0, _mathJs.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(states) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */ getExtent() {
        return /** @type {import("../extent.js").Extent|undefined} */ this.get((0, _propertyJsDefault.default).EXTENT);
    }
    /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */ getMaxResolution() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MAX_RESOLUTION);
    }
    /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */ getMinResolution() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MIN_RESOLUTION);
    }
    /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */ getMinZoom() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MIN_ZOOM);
    }
    /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */ getMaxZoom() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MAX_ZOOM);
    }
    /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */ getOpacity() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).OPACITY);
    }
    /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */ getVisible() {
        return /** @type {boolean} */ this.get((0, _propertyJsDefault.default).VISIBLE);
    }
    /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */ getZIndex() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).Z_INDEX);
    }
    /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */ setBackground(background) {
        this.background_ = background;
        this.changed();
    }
    /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */ setExtent(extent) {
        this.set((0, _propertyJsDefault.default).EXTENT, extent);
    }
    /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */ setMaxResolution(maxResolution) {
        this.set((0, _propertyJsDefault.default).MAX_RESOLUTION, maxResolution);
    }
    /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */ setMinResolution(minResolution) {
        this.set((0, _propertyJsDefault.default).MIN_RESOLUTION, minResolution);
    }
    /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */ setMaxZoom(maxZoom) {
        this.set((0, _propertyJsDefault.default).MAX_ZOOM, maxZoom);
    }
    /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */ setMinZoom(minZoom) {
        this.set((0, _propertyJsDefault.default).MIN_ZOOM, minZoom);
    }
    /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */ setOpacity(opacity) {
        (0, _assertsJs.assert)(typeof opacity === "number", 64); // Layer opacity must be a number
        this.set((0, _propertyJsDefault.default).OPACITY, opacity);
    }
    /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */ setVisible(visible) {
        this.set((0, _propertyJsDefault.default).VISIBLE, visible);
    }
    /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */ setZIndex(zindex) {
        this.set((0, _propertyJsDefault.default).Z_INDEX, zindex);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.state_) {
            this.state_.layer = null;
            this.state_ = null;
        }
        super.disposeInternal();
    }
}
exports.default = BaseLayer;

},{"../Object.js":"1zG8z","./Property.js":"kCuCK","../util.js":"pLBjQ","../asserts.js":"e4TiF","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kCuCK":[function(require,module,exports) {
/**
 * @module ol/layer/Property
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    OPACITY: "opacity",
    VISIBLE: "visible",
    EXTENT: "extent",
    Z_INDEX: "zIndex",
    MAX_RESOLUTION: "maxResolution",
    MIN_RESOLUTION: "minResolution",
    MAX_ZOOM: "maxZoom",
    MIN_ZOOM: "minZoom",
    SOURCE: "source",
    MAP: "map"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5G9JA":[function(require,module,exports) {
/**
 * @module ol/render/EventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */ PRERENDER: "prerender",
    /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */ POSTRENDER: "postrender",
    /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */ PRECOMPOSE: "precompose",
    /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */ POSTCOMPOSE: "postcompose",
    /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */ RENDERCOMPLETE: "rendercomplete"
}; /**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */  /**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b1I4K":[function(require,module,exports) {
/**
 * @module ol/renderer/canvas/ImageLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _imageStateJs = require("../../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _viewHintJs = require("../../ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _projJs = require("../../proj.js");
/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */ class CanvasImageLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */ constructor(imageLayer){
        super(imageLayer);
        /**
     * @protected
     * @type {?import("../../ImageBase.js").default}
     */ this.image_ = null;
    }
    /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */ getImage() {
        return !this.image_ ? null : this.image_.getImage();
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const pixelRatio = frameState.pixelRatio;
        const viewState = frameState.viewState;
        const viewResolution = viewState.resolution;
        const imageSource = this.getLayer().getSource();
        const hints = frameState.viewHints;
        let renderedExtent = frameState.extent;
        if (layerState.extent !== undefined) renderedExtent = (0, _extentJs.getIntersection)(renderedExtent, (0, _projJs.fromUserExtent)(layerState.extent, viewState.projection));
        if (!hints[(0, _viewHintJsDefault.default).ANIMATING] && !hints[(0, _viewHintJsDefault.default).INTERACTING] && !(0, _extentJs.isEmpty)(renderedExtent)) {
            if (imageSource) {
                const projection = viewState.projection;
                const image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
                if (image) {
                    if (this.loadImage(image)) this.image_ = image;
                    else if (image.getState() === (0, _imageStateJsDefault.default).EMPTY) this.image_ = null;
                }
            } else this.image_ = null;
        }
        return !!this.image_;
    }
    /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */ getData(pixel) {
        const frameState = this.frameState;
        if (!frameState) return null;
        const layer = this.getLayer();
        const coordinate = (0, _transformJs.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
        const layerExtent = layer.getExtent();
        if (layerExtent) {
            if (!(0, _extentJs.containsCoordinate)(layerExtent, coordinate)) return null;
        }
        const imageExtent = this.image_.getExtent();
        const img = this.image_.getImage();
        const imageMapWidth = (0, _extentJs.getWidth)(imageExtent);
        const col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));
        if (col < 0 || col >= img.width) return null;
        const imageMapHeight = (0, _extentJs.getHeight)(imageExtent);
        const row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));
        if (row < 0 || row >= img.height) return null;
        return this.getImageData(img, col, row);
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */ renderFrame(frameState, target) {
        const image = this.image_;
        const imageExtent = image.getExtent();
        const imageResolution = image.getResolution();
        const imagePixelRatio = image.getPixelRatio();
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const pixelRatio = frameState.pixelRatio;
        const viewState = frameState.viewState;
        const viewCenter = viewState.center;
        const viewResolution = viewState.resolution;
        const scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
        const extent = frameState.extent;
        const resolution = viewState.resolution;
        const rotation = viewState.rotation;
        // desired dimensions of the canvas in pixels
        const width = Math.round((0, _extentJs.getWidth)(extent) / resolution * pixelRatio);
        const height = Math.round((0, _extentJs.getHeight)(extent) / resolution * pixelRatio);
        // set forward and inverse pixel transforms
        (0, _transformJs.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
        (0, _transformJs.makeInverse)(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = (0, _transformJs.toString)(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
        } else if (!this.containerReused) context.clearRect(0, 0, width, height);
        // clipped rendering if layer extent is set
        let clipped = false;
        let render = true;
        if (layerState.extent) {
            const layerExtent = (0, _projJs.fromUserExtent)(layerState.extent, viewState.projection);
            render = (0, _extentJs.intersects)(layerExtent, frameState.extent);
            clipped = render && !(0, _extentJs.containsExtent)(layerExtent, frameState.extent);
            if (clipped) this.clipUnrotated(context, frameState, layerExtent);
        }
        const img = image.getImage();
        const transform = (0, _transformJs.compose)(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
        this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
        const dw = img.width * transform[0];
        const dh = img.height * transform[3];
        if (!this.getLayer().getSource().getInterpolate()) context.imageSmoothingEnabled = false;
        this.preRender(context, frameState);
        if (render && dw >= 0.5 && dh >= 0.5) {
            const dx = transform[4];
            const dy = transform[5];
            const opacity = layerState.opacity;
            let previousAlpha;
            if (opacity !== 1) {
                previousAlpha = context.globalAlpha;
                context.globalAlpha = opacity;
            }
            context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);
            if (opacity !== 1) context.globalAlpha = previousAlpha;
        }
        this.postRender(context, frameState);
        if (clipped) context.restore();
        context.imageSmoothingEnabled = true;
        if (canvasTransform !== canvas.style.transform) canvas.style.transform = canvasTransform;
        return this.container;
    }
}
exports.default = CanvasImageLayerRenderer;

},{"./Layer.js":"fY3ny","../../ImageState.js":"c4jJS","../../ViewHint.js":"6THmF","../../transform.js":"1BqUf","../../extent.js":"6YrVc","../../proj.js":"SznqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fY3ny":[function(require,module,exports) {
/**
 * @module ol/renderer/canvas/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canvasPool", ()=>canvasPool);
var _layerJs = require("../Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _eventJs = require("../../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _transformJs = require("../../transform.js");
var _colorJs = require("../../color.js");
var _domJs = require("../../dom.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
const canvasPool = [];
/**
 * @type {CanvasRenderingContext2D}
 */ let pixelContext = null;
function createPixelContext() {
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    pixelContext = canvas.getContext("2d");
}
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */ class CanvasLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super(layer);
        /**
     * @protected
     * @type {HTMLElement}
     */ this.container = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedResolution;
        /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.tempTransform = (0, _transformJs.create)();
        /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.pixelTransform = (0, _transformJs.create)();
        /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.inversePixelTransform = (0, _transformJs.create)();
        /**
     * @type {CanvasRenderingContext2D}
     */ this.context = null;
        /**
     * @type {boolean}
     */ this.containerReused = false;
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.pixelContext_ = null;
        /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */ this.frameState = null;
    }
    /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */ getImageData(image, col, row) {
        if (!pixelContext) createPixelContext();
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
            pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
            data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
            pixelContext = null;
            return null;
        }
        return data;
    }
    /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */ getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === "function") background = background(frameState.viewState.resolution);
        return background || undefined;
    }
    /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */ useContainer(target, transform, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && (0, _arrayJs.equals)((0, _colorJs.asArray)(target.style.backgroundColor), (0, _colorJs.asArray)(backgroundColor)))) {
            const canvas = target.firstElementChild;
            if (canvas instanceof HTMLCanvasElement) context = canvas.getContext("2d");
        }
        if (context && context.canvas.style.transform === transform) {
            // Container of the previous layer renderer can be used.
            this.container = target;
            this.context = context;
            this.containerReused = true;
        } else if (this.containerReused) {
            // Previously reused container cannot be used any more.
            this.container = null;
            this.context = null;
            this.containerReused = false;
        }
        if (!this.container) {
            container = document.createElement("div");
            container.className = layerClassName;
            let style = container.style;
            style.position = "absolute";
            style.width = "100%";
            style.height = "100%";
            context = (0, _domJs.createCanvasContext2D)();
            const canvas1 = context.canvas;
            container.appendChild(canvas1);
            style = canvas1.style;
            style.position = "absolute";
            style.left = "0";
            style.transformOrigin = "top left";
            this.container = container;
            this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) this.container.style.backgroundColor = backgroundColor;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */ clipUnrotated(context, frameState, extent) {
        const topLeft = (0, _extentJs.getTopLeft)(extent);
        const topRight = (0, _extentJs.getTopRight)(extent);
        const bottomRight = (0, _extentJs.getBottomRight)(extent);
        const bottomLeft = (0, _extentJs.getBottomLeft)(extent);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, topLeft);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, topRight);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, bottomRight);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        (0, _transformJs.apply)(inverted, topLeft);
        (0, _transformJs.apply)(inverted, topRight);
        (0, _transformJs.apply)(inverted, bottomRight);
        (0, _transformJs.apply)(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
    }
    /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */ dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
            const event = new (0, _eventJsDefault.default)(type, this.inversePixelTransform, frameState, context);
            layer.dispatchEvent(event);
        }
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ preRender(context, frameState) {
        this.frameState = frameState;
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).PRERENDER, context, frameState);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ postRender(context, frameState) {
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).POSTRENDER, context, frameState);
    }
    /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */ getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return (0, _transformJs.compose)(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
    }
}
exports.default = CanvasLayerRenderer;

},{"../Layer.js":"b6gGa","../../render/Event.js":"bpzid","../../render/EventType.js":"5G9JA","../../transform.js":"1BqUf","../../color.js":"4tahz","../../dom.js":"84QzQ","../../array.js":"1Fbic","../../extent.js":"6YrVc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6gGa":[function(require,module,exports) {
/**
 * @module ol/renderer/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _observableJs = require("../Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _utilJs = require("../util.js");
/**
 * @template {import("../layer/Layer.js").default} LayerType
 */ class LayerRenderer extends (0, _observableJsDefault.default) {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super();
        /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */ this.ready = true;
        /** @private */ this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        /**
     * @protected
     * @type {LayerType}
     */ this.layer_ = layer;
        /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */ this.declutterExecutorGroup = null;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        return null;
    }
    /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */ renderFrame(frameState, target) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */ loadedTileCallback(tiles, zoom, tile) {
        if (!tiles[zoom]) tiles[zoom] = {};
        tiles[zoom][tile.tileCoord.toString()] = tile;
        return undefined;
    }
    /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */ createLoadedTileFinder(source, projection, tiles) {
        return(/**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       * @this {LayerRenderer}
       */ (function(zoom, tileRange) {
            const callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        }).bind(this));
    }
    /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return undefined;
    }
    /**
   * @return {LayerType} Layer.
   */ getLayer() {
        return this.layer_;
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */ handleFontsChanged() {}
    /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */ handleImageChange_(event) {
        const image = /** @type {import("../Image.js").default} */ event.target;
        if (image.getState() === (0, _imageStateJsDefault.default).LOADED) this.renderIfReadyAndVisible();
    }
    /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */ loadImage(image) {
        let imageState = image.getState();
        if (imageState != (0, _imageStateJsDefault.default).LOADED && imageState != (0, _imageStateJsDefault.default).ERROR) image.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleImageChange_);
        if (imageState == (0, _imageStateJsDefault.default).IDLE) {
            image.load();
            imageState = image.getState();
        }
        return imageState == (0, _imageStateJsDefault.default).LOADED;
    }
    /**
   * @protected
   */ renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === "ready") layer.changed();
    }
    /**
   * Clean up.
   */ disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
    }
}
exports.default = LayerRenderer;

},{"../events/EventType.js":"hrQJ6","../ImageState.js":"c4jJS","../Observable.js":"cQ2uI","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bpzid":[function(require,module,exports) {
/**
 * @module ol/render/Event
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
class RenderEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */ constructor(type, inversePixelTransform, frameState, context){
        super(type);
        /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */ this.inversePixelTransform = inversePixelTransform;
        /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */ this.frameState = frameState;
        /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */ this.context = context;
    }
}
exports.default = RenderEvent;

},{"../events/Event.js":"hwXQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6THmF":[function(require,module,exports) {
/**
 * @module ol/ViewHint
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ANIMATING: 0,
    INTERACTING: 1
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jelpD":[function(require,module,exports) {
/**
 * @module ol/format/MVT
 */ //FIXME Implement projection handling
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("./Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pbf = require("pbf");
var _pbfDefault = parcelHelpers.interopDefault(_pbf);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _projectionJs = require("../proj/Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
var _featureJs1 = require("../render/Feature.js");
var _featureJsDefault1 = parcelHelpers.interopDefault(_featureJs1);
var _assertsJs = require("../asserts.js");
var _projJs = require("../proj.js");
var _orientJs = require("../geom/flat/orient.js");
/**
 * @typedef {Object} Options
 * @property {import("../Feature.js").FeatureClass} [featureClass] Class for features returned by
 * {@link module:ol/format/MVT~MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry
 * support at the cost of decreased rendering performance. The default is
 * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.
 * @property {string} [geometryName='geometry'] Geometry name to use when creating features.
 * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.
 * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all
 * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.
 * layers.
 */ /**
 * @classdesc
 * Feature format for reading data in the Mapbox MVT format.
 *
 * @param {Options} [options] Options.
 * @api
 */ class MVT extends (0, _featureJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @type {Projection}
     */ this.dataProjection = new (0, _projectionJsDefault.default)({
            code: "",
            units: "tile-pixels"
        });
        /**
     * @private
     * @type {import("../Feature.js").FeatureClass}
     */ this.featureClass_ = options.featureClass ? options.featureClass : (0, _featureJsDefault1.default);
        /**
     * @private
     * @type {string|undefined}
     */ this.geometryName_ = options.geometryName;
        /**
     * @private
     * @type {string}
     */ this.layerName_ = options.layerName ? options.layerName : "layer";
        /**
     * @private
     * @type {Array<string>|null}
     */ this.layers_ = options.layers ? options.layers : null;
        /**
     * @private
     * @type {string}
     */ this.idProperty_ = options.idProperty;
        this.supportedMediaTypes = [
            "application/vnd.mapbox-vector-tile",
            "application/x-protobuf"
        ];
    }
    /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */ readRawGeometry_(pbf, feature, flatCoordinates, ends) {
        pbf.pos = feature.geometry;
        const end = pbf.readVarint() + pbf.pos;
        let cmd = 1;
        let length = 0;
        let x = 0;
        let y = 0;
        let coordsLen = 0;
        let currentEnd = 0;
        while(pbf.pos < end){
            if (!length) {
                const cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }
            length--;
            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();
                if (cmd === 1) // moveTo
                {
                    if (coordsLen > currentEnd) {
                        ends.push(coordsLen);
                        currentEnd = coordsLen;
                    }
                }
                flatCoordinates.push(x, y);
                coordsLen += 2;
            } else if (cmd === 7) {
                if (coordsLen > currentEnd) {
                    // close polygon
                    flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
                    coordsLen += 2;
                }
            } else (0, _assertsJs.assert)(false, 59); // Invalid command found in the PBF
        }
        if (coordsLen > currentEnd) {
            ends.push(coordsLen);
            currentEnd = coordsLen;
        }
    }
    /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */ createFeature_(pbf, rawFeature, options) {
        const type = rawFeature.type;
        if (type === 0) return null;
        let feature;
        const values = rawFeature.properties;
        let id;
        if (!this.idProperty_) id = rawFeature.id;
        else {
            id = values[this.idProperty_];
            delete values[this.idProperty_];
        }
        values[this.layerName_] = rawFeature.layer.name;
        const flatCoordinates = /** @type {Array<number>} */ [];
        const ends = /** @type {Array<number>} */ [];
        this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
        const geometryType = getGeometryType(type, ends.length);
        if (this.featureClass_ === (0, _featureJsDefault1.default)) {
            feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);
            feature.transform(options.dataProjection);
        } else {
            let geom;
            if (geometryType == "Polygon") {
                const endss = (0, _orientJs.inflateEnds)(flatCoordinates, ends);
                geom = endss.length > 1 ? new (0, _multiPolygonJsDefault.default)(flatCoordinates, "XY", endss) : new (0, _polygonJsDefault.default)(flatCoordinates, "XY", ends);
            } else geom = geometryType === "Point" ? new (0, _pointJsDefault.default)(flatCoordinates, "XY") : geometryType === "LineString" ? new (0, _lineStringJsDefault.default)(flatCoordinates, "XY") : geometryType === "MultiPoint" ? new (0, _multiPointJsDefault.default)(flatCoordinates, "XY") : geometryType === "MultiLineString" ? new (0, _multiLineStringJsDefault.default)(flatCoordinates, "XY", ends) : null;
            const ctor = /** @type {typeof import("../Feature.js").default} */ this.featureClass_;
            feature = new ctor();
            if (this.geometryName_) feature.setGeometryName(this.geometryName_);
            const geometry = (0, _featureJs.transformGeometryWithOptions)(geom, false, options);
            feature.setGeometry(geometry);
            if (id !== undefined) feature.setId(id);
            feature.setProperties(values, true);
        }
        return feature;
    }
    /**
   * @return {import("./Feature.js").Type} Format.
   */ getType() {
        return "arraybuffer";
    }
    /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */ readFeatures(source, options) {
        const layers = this.layers_;
        options = this.adaptOptions(options);
        const dataProjection = (0, _projJs.get)(options.dataProjection);
        dataProjection.setWorldExtent(options.extent);
        options.dataProjection = dataProjection;
        const pbf = new (0, _pbfDefault.default)(/** @type {ArrayBuffer} */ source);
        const pbfLayers = pbf.readFields(layersPBFReader, {});
        const features = [];
        for(const name in pbfLayers){
            if (layers && !layers.includes(name)) continue;
            const pbfLayer = pbfLayers[name];
            const extent = pbfLayer ? [
                0,
                0,
                pbfLayer.extent,
                pbfLayer.extent
            ] : null;
            dataProjection.setExtent(extent);
            for(let i = 0, ii = pbfLayer.length; i < ii; ++i){
                const rawFeature = readRawFeature(pbf, pbfLayer, i);
                const feature = this.createFeature_(pbf, rawFeature, options);
                if (feature !== null) features.push(feature);
            }
        }
        return features;
    }
    /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */ readProjection(source) {
        return this.dataProjection;
    }
    /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */ setLayers(layers) {
        this.layers_ = layers;
    }
}
/**
 * Reader callback for parsing layers.
 * @param {number} tag The tag.
 * @param {Object} layers The layers object.
 * @param {PBF} pbf The PBF.
 */ function layersPBFReader(tag, layers, pbf) {
    if (tag === 3) {
        const layer = {
            keys: [],
            values: [],
            features: []
        };
        const end = pbf.readVarint() + pbf.pos;
        pbf.readFields(layerPBFReader, layer, end);
        layer.length = layer.features.length;
        if (layer.length) layers[layer.name] = layer;
    }
}
/**
 * Reader callback for parsing layer.
 * @param {number} tag The tag.
 * @param {Object} layer The layer object.
 * @param {PBF} pbf The PBF.
 */ function layerPBFReader(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer.features.push(pbf.pos);
    else if (tag === 3) layer.keys.push(pbf.readString());
    else if (tag === 4) {
        let value = null;
        const end = pbf.readVarint() + pbf.pos;
        while(pbf.pos < end){
            tag = pbf.readVarint() >> 3;
            value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
        }
        layer.values.push(value);
    }
}
/**
 * Reader callback for parsing feature.
 * @param {number} tag The tag.
 * @param {Object} feature The feature object.
 * @param {PBF} pbf The PBF.
 */ function featurePBFReader(tag, feature, pbf) {
    if (tag == 1) feature.id = pbf.readVarint();
    else if (tag == 2) {
        const end = pbf.readVarint() + pbf.pos;
        while(pbf.pos < end){
            const key = feature.layer.keys[pbf.readVarint()];
            const value = feature.layer.values[pbf.readVarint()];
            feature.properties[key] = value;
        }
    } else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature.geometry = pbf.pos;
}
/**
 * Read a raw feature from the pbf offset stored at index `i` in the raw layer.
 * @param {PBF} pbf PBF.
 * @param {Object} layer Raw layer.
 * @param {number} i Index of the feature in the raw layer's `features` array.
 * @return {Object} Raw feature.
 */ function readRawFeature(pbf, layer, i) {
    pbf.pos = layer.features[i];
    const end = pbf.readVarint() + pbf.pos;
    const feature = {
        layer: layer,
        type: 0,
        properties: {}
    };
    pbf.readFields(featurePBFReader, feature, end);
    return feature;
}
/**
 * @param {number} type The raw feature's geometry type
 * @param {number} numEnds Number of ends of the flat coordinates of the
 * geometry.
 * @return {import("../geom/Geometry.js").Type} The geometry type.
 */ function getGeometryType(type, numEnds) {
    /** @type {import("../geom/Geometry.js").Type} */ let geometryType;
    if (type === 1) geometryType = numEnds === 1 ? "Point" : "MultiPoint";
    else if (type === 2) geometryType = numEnds === 1 ? "LineString" : "MultiLineString";
    else if (type === 3) geometryType = "Polygon";
    return geometryType;
}
exports.default = MVT;

},{"./Feature.js":"FZbV5","../geom/LineString.js":"jLUiq","../geom/MultiLineString.js":"030lt","../geom/MultiPoint.js":"k4LcJ","../geom/MultiPolygon.js":"2XIqx","pbf":"8013B","../geom/Point.js":"hx2Ar","../geom/Polygon.js":"cJuQF","../proj/Projection.js":"7HvLt","../render/Feature.js":"3Oc3i","../asserts.js":"e4TiF","../proj.js":"SznqC","../geom/flat/orient.js":"btd6s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8013B":[function(require,module,exports) {
"use strict";
module.exports = Pbf;
var ieee754 = require("ieee754");
function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}
Pbf.Varint = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32
var SHIFT_LEFT_32 = 4294967296, SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
// Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
Pbf.prototype = {
    destroy: function() {
        this.buf = null;
    },
    // === READING =================================================================
    readFields: function(readField, result, end) {
        end = end || this.length;
        while(this.pos < end){
            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
            this.type = val & 0x7;
            readField(tag, result, this);
            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },
    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },
    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },
    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },
    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },
    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },
    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },
    readVarint: function(isSigned) {
        var buf = this.buf, val, b;
        b = buf[this.pos++];
        val = b & 0x7f;
        if (b < 0x80) return val;
        b = buf[this.pos++];
        val |= (b & 0x7f) << 7;
        if (b < 0x80) return val;
        b = buf[this.pos++];
        val |= (b & 0x7f) << 14;
        if (b < 0x80) return val;
        b = buf[this.pos++];
        val |= (b & 0x7f) << 21;
        if (b < 0x80) return val;
        b = buf[this.pos];
        val |= (b & 0x0f) << 28;
        return readVarintRemainder(val, isSigned, this);
    },
    readVarint64: function() {
        return this.readVarint(true);
    },
    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },
    readBoolean: function() {
        return Boolean(this.readVarint());
    },
    readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) // longer strings are fast with the built-in browser TextDecoder API
        return readUtf8TextDecoder(this.buf, pos, end);
        // short strings are fast with our custom implementation
        return readUtf8(this.buf, pos, end);
    },
    readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while(this.pos < end)arr.push(this.readSFixed64());
        return arr;
    },
    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while(this.buf[this.pos++] > 0x7f);
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error("Unimplemented type: " + type);
    },
    // === WRITING =================================================================
    writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
    },
    realloc: function(min) {
        var length = this.length || 16;
        while(length < this.pos + min)length *= 2;
        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },
    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },
    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },
    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },
    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },
    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },
    writeVarint: function(val) {
        val = +val || 0;
        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 0x7f | (val > 0x7f ? 0x80 : 0);
        if (val <= 0x7f) return;
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);
        if (val <= 0x7f) return;
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);
        if (val <= 0x7f) return;
        this.buf[this.pos++] = val >>> 7 & 0x7f;
    },
    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },
    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },
    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++; // reserve 1 byte for short string length
        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);
        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },
    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },
    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },
    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for(var i = 0; i < len; i++)this.buf[this.pos++] = buffer[i];
    },
    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length
        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);
        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },
    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },
    writePackedVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
    },
    writePackedSVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
    },
    writePackedBoolean: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
    },
    writePackedFloat: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
    },
    writePackedDouble: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
    },
    writePackedFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
    },
    writePackedSFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
    },
    writePackedFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
    },
    writePackedSFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
    },
    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};
function readVarintRemainder(l, s, p) {
    var buf = p.buf, h, b;
    b = buf[p.pos++];
    h = (b & 0x70) >> 4;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 3;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 10;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 17;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x7f) << 24;
    if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 0x01) << 31;
    if (b < 0x80) return toNum(l, h, s);
    throw new Error("Expected varint not more than 10 bytes");
}
function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
}
function toNum(low, high, isSigned) {
    if (isSigned) return high * 0x100000000 + (low >>> 0);
    return (high >>> 0) * 0x100000000 + (low >>> 0);
}
function writeBigVarint(val, pbf) {
    var low, high;
    if (val >= 0) {
        low = val % 0x100000000 | 0;
        high = val / 0x100000000 | 0;
    } else {
        low = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);
        if (low ^ 0xffffffff) low = low + 1 | 0;
        else {
            low = 0;
            high = high + 1 | 0;
        }
    }
    if (val >= 0x10000000000000000 || val < -18446744073709552000) throw new Error("Given varint doesn't fit into 10 bytes");
    pbf.realloc(10);
    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}
function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
    low >>>= 7;
    pbf.buf[pbf.pos] = low & 0x7f;
}
function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;
    pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
    if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f;
}
function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen = len <= 0x3fff ? 1 : len <= 0x1fffff ? 2 : len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for(var i = pbf.pos - 1; i >= startPos; i--)pbf.buf[i + extraLen] = pbf.buf[i];
}
function writePackedVarint(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeVarint(arr[i]);
}
function writePackedSVarint(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeSVarint(arr[i]);
}
function writePackedFloat(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeFloat(arr[i]);
}
function writePackedDouble(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeDouble(arr[i]);
}
function writePackedBoolean(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeBoolean(arr[i]);
}
function writePackedFixed32(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeFixed32(arr[i]);
}
function writePackedSFixed32(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeSFixed32(arr[i]);
}
function writePackedFixed64(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeFixed64(arr[i]);
}
function writePackedSFixed64(arr, pbf) {
    for(var i = 0; i < arr.length; i++)pbf.writeSFixed64(arr[i]);
}
// Buffer code below from https://github.com/feross/buffer, MIT-licensed
function readUInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 0x1000000;
}
function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = val >>> 8;
    buf[pos + 2] = val >>> 16;
    buf[pos + 3] = val >>> 24;
}
function readInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}
function readUtf8(buf, pos, end) {
    var str = "";
    var i = pos;
    while(i < end){
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence = b0 > 0xEF ? 4 : b0 > 0xDF ? 3 : b0 > 0xBF ? 2 : 1;
        if (i + bytesPerSequence > end) break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
            if (b0 < 0x80) c = b0;
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | b1 & 0x3F;
                if (c <= 0x7F) c = null;
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | b2 & 0x3F;
                if (c <= 0x7FF || c >= 0xD800 && c <= 0xDFFF) c = null;
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | b3 & 0x3F;
                if (c <= 0xFFFF || c >= 0x110000) c = null;
            }
        }
        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;
        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }
        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }
    return str;
}
function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
}
function writeUtf8(buf, str, pos) {
    for(var i = 0, c, lead; i < str.length; i++){
        c = str.charCodeAt(i); // code point
        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || i + 1 === str.length) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else lead = c;
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }
        if (c < 0x80) buf[pos++] = c;
        else {
            if (c < 0x800) buf[pos++] = c >> 0x6 | 0xC0;
            else {
                if (c < 0x10000) buf[pos++] = c >> 0xC | 0xE0;
                else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

},{"ieee754":"cO95r"}],"cO95r":[function(require,module,exports) {
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"14YFC":[function(require,module,exports) {
/**
 * @module ol/Map
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("./CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _compositeJs = require("./renderer/Composite.js");
var _compositeJsDefault = parcelHelpers.interopDefault(_compositeJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _layerJs = require("./layer/Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _groupJs = require("./layer/Group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventHandlerJs = require("./MapBrowserEventHandler.js");
var _mapBrowserEventHandlerJsDefault = parcelHelpers.interopDefault(_mapBrowserEventHandlerJs);
var _mapBrowserEventTypeJs = require("./MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
var _mapEventTypeJs = require("./MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _mapPropertyJs = require("./MapProperty.js");
var _mapPropertyJsDefault = parcelHelpers.interopDefault(_mapPropertyJs);
var _objectEventTypeJs = require("./ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _eventTypeJs1 = require("./pointer/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _eventTypeJs2 = require("./render/EventType.js");
var _eventTypeJsDefault2 = parcelHelpers.interopDefault(_eventTypeJs2);
var _tileQueueJs = require("./TileQueue.js");
var _tileQueueJsDefault = parcelHelpers.interopDefault(_tileQueueJs);
var _viewJs = require("./View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _viewHintJs = require("./ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hasJs = require("./has.js");
var _functionsJs = require("./functions.js");
var _transformJs = require("./transform.js");
var _assertsJs = require("./asserts.js");
var _extentJs = require("./extent.js");
var _defaultsJs = require("./control/defaults.js");
var _defaultsJs1 = require("./interaction/defaults.js");
var _projJs = require("./proj.js");
var _utilJs = require("./util.js");
var _sizeJs = require("./size.js");
var _eventsJs = require("./events.js");
var _domJs = require("./dom.js");
/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent.
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */ /**
 * @typedef {function(Map, ?FrameState): any} PostRenderFunction
 */ /**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */ /**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */ /**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
 */ /**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/defaults.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction/defaults.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */ /**
 * @param {import("./layer/Base.js").default} layer Layer.
 */ function removeLayerMapProperty(layer) {
    if (layer instanceof (0, _layerJsDefault.default)) {
        layer.setMapInternal(null);
        return;
    }
    if (layer instanceof (0, _groupJsDefault.default)) layer.getLayers().forEach(removeLayerMapProperty);
}
/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {Map} map Map.
 */ function setLayerMapProperty(layer, map) {
    if (layer instanceof (0, _layerJsDefault.default)) {
        layer.setMapInternal(map);
        return;
    }
    if (layer instanceof (0, _groupJsDefault.default)) {
        const layers = layer.getLayers().getArray();
        for(let i = 0, ii = layers.length; i < ii; ++i)setLayerMapProperty(layers[i], map);
    }
}
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */ class Map extends (0, _objectJsDefault.default) {
    /**
   * @param {MapOptions} [options] Map options.
   */ constructor(options){
        super();
        options = options || {};
        /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {MapEventHandler<void>}
     */ this.un;
        const optionsInternal = createOptionsInternal(options);
        /**
     * @private
     * @type {boolean|undefined}
     */ this.renderComplete_;
        /**
     * @private
     * @type {boolean}
     */ this.loaded_ = true;
        /** @private */ this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
        /**
     * @type {number}
     * @private
     */ this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : (0, _hasJs.DEVICE_PIXEL_RATIO);
        /**
     * @private
     * @type {*}
     */ this.postRenderTimeoutHandle_;
        /**
     * @private
     * @type {number|undefined}
     */ this.animationDelayKey_;
        /**
     * @private
     */ this.animationDelay_ = this.animationDelay_.bind(this);
        /**
     * @private
     * @type {import("./transform.js").Transform}
     */ this.coordinateToPixelTransform_ = (0, _transformJs.create)();
        /**
     * @private
     * @type {import("./transform.js").Transform}
     */ this.pixelToCoordinateTransform_ = (0, _transformJs.create)();
        /**
     * @private
     * @type {number}
     */ this.frameIndex_ = 0;
        /**
     * @private
     * @type {?FrameState}
     */ this.frameState_ = null;
        /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */ this.previousExtent_ = null;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.viewPropertyListenerKey_ = null;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.viewChangeListenerKey_ = null;
        /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */ this.layerGroupPropertyListenerKeys_ = null;
        /**
     * @private
     * @type {!HTMLElement}
     */ this.viewport_ = document.createElement("div");
        this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
        this.viewport_.style.position = "relative";
        this.viewport_.style.overflow = "hidden";
        this.viewport_.style.width = "100%";
        this.viewport_.style.height = "100%";
        /**
     * @private
     * @type {!HTMLElement}
     */ this.overlayContainer_ = document.createElement("div");
        this.overlayContainer_.style.position = "absolute";
        this.overlayContainer_.style.zIndex = "0";
        this.overlayContainer_.style.width = "100%";
        this.overlayContainer_.style.height = "100%";
        this.overlayContainer_.style.pointerEvents = "none";
        this.overlayContainer_.className = "ol-overlaycontainer";
        this.viewport_.appendChild(this.overlayContainer_);
        /**
     * @private
     * @type {!HTMLElement}
     */ this.overlayContainerStopEvent_ = document.createElement("div");
        this.overlayContainerStopEvent_.style.position = "absolute";
        this.overlayContainerStopEvent_.style.zIndex = "0";
        this.overlayContainerStopEvent_.style.width = "100%";
        this.overlayContainerStopEvent_.style.height = "100%";
        this.overlayContainerStopEvent_.style.pointerEvents = "none";
        this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
        this.viewport_.appendChild(this.overlayContainerStopEvent_);
        /**
     * @private
     * @type {MapBrowserEventHandler}
     */ this.mapBrowserEventHandler_ = null;
        /**
     * @private
     * @type {number}
     */ this.moveTolerance_ = options.moveTolerance;
        /**
     * @private
     * @type {HTMLElement|Document}
     */ this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
        /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */ this.targetChangeHandlerKeys_ = null;
        /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */ this.controls = optionsInternal.controls || (0, _defaultsJs.defaults)();
        /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */ this.interactions = optionsInternal.interactions || (0, _defaultsJs1.defaults)({
            onFocusOnly: true
        });
        /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */ this.overlays_ = optionsInternal.overlays;
        /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */ this.overlayIdIndex_ = {};
        /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */ this.renderer_ = null;
        /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */ this.postRenderFunctions_ = [];
        /**
     * @private
     * @type {TileQueue}
     */ this.tileQueue_ = new (0, _tileQueueJsDefault.default)(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));
        this.addChangeListener((0, _mapPropertyJsDefault.default).LAYERGROUP, this.handleLayerGroupChanged_);
        this.addChangeListener((0, _mapPropertyJsDefault.default).VIEW, this.handleViewChanged_);
        this.addChangeListener((0, _mapPropertyJsDefault.default).SIZE, this.handleSizeChanged_);
        this.addChangeListener((0, _mapPropertyJsDefault.default).TARGET, this.handleTargetChanged_);
        // setProperties will trigger the rendering of the map if the map
        // is "defined" already.
        this.setProperties(optionsInternal.values);
        const map = this;
        if (options.view && !(options.view instanceof (0, _viewJsDefault.default))) options.view.then(function(viewOptions) {
            map.setView(new (0, _viewJsDefault.default)(viewOptions));
        });
        this.controls.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */ (function(event) {
            event.element.setMap(this);
        }).bind(this));
        this.controls.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */ (function(event) {
            event.element.setMap(null);
        }).bind(this));
        this.interactions.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */ (function(event) {
            event.element.setMap(this);
        }).bind(this));
        this.interactions.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */ (function(event) {
            event.element.setMap(null);
        }).bind(this));
        this.overlays_.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */ (function(event) {
            this.addOverlayInternal_(event.element);
        }).bind(this));
        this.overlays_.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */ (function(event) {
            const id = event.element.getId();
            if (id !== undefined) delete this.overlayIdIndex_[id.toString()];
            event.element.setMap(null);
        }).bind(this));
        this.controls.forEach(/**
       * @param {import("./control/Control.js").default} control Control.
       * @this {Map}
       */ (function(control) {
            control.setMap(this);
        }).bind(this));
        this.interactions.forEach(/**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       * @this {Map}
       */ (function(interaction) {
            interaction.setMap(this);
        }).bind(this));
        this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */ addControl(control) {
        this.getControls().push(control);
    }
    /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */ addInteraction(interaction) {
        this.getInteractions().push(interaction);
    }
    /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */ addLayer(layer) {
        const layers = this.getLayerGroup().getLayers();
        layers.push(layer);
    }
    /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */ handleLayerAdd_(event) {
        setLayerMapProperty(event.layer, this);
    }
    /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */ addOverlay(overlay) {
        this.getOverlays().push(overlay);
    }
    /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */ addOverlayInternal_(overlay) {
        const id = overlay.getId();
        if (id !== undefined) this.overlayIdIndex_[id.toString()] = overlay;
        overlay.setMap(this);
    }
    /**
   *
   * Clean up.
   */ disposeInternal() {
        this.controls.clear();
        this.interactions.clear();
        this.overlays_.clear();
        this.setTarget(null);
        super.disposeInternal();
    }
    /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */ forEachFeatureAtPixel(pixel, callback, options) {
        if (!this.frameState_ || !this.renderer_) return;
        const coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        const layerFilter = options.layerFilter !== undefined ? options.layerFilter : (0, _functionsJs.TRUE);
        const checkWrapped = options.checkWrapped !== false;
        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
    }
    /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */ getFeaturesAtPixel(pixel, options) {
        const features = [];
        this.forEachFeatureAtPixel(pixel, function(feature) {
            features.push(feature);
        }, options);
        return features;
    }
    /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */ getAllLayers() {
        const layers = [];
        function addLayersFrom(layerGroup) {
            layerGroup.forEach(function(layer) {
                if (layer instanceof (0, _groupJsDefault.default)) addLayersFrom(layer.getLayers());
                else layers.push(layer);
            });
        }
        addLayersFrom(this.getLayers());
        return layers;
    }
    /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */ hasFeatureAtPixel(pixel, options) {
        if (!this.frameState_ || !this.renderer_) return false;
        const coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        const layerFilter = options.layerFilter !== undefined ? options.layerFilter : (0, _functionsJs.TRUE);
        const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        const checkWrapped = options.checkWrapped !== false;
        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
    }
    /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */ getEventCoordinate(event) {
        return this.getCoordinateFromPixel(this.getEventPixel(event));
    }
    /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */ getEventCoordinateInternal(event) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    }
    /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */ getEventPixel(event) {
        const viewportPosition = this.viewport_.getBoundingClientRect();
        const eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
        "changedTouches" in event ? /** @type {TouchEvent} */ event.changedTouches[0] : /** @type {MouseEvent} */ event;
        return [
            eventPosition.clientX - viewportPosition.left,
            eventPosition.clientY - viewportPosition.top
        ];
    }
    /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */ getTarget() {
        return /** @type {HTMLElement|string|undefined} */ this.get((0, _mapPropertyJsDefault.default).TARGET);
    }
    /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */ getTargetElement() {
        const target = this.getTarget();
        if (target !== undefined) return typeof target === "string" ? document.getElementById(target) : target;
        else return null;
    }
    /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */ getCoordinateFromPixel(pixel) {
        return (0, _projJs.toUserCoordinate)(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
    }
    /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */ getCoordinateFromPixelInternal(pixel) {
        const frameState = this.frameState_;
        if (!frameState) return null;
        else return (0, _transformJs.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    }
    /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */ getControls() {
        return this.controls;
    }
    /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */ getOverlays() {
        return this.overlays_;
    }
    /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */ getOverlayById(id) {
        const overlay = this.overlayIdIndex_[id.toString()];
        return overlay !== undefined ? overlay : null;
    }
    /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */ getInteractions() {
        return this.interactions;
    }
    /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */ getLayerGroup() {
        return /** @type {LayerGroup} */ this.get((0, _mapPropertyJsDefault.default).LAYERGROUP);
    }
    /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */ setLayers(layers) {
        const group = this.getLayerGroup();
        if (layers instanceof (0, _collectionJsDefault.default)) {
            group.setLayers(layers);
            return;
        }
        const collection = group.getLayers();
        collection.clear();
        collection.extend(layers);
    }
    /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */ getLayers() {
        const layers = this.getLayerGroup().getLayers();
        return layers;
    }
    /**
   * @return {boolean} Layers have sources that are still loading.
   */ getLoadingOrNotReady() {
        const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
        for(let i = 0, ii = layerStatesArray.length; i < ii; ++i){
            const state = layerStatesArray[i];
            if (!state.visible) continue;
            const renderer = state.layer.getRenderer();
            if (renderer && !renderer.ready) return true;
            const source = state.layer.getSource();
            if (source && source.loading) return true;
        }
        return false;
    }
    /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */ getPixelFromCoordinate(coordinate) {
        const viewCoordinate = (0, _projJs.fromUserCoordinate)(coordinate, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(viewCoordinate);
    }
    /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */ getPixelFromCoordinateInternal(coordinate) {
        const frameState = this.frameState_;
        if (!frameState) return null;
        else return (0, _transformJs.apply)(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
    /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */ getRenderer() {
        return this.renderer_;
    }
    /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */ getSize() {
        return /** @type {import("./size.js").Size|undefined} */ this.get((0, _mapPropertyJsDefault.default).SIZE);
    }
    /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */ getView() {
        return /** @type {View} */ this.get((0, _mapPropertyJsDefault.default).VIEW);
    }
    /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */ getViewport() {
        return this.viewport_;
    }
    /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */ getOverlayContainer() {
        return this.overlayContainer_;
    }
    /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */ getOverlayContainerStopEvent() {
        return this.overlayContainerStopEvent_;
    }
    /**
   * @return {!Document} The document where the map is displayed.
   */ getOwnerDocument() {
        const targetElement = this.getTargetElement();
        return targetElement ? targetElement.ownerDocument : document;
    }
    /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */ getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
        return (0, _tileQueueJs.getTilePriority)(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
    }
    /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */ handleBrowserEvent(browserEvent, type) {
        type = type || browserEvent.type;
        const mapBrowserEvent = new (0, _mapBrowserEventJsDefault.default)(type, this, browserEvent);
        this.handleMapBrowserEvent(mapBrowserEvent);
    }
    /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */ handleMapBrowserEvent(mapBrowserEvent) {
        if (!this.frameState_) // With no view defined, we cannot translate pixels into geographical
        // coordinates so interactions cannot be used.
        return;
        const originalEvent = /** @type {PointerEvent} */ mapBrowserEvent.originalEvent;
        const eventType = originalEvent.type;
        if (eventType === (0, _eventTypeJsDefault1.default).POINTERDOWN || eventType === (0, _eventTypeJsDefault.default).WHEEL || eventType === (0, _eventTypeJsDefault.default).KEYDOWN) {
            const doc = this.getOwnerDocument();
            const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
            const target = /** @type {Node} */ originalEvent.target;
            if (// Abort if the target is a child of the container for elements whose events are not meant
            // to be handled by map interactions.
            this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
            // It's possible for the target to no longer be in the page if it has been removed in an
            // event listener, this might happen in a Control that recreates it's content based on
            // user interaction either manually or via a render in something like https://reactjs.org/
            !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) return;
        }
        mapBrowserEvent.frameState = this.frameState_;
        if (this.dispatchEvent(mapBrowserEvent) !== false) {
            const interactionsArray = this.getInteractions().getArray().slice();
            for(let i = interactionsArray.length - 1; i >= 0; i--){
                const interaction = interactionsArray[i];
                if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) continue;
                const cont = interaction.handleEvent(mapBrowserEvent);
                if (!cont || mapBrowserEvent.propagationStopped) break;
            }
        }
    }
    /**
   * @protected
   */ handlePostRender() {
        const frameState = this.frameState_;
        // Manage the tile queue
        // Image loads are expensive and a limited resource, so try to use them
        // efficiently:
        // * When the view is static we allow a large number of parallel tile loads
        //   to complete the frame as quickly as possible.
        // * When animating or interacting, image loads can cause janks, so we reduce
        //   the maximum number of loads per frame and limit the number of parallel
        //   tile loads to remain reactive to view changes and to reduce the chance of
        //   loading tiles that will quickly disappear from view.
        const tileQueue = this.tileQueue_;
        if (!tileQueue.isEmpty()) {
            let maxTotalLoading = this.maxTilesLoading_;
            let maxNewLoads = maxTotalLoading;
            if (frameState) {
                const hints = frameState.viewHints;
                if (hints[(0, _viewHintJsDefault.default).ANIMATING] || hints[(0, _viewHintJsDefault.default).INTERACTING]) {
                    const lowOnFrameBudget = Date.now() - frameState.time > 8;
                    maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                    maxNewLoads = lowOnFrameBudget ? 0 : 2;
                }
            }
            if (tileQueue.getTilesLoading() < maxTotalLoading) {
                tileQueue.reprioritize(); // FIXME only call if view has changed
                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
            }
        }
        if (frameState && this.renderer_ && !frameState.animate) {
            if (this.renderComplete_ === true) {
                if (this.hasListener((0, _eventTypeJsDefault2.default).RENDERCOMPLETE)) this.renderer_.dispatchRenderEvent((0, _eventTypeJsDefault2.default).RENDERCOMPLETE, frameState);
                if (this.loaded_ === false) {
                    this.loaded_ = true;
                    this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).LOADEND, this, frameState));
                }
            } else if (this.loaded_ === true) {
                this.loaded_ = false;
                this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).LOADSTART, this, frameState));
            }
        }
        const postRenderFunctions = this.postRenderFunctions_;
        for(let i = 0, ii = postRenderFunctions.length; i < ii; ++i)postRenderFunctions[i](this, frameState);
        postRenderFunctions.length = 0;
    }
    /**
   * @private
   */ handleSizeChanged_() {
        if (this.getView() && !this.getView().getAnimating()) this.getView().resolveConstraints(0);
        this.render();
    }
    /**
   * @private
   */ handleTargetChanged_() {
        if (this.mapBrowserEventHandler_) {
            for(let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i)(0, _eventsJs.unlistenByKey)(this.targetChangeHandlerKeys_[i]);
            this.targetChangeHandlerKeys_ = null;
            this.viewport_.removeEventListener((0, _eventTypeJsDefault.default).CONTEXTMENU, this.boundHandleBrowserEvent_);
            this.viewport_.removeEventListener((0, _eventTypeJsDefault.default).WHEEL, this.boundHandleBrowserEvent_);
            this.mapBrowserEventHandler_.dispose();
            this.mapBrowserEventHandler_ = null;
            (0, _domJs.removeNode)(this.viewport_);
        }
        // target may be undefined, null, a string or an Element.
        // If it's a string we convert it to an Element before proceeding.
        // If it's not now an Element we remove the viewport from the DOM.
        // If it's an Element we append the viewport element to it.
        const targetElement = this.getTargetElement();
        if (!targetElement) {
            if (this.renderer_) {
                clearTimeout(this.postRenderTimeoutHandle_);
                this.postRenderTimeoutHandle_ = undefined;
                this.postRenderFunctions_.length = 0;
                this.renderer_.dispose();
                this.renderer_ = null;
            }
            if (this.animationDelayKey_) {
                cancelAnimationFrame(this.animationDelayKey_);
                this.animationDelayKey_ = undefined;
            }
        } else {
            targetElement.appendChild(this.viewport_);
            if (!this.renderer_) this.renderer_ = new (0, _compositeJsDefault.default)(this);
            this.mapBrowserEventHandler_ = new (0, _mapBrowserEventHandlerJsDefault.default)(this, this.moveTolerance_);
            for(const key in 0, _mapBrowserEventTypeJsDefault.default)this.mapBrowserEventHandler_.addEventListener((0, _mapBrowserEventTypeJsDefault.default)[key], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener((0, _eventTypeJsDefault.default).CONTEXTMENU, this.boundHandleBrowserEvent_, false);
            this.viewport_.addEventListener((0, _eventTypeJsDefault.default).WHEEL, this.boundHandleBrowserEvent_, (0, _hasJs.PASSIVE_EVENT_LISTENERS) ? {
                passive: false
            } : false);
            const defaultView = this.getOwnerDocument().defaultView;
            const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
            this.targetChangeHandlerKeys_ = [
                (0, _eventsJs.listen)(keyboardEventTarget, (0, _eventTypeJsDefault.default).KEYDOWN, this.handleBrowserEvent, this),
                (0, _eventsJs.listen)(keyboardEventTarget, (0, _eventTypeJsDefault.default).KEYPRESS, this.handleBrowserEvent, this),
                (0, _eventsJs.listen)(defaultView, (0, _eventTypeJsDefault.default).RESIZE, this.updateSize, this)
            ];
        }
        this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
    }
    /**
   * @private
   */ handleTileChange_() {
        this.render();
    }
    /**
   * @private
   */ handleViewPropertyChanged_() {
        this.render();
    }
    /**
   * @private
   */ handleViewChanged_() {
        if (this.viewPropertyListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.viewPropertyListenerKey_);
            this.viewPropertyListenerKey_ = null;
        }
        if (this.viewChangeListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.viewChangeListenerKey_);
            this.viewChangeListenerKey_ = null;
        }
        const view = this.getView();
        if (view) {
            this.updateViewportSize_();
            this.viewPropertyListenerKey_ = (0, _eventsJs.listen)(view, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
            this.viewChangeListenerKey_ = (0, _eventsJs.listen)(view, (0, _eventTypeJsDefault.default).CHANGE, this.handleViewPropertyChanged_, this);
            view.resolveConstraints(0);
        }
        this.render();
    }
    /**
   * @private
   */ handleLayerGroupChanged_() {
        if (this.layerGroupPropertyListenerKeys_) {
            this.layerGroupPropertyListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
            this.layerGroupPropertyListenerKeys_ = null;
        }
        const layerGroup = this.getLayerGroup();
        if (layerGroup) {
            this.handleLayerAdd_(new (0, _groupJs.GroupEvent)("addlayer", layerGroup));
            this.layerGroupPropertyListenerKeys_ = [
                (0, _eventsJs.listen)(layerGroup, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.render, this),
                (0, _eventsJs.listen)(layerGroup, (0, _eventTypeJsDefault.default).CHANGE, this.render, this),
                (0, _eventsJs.listen)(layerGroup, "addlayer", this.handleLayerAdd_, this),
                (0, _eventsJs.listen)(layerGroup, "removelayer", this.handleLayerRemove_, this)
            ];
        }
        this.render();
    }
    /**
   * @return {boolean} Is rendered.
   */ isRendered() {
        return !!this.frameState_;
    }
    /**
   * @private
   */ animationDelay_() {
        this.animationDelayKey_ = undefined;
        this.renderFrame_(Date.now());
    }
    /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */ renderSync() {
        if (this.animationDelayKey_) cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelay_();
    }
    /**
   * Redraws all text after new fonts have loaded
   */ redrawText() {
        const layerStates = this.getLayerGroup().getLayerStatesArray();
        for(let i = 0, ii = layerStates.length; i < ii; ++i){
            const layer = layerStates[i].layer;
            if (layer.hasRenderer()) layer.getRenderer().handleFontsChanged();
        }
    }
    /**
   * Request a map rendering (at the next animation frame).
   * @api
   */ render() {
        if (this.renderer_ && this.animationDelayKey_ === undefined) this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
    /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */ removeControl(control) {
        return this.getControls().remove(control);
    }
    /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */ removeInteraction(interaction) {
        return this.getInteractions().remove(interaction);
    }
    /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */ removeLayer(layer) {
        const layers = this.getLayerGroup().getLayers();
        return layers.remove(layer);
    }
    /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */ handleLayerRemove_(event) {
        removeLayerMapProperty(event.layer);
    }
    /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */ removeOverlay(overlay) {
        return this.getOverlays().remove(overlay);
    }
    /**
   * @param {number} time Time.
   * @private
   */ renderFrame_(time) {
        const size = this.getSize();
        const view = this.getView();
        const previousFrameState = this.frameState_;
        /** @type {?FrameState} */ let frameState = null;
        if (size !== undefined && (0, _sizeJs.hasArea)(size) && view && view.isDef()) {
            const viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
            const viewState = view.getState();
            frameState = {
                animate: false,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: (0, _extentJs.getForViewAndSize)(viewState.center, viewState.resolution, viewState.rotation, size),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: size,
                tileQueue: this.tileQueue_,
                time: time,
                usedTiles: {},
                viewState: viewState,
                viewHints: viewHints,
                wantedTiles: {},
                mapId: (0, _utilJs.getUid)(this),
                renderTargets: {}
            };
            if (viewState.nextCenter && viewState.nextResolution) {
                const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
                frameState.nextExtent = (0, _extentJs.getForViewAndSize)(viewState.nextCenter, viewState.nextResolution, rotation, size);
            }
        }
        this.frameState_ = frameState;
        this.renderer_.renderFrame(frameState);
        if (frameState) {
            if (frameState.animate) this.render();
            Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
            if (previousFrameState) {
                const moveStart = !this.previousExtent_ || !(0, _extentJs.isEmpty)(this.previousExtent_) && !(0, _extentJs.equals)(frameState.extent, this.previousExtent_);
                if (moveStart) {
                    this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).MOVESTART, this, previousFrameState));
                    this.previousExtent_ = (0, _extentJs.createOrUpdateEmpty)(this.previousExtent_);
                }
            }
            const idle = this.previousExtent_ && !frameState.viewHints[(0, _viewHintJsDefault.default).ANIMATING] && !frameState.viewHints[(0, _viewHintJsDefault.default).INTERACTING] && !(0, _extentJs.equals)(frameState.extent, this.previousExtent_);
            if (idle) {
                this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).MOVEEND, this, frameState));
                (0, _extentJs.clone)(frameState.extent, this.previousExtent_);
            }
        }
        this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).POSTRENDER, this, frameState));
        this.renderComplete_ = this.hasListener((0, _mapEventTypeJsDefault.default).LOADSTART) || this.hasListener((0, _mapEventTypeJsDefault.default).LOADEND) || this.hasListener((0, _eventTypeJsDefault2.default).RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : undefined;
        if (!this.postRenderTimeoutHandle_) this.postRenderTimeoutHandle_ = setTimeout(()=>{
            this.postRenderTimeoutHandle_ = undefined;
            this.handlePostRender();
        }, 0);
    }
    /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */ setLayerGroup(layerGroup) {
        const oldLayerGroup = this.getLayerGroup();
        if (oldLayerGroup) this.handleLayerRemove_(new (0, _groupJs.GroupEvent)("removelayer", oldLayerGroup));
        this.set((0, _mapPropertyJsDefault.default).LAYERGROUP, layerGroup);
    }
    /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */ setSize(size) {
        this.set((0, _mapPropertyJsDefault.default).SIZE, size);
    }
    /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */ setTarget(target) {
        this.set((0, _mapPropertyJsDefault.default).TARGET, target);
    }
    /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */ setView(view) {
        if (!view || view instanceof (0, _viewJsDefault.default)) {
            this.set((0, _mapPropertyJsDefault.default).VIEW, view);
            return;
        }
        this.set((0, _mapPropertyJsDefault.default).VIEW, new (0, _viewJsDefault.default)());
        const map = this;
        view.then(function(viewOptions) {
            map.setView(new (0, _viewJsDefault.default)(viewOptions));
        });
    }
    /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */ updateSize() {
        const targetElement = this.getTargetElement();
        let size = undefined;
        if (targetElement) {
            const computedStyle = getComputedStyle(targetElement);
            const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
            const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
            if (!isNaN(width) && !isNaN(height)) {
                size = [
                    width,
                    height
                ];
                if (!(0, _sizeJs.hasArea)(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) // eslint-disable-next-line
                console.warn("No map visible because the map container's width or height are 0.");
            }
        }
        this.setSize(size);
        this.updateViewportSize_();
    }
    /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */ updateViewportSize_() {
        const view = this.getView();
        if (view) {
            let size = undefined;
            const computedStyle = getComputedStyle(this.viewport_);
            if (computedStyle.width && computedStyle.height) size = [
                parseInt(computedStyle.width, 10),
                parseInt(computedStyle.height, 10)
            ];
            view.setViewportSize(size);
        }
    }
}
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */ function createOptionsInternal(options) {
    /**
   * @type {HTMLElement|Document}
   */ let keyboardEventTarget = null;
    if (options.keyboardEventTarget !== undefined) keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
    /**
   * @type {Object<string, *>}
   */ const values = {};
    const layerGroup = options.layers && typeof /** @type {?} */ options.layers.getLayers === "function" ? /** @type {LayerGroup} */ options.layers : new (0, _groupJsDefault.default)({
        layers: /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */ options.layers
    });
    values[(0, _mapPropertyJsDefault.default).LAYERGROUP] = layerGroup;
    values[(0, _mapPropertyJsDefault.default).TARGET] = options.target;
    values[(0, _mapPropertyJsDefault.default).VIEW] = options.view instanceof (0, _viewJsDefault.default) ? options.view : new (0, _viewJsDefault.default)();
    /** @type {Collection<import("./control/Control.js").default>} */ let controls;
    if (options.controls !== undefined) {
        if (Array.isArray(options.controls)) controls = new (0, _collectionJsDefault.default)(options.controls.slice());
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ options.controls.getArray === "function", 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
            controls = options.controls;
        }
    }
    /** @type {Collection<import("./interaction/Interaction").default>} */ let interactions;
    if (options.interactions !== undefined) {
        if (Array.isArray(options.interactions)) interactions = new (0, _collectionJsDefault.default)(options.interactions.slice());
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ options.interactions.getArray === "function", 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
            interactions = options.interactions;
        }
    }
    /** @type {Collection<import("./Overlay.js").default>} */ let overlays;
    if (options.overlays !== undefined) {
        if (Array.isArray(options.overlays)) overlays = new (0, _collectionJsDefault.default)(options.overlays.slice());
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ options.overlays.getArray === "function", 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
            overlays = options.overlays;
        }
    } else overlays = new (0, _collectionJsDefault.default)();
    return {
        controls: controls,
        interactions: interactions,
        keyboardEventTarget: keyboardEventTarget,
        overlays: overlays,
        values: values
    };
}
exports.default = Map;

},{"./Object.js":"1zG8z","./Collection.js":"gReoh","./CollectionEventType.js":"82Ksf","./renderer/Composite.js":"fRfJ1","./events/EventType.js":"hrQJ6","./layer/Layer.js":"8J9Kf","./layer/Group.js":"h4ZNC","./MapBrowserEvent.js":"32Can","./MapBrowserEventHandler.js":"b2FtY","./MapBrowserEventType.js":"fB9ae","./MapEvent.js":"1APU6","./MapEventType.js":"1cFF9","./MapProperty.js":"jMfsr","./ObjectEventType.js":"f2U6i","./pointer/EventType.js":"cVfVH","./render/EventType.js":"5G9JA","./TileQueue.js":"iKkF5","./View.js":"8xbkS","./ViewHint.js":"6THmF","./has.js":"6BDNi","./functions.js":"iqv8I","./transform.js":"1BqUf","./asserts.js":"e4TiF","./extent.js":"6YrVc","./control/defaults.js":"kVrDf","./interaction/defaults.js":"1L9Hg","./proj.js":"SznqC","./util.js":"pLBjQ","./size.js":"lKEPe","./events.js":"dcspA","./dom.js":"84QzQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gReoh":[function(require,module,exports) {
/**
 * @module ol/Collection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */ parcelHelpers.export(exports, "CollectionEvent", ()=>CollectionEvent);
var _assertionErrorJs = require("./AssertionError.js");
var _assertionErrorJsDefault = parcelHelpers.interopDefault(_assertionErrorJs);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _collectionEventTypeJs = require("./CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
/**
 * @enum {string}
 * @private
 */ const Property = {
    LENGTH: "length"
};
class CollectionEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */ constructor(type, element, index){
        super(type);
        /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */ this.element = element;
        /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */ this.index = index;
    }
}
/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */ /**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */ class Collection extends (0, _objectJsDefault.default) {
    /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */ constructor(array, options){
        super();
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {CollectionOnSignature<T, void>}
     */ this.un;
        options = options || {};
        /**
     * @private
     * @type {boolean}
     */ this.unique_ = !!options.unique;
        /**
     * @private
     * @type {!Array<T>}
     */ this.array_ = array ? array : [];
        if (this.unique_) for(let i = 0, ii = this.array_.length; i < ii; ++i)this.assertUnique_(this.array_[i], i);
        this.updateLength_();
    }
    /**
   * Remove all elements from the collection.
   * @api
   */ clear() {
        while(this.getLength() > 0)this.pop();
    }
    /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */ extend(arr) {
        for(let i = 0, ii = arr.length; i < ii; ++i)this.push(arr[i]);
        return this;
    }
    /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */ forEach(f) {
        const array = this.array_;
        for(let i = 0, ii = array.length; i < ii; ++i)f(array[i], i, array);
    }
    /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */ getArray() {
        return this.array_;
    }
    /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */ item(index) {
        return this.array_[index];
    }
    /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */ getLength() {
        return this.get(Property.LENGTH);
    }
    /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) throw new Error("Index out of bounds: " + index);
        if (this.unique_) this.assertUnique_(elem);
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent((0, _collectionEventTypeJsDefault.default).ADD, elem, index));
    }
    /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */ pop() {
        return this.removeAt(this.getLength() - 1);
    }
    /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */ push(elem) {
        if (this.unique_) this.assertUnique_(elem);
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
    }
    /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */ remove(elem) {
        const arr = this.array_;
        for(let i = 0, ii = arr.length; i < ii; ++i){
            if (arr[i] === elem) return this.removeAt(i);
        }
        return undefined;
    }
    /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */ removeAt(index) {
        if (index < 0 || index >= this.getLength()) return undefined;
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).REMOVE, prev, index));
        return prev;
    }
    /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
            this.insertAt(index, elem);
            return;
        }
        if (index < 0) throw new Error("Index out of bounds: " + index);
        if (this.unique_) this.assertUnique_(elem, index);
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).REMOVE, prev, index));
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).ADD, elem, index));
    }
    /**
   * @private
   */ updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
    }
    /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */ assertUnique_(elem, except) {
        for(let i = 0, ii = this.array_.length; i < ii; ++i){
            if (this.array_[i] === elem && i !== except) throw new (0, _assertionErrorJsDefault.default)(58);
        }
    }
}
exports.default = Collection;

},{"./AssertionError.js":"1MBbN","./Object.js":"1zG8z","./CollectionEventType.js":"82Ksf","./events/Event.js":"hwXQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82Ksf":[function(require,module,exports) {
/**
 * @module ol/CollectionEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */ ADD: "add",
    /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */ REMOVE: "remove"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fRfJ1":[function(require,module,exports) {
/**
 * @module ol/renderer/Composite
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _eventJs = require("../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _canvasJs = require("../render/canvas.js");
var _layerJs = require("../layer/Layer.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */ class CompositeMapRenderer extends (0, _mapJsDefault.default) {
    /**
   * @param {import("../Map.js").default} map Map.
   */ constructor(map){
        super(map);
        /**
     * @type {import("../events.js").EventsKey}
     */ this.fontChangeListenerKey_ = (0, _eventsJs.listen)((0, _canvasJs.checkedFonts), (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, map.redrawText.bind(map));
        /**
     * @private
     * @type {HTMLDivElement}
     */ this.element_ = document.createElement("div");
        const style = this.element_.style;
        style.position = "absolute";
        style.width = "100%";
        style.height = "100%";
        style.zIndex = "0";
        this.element_.className = (0, _cssJs.CLASS_UNSELECTABLE) + " ol-layers";
        const container = map.getViewport();
        container.insertBefore(this.element_, container.firstChild || null);
        /**
     * @private
     * @type {Array<HTMLElement>}
     */ this.children_ = [];
        /**
     * @private
     * @type {boolean}
     */ this.renderedVisible_ = true;
    }
    /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ dispatchRenderEvent(type, frameState) {
        const map = this.getMap();
        if (map.hasListener(type)) {
            const event = new (0, _eventJsDefault.default)(type, undefined, frameState);
            map.dispatchEvent(event);
        }
    }
    disposeInternal() {
        (0, _eventsJs.unlistenByKey)(this.fontChangeListenerKey_);
        this.element_.parentNode.removeChild(this.element_);
        super.disposeInternal();
    }
    /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ renderFrame(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element_.style.display = "none";
                this.renderedVisible_ = false;
            }
            return;
        }
        this.calculateMatrices2D(frameState);
        this.dispatchRenderEvent((0, _eventTypeJsDefault.default).PRECOMPOSE, frameState);
        const layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
            return a.zIndex - b.zIndex;
        });
        const viewState = frameState.viewState;
        this.children_.length = 0;
        /**
     * @type {Array<import("../layer/BaseVector.js").default>}
     */ const declutterLayers = [];
        let previousElement = null;
        for(let i = 0, ii = layerStatesArray.length; i < ii; ++i){
            const layerState = layerStatesArray[i];
            frameState.layerIndex = i;
            const layer = layerState.layer;
            const sourceState = layer.getSourceState();
            if (!(0, _layerJs.inView)(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
                layer.unrender();
                continue;
            }
            const element = layer.render(frameState, previousElement);
            if (!element) continue;
            if (element !== previousElement) {
                this.children_.push(element);
                previousElement = element;
            }
            if ("getDeclutter" in layer) declutterLayers.push(/** @type {import("../layer/BaseVector.js").default} */ layer);
        }
        for(let i1 = declutterLayers.length - 1; i1 >= 0; --i1)declutterLayers[i1].renderDeclutter(frameState);
        (0, _domJs.replaceChildren)(this.element_, this.children_);
        this.dispatchRenderEvent((0, _eventTypeJsDefault.default).POSTCOMPOSE, frameState);
        if (!this.renderedVisible_) {
            this.element_.style.display = "";
            this.renderedVisible_ = true;
        }
        this.scheduleExpireIconCache(frameState);
    }
}
exports.default = CompositeMapRenderer;

},{"./Map.js":"5iRLs","../ObjectEventType.js":"f2U6i","../render/Event.js":"bpzid","../render/EventType.js":"5G9JA","../css.js":"lDlNi","../render/canvas.js":"e85iQ","../layer/Layer.js":"8J9Kf","../events.js":"dcspA","../dom.js":"84QzQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5iRLs":[function(require,module,exports) {
/**
 * @module ol/renderer/Map
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _functionsJs = require("../functions.js");
var _utilJs = require("../util.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _iconImageCacheJs = require("../style/IconImageCache.js");
var _layerJs = require("../layer/Layer.js");
var _coordinateJs = require("../coordinate.js");
/**
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 * @template T
 */ /**
 * @abstract
 */ class MapRenderer extends (0, _disposableJsDefault.default) {
    /**
   * @param {import("../Map.js").default} map Map.
   */ constructor(map){
        super();
        /**
     * @private
     * @type {import("../Map.js").default}
     */ this.map_ = map;
    }
    /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ dispatchRenderEvent(type, frameState) {
        (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */ calculateMatrices2D(frameState) {
        const viewState = frameState.viewState;
        const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
        const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
        (0, _transformJs.compose)(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
        (0, _transformJs.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
        let result;
        const viewState = frameState.viewState;
        /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */ function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
            return callback.call(thisArg, feature, managed ? layer : null, geometry);
        }
        const projection = viewState.projection;
        const translatedCoordinate = (0, _coordinateJs.wrapX)(coordinate.slice(), projection);
        const offsets = [
            [
                0,
                0
            ]
        ];
        if (projection.canWrapX() && checkWrapped) {
            const projectionExtent = projection.getExtent();
            const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
            offsets.push([
                -worldWidth,
                0
            ], [
                worldWidth,
                0
            ]);
        }
        const layerStates = frameState.layerStatesArray;
        const numLayers = layerStates.length;
        const matches = /** @type {Array<HitMatch<T>>} */ [];
        const tmpCoord = [];
        for(let i = 0; i < offsets.length; i++)for(let j = numLayers - 1; j >= 0; --j){
            const layerState = layerStates[j];
            const layer = layerState.layer;
            if (layer.hasRenderer() && (0, _layerJs.inView)(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
                const layerRenderer = layer.getRenderer();
                const source = layer.getSource();
                if (layerRenderer && source) {
                    const coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
                    const callback1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                    tmpCoord[0] = coordinates[0] + offsets[i][0];
                    tmpCoord[1] = coordinates[1] + offsets[i][1];
                    result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback1, matches);
                }
                if (result) return result;
            }
        }
        if (matches.length === 0) return undefined;
        const order = 1 / matches.length;
        matches.forEach((m, i)=>m.distanceSq += i * order);
        matches.sort((a, b)=>a.distanceSq - b.distanceSq);
        matches.some((m)=>{
            return result = m.callback(m.feature, m.layer, m.geometry);
        });
        return result;
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */ hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
        const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, (0, _functionsJs.TRUE), this, layerFilter, thisArg);
        return hasFeature !== undefined;
    }
    /**
   * @return {import("../Map.js").default} Map.
   */ getMap() {
        return this.map_;
    }
    /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ renderFrame(frameState) {
        (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */ scheduleExpireIconCache(frameState) {
        if ((0, _iconImageCacheJs.shared).canExpireCache()) frameState.postRenderFunctions.push(expireIconCache);
    }
}
/**
 * @param {import("../Map.js").default} map Map.
 * @param {import("../Map.js").FrameState} frameState Frame state.
 */ function expireIconCache(map, frameState) {
    (0, _iconImageCacheJs.shared).expire();
}
exports.default = MapRenderer;

},{"../Disposable.js":"c0oTM","../functions.js":"iqv8I","../util.js":"pLBjQ","../transform.js":"1BqUf","../extent.js":"6YrVc","../style/IconImageCache.js":"2uEpE","../layer/Layer.js":"8J9Kf","../coordinate.js":"85Vu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4ZNC":[function(require,module,exports) {
/**
 * @module ol/layer/Group
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {'addlayer'|'removelayer'} EventType
 */ /**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */ parcelHelpers.export(exports, "GroupEvent", ()=>GroupEvent);
var _baseJs = require("./Base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var _eventsJs = require("../events.js");
class GroupEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */ constructor(type, layer){
        super(type);
        /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */ this.layer = layer;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ const Property = {
    LAYERS: "layers"
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */ class LayerGroup extends (0, _baseJsDefault.default) {
    /**
   * @param {Options} [options] Layer options.
   */ constructor(options){
        options = options || {};
        const baseOptions = /** @type {Options} */ Object.assign({}, options);
        delete baseOptions.layers;
        let layers = options.layers;
        super(baseOptions);
        /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {GroupOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */ this.layersListenerKeys_ = [];
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */ this.listenerKeys_ = {};
        this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);
        if (layers) {
            if (Array.isArray(layers)) layers = new (0, _collectionJsDefault.default)(layers.slice(), {
                unique: true
            });
            else (0, _assertsJs.assert)(typeof /** @type {?} */ layers.getArray === "function", 43); // Expected `layers` to be an array or a `Collection`
        } else layers = new (0, _collectionJsDefault.default)(undefined, {
            unique: true
        });
        this.setLayers(layers);
    }
    /**
   * @private
   */ handleLayerChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleLayersChanged_() {
        this.layersListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.layersListenerKeys_.length = 0;
        const layers = this.getLayers();
        this.layersListenerKeys_.push((0, _eventsJs.listen)(layers, (0, _collectionEventTypeJsDefault.default).ADD, this.handleLayersAdd_, this), (0, _eventsJs.listen)(layers, (0, _collectionEventTypeJsDefault.default).REMOVE, this.handleLayersRemove_, this));
        for(const id in this.listenerKeys_)this.listenerKeys_[id].forEach((0, _eventsJs.unlistenByKey));
        (0, _objJs.clear)(this.listenerKeys_);
        const layersArray = layers.getArray();
        for(let i = 0, ii = layersArray.length; i < ii; i++){
            const layer = layersArray[i];
            this.registerLayerListeners_(layer);
            this.dispatchEvent(new GroupEvent("addlayer", layer));
        }
        this.changed();
    }
    /**
   * @param {BaseLayer} layer The layer.
   */ registerLayerListeners_(layer) {
        const listenerKeys = [
            (0, _eventsJs.listen)(layer, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.handleLayerChange_, this),
            (0, _eventsJs.listen)(layer, (0, _eventTypeJsDefault.default).CHANGE, this.handleLayerChange_, this)
        ];
        if (layer instanceof LayerGroup) listenerKeys.push((0, _eventsJs.listen)(layer, "addlayer", this.handleLayerGroupAdd_, this), (0, _eventsJs.listen)(layer, "removelayer", this.handleLayerGroupRemove_, this));
        this.listenerKeys_[(0, _utilJs.getUid)(layer)] = listenerKeys;
    }
    /**
   * @param {GroupEvent} event The layer group event.
   */ handleLayerGroupAdd_(event) {
        this.dispatchEvent(new GroupEvent("addlayer", event.layer));
    }
    /**
   * @param {GroupEvent} event The layer group event.
   */ handleLayerGroupRemove_(event) {
        this.dispatchEvent(new GroupEvent("removelayer", event.layer));
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */ handleLayersAdd_(collectionEvent) {
        const layer = collectionEvent.element;
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent("addlayer", layer));
        this.changed();
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */ handleLayersRemove_(collectionEvent) {
        const layer = collectionEvent.element;
        const key = (0, _utilJs.getUid)(layer);
        this.listenerKeys_[key].forEach((0, _eventsJs.unlistenByKey));
        delete this.listenerKeys_[key];
        this.dispatchEvent(new GroupEvent("removelayer", layer));
        this.changed();
    }
    /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */ getLayers() {
        return /** @type {!Collection<import("./Base.js").default>} */ this.get(Property.LAYERS);
    }
    /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */ setLayers(layers) {
        const collection = this.getLayers();
        if (collection) {
            const currentLayers = collection.getArray();
            for(let i = 0, ii = currentLayers.length; i < ii; ++i)this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
        }
        this.set(Property.LAYERS, layers);
    }
    /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        array = array !== undefined ? array : [];
        this.getLayers().forEach(function(layer) {
            layer.getLayersArray(array);
        });
        return array;
    }
    /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(dest) {
        const states = dest !== undefined ? dest : [];
        const pos = states.length;
        this.getLayers().forEach(function(layer) {
            layer.getLayerStatesArray(states);
        });
        const ownLayerState = this.getLayerState();
        let defaultZIndex = ownLayerState.zIndex;
        if (!dest && ownLayerState.zIndex === undefined) defaultZIndex = 0;
        for(let i = pos, ii = states.length; i < ii; i++){
            const layerState = states[i];
            layerState.opacity *= ownLayerState.opacity;
            layerState.visible = layerState.visible && ownLayerState.visible;
            layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
            layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
            layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
            layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
            if (ownLayerState.extent !== undefined) {
                if (layerState.extent !== undefined) layerState.extent = (0, _extentJs.getIntersection)(layerState.extent, ownLayerState.extent);
                else layerState.extent = ownLayerState.extent;
            }
            if (layerState.zIndex === undefined) layerState.zIndex = defaultZIndex;
        }
        return states;
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        return "ready";
    }
}
exports.default = LayerGroup;

},{"./Base.js":"ag0tc","../Collection.js":"gReoh","../CollectionEventType.js":"82Ksf","../events/Event.js":"hwXQP","../events/EventType.js":"hrQJ6","../ObjectEventType.js":"f2U6i","../asserts.js":"e4TiF","../obj.js":"3ssAG","../extent.js":"6YrVc","../util.js":"pLBjQ","../events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"32Can":[function(require,module,exports) {
/**
 * @module ol/MapBrowserEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */ class MapBrowserEvent extends (0, _mapEventJsDefault.default) {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */ constructor(type, map, originalEvent, dragging, frameState, activePointers){
        super(type, map, frameState);
        /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */ this.originalEvent = originalEvent;
        /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */ this.pixel_ = null;
        /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */ this.coordinate_ = null;
        /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */ this.dragging = dragging !== undefined ? dragging : false;
        /**
     * @type {Array<PointerEvent>|undefined}
     */ this.activePointers = activePointers;
    }
    /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */ get pixel() {
        if (!this.pixel_) this.pixel_ = this.map.getEventPixel(this.originalEvent);
        return this.pixel_;
    }
    set pixel(pixel) {
        this.pixel_ = pixel;
    }
    /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */ get coordinate() {
        if (!this.coordinate_) this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
        return this.coordinate_;
    }
    set coordinate(coordinate) {
        this.coordinate_ = coordinate;
    }
    /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */ preventDefault() {
        super.preventDefault();
        if ("preventDefault" in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.preventDefault();
    }
    /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */ stopPropagation() {
        super.stopPropagation();
        if ("stopPropagation" in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.stopPropagation();
    }
}
exports.default = MapBrowserEvent;

},{"./MapEvent.js":"1APU6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1APU6":[function(require,module,exports) {
/**
 * @module ol/MapEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */ class MapEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */ constructor(type, map, frameState){
        super(type);
        /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */ this.map = map;
        /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */ this.frameState = frameState !== undefined ? frameState : null;
    }
}
exports.default = MapEvent;

},{"./events/Event.js":"hwXQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b2FtY":[function(require,module,exports) {
/**
 * @module ol/MapBrowserEventHandler
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventTypeJs = require("./MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _eventTypeJs1 = require("./pointer/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _hasJs = require("./has.js");
var _functionsJs = require("./functions.js");
var _eventsJs = require("./events.js");
class MapBrowserEventHandler extends (0, _targetJsDefault.default) {
    /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */ constructor(map, moveTolerance){
        super(map);
        /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */ this.map_ = map;
        /**
     * @type {any}
     * @private
     */ this.clickTimeoutId_;
        /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */ this.emulateClicks_ = false;
        /**
     * @type {boolean}
     * @private
     */ this.dragging_ = false;
        /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */ this.dragListenerKeys_ = [];
        /**
     * @type {number}
     * @private
     */ this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
        /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */ this.down_ = null;
        const element = this.map_.getViewport();
        /**
     * @type {Array<PointerEvent>}
     * @private
     */ this.activePointers_ = [];
        /**
     * @type {!Object<number, Event>}
     * @private
     */ this.trackedTouches_ = {};
        this.element_ = element;
        /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */ this.pointerdownListenerKey_ = (0, _eventsJs.listen)(element, (0, _eventTypeJsDefault1.default).POINTERDOWN, this.handlePointerDown_, this);
        /**
     * @type {PointerEvent}
     * @private
     */ this.originalPointerMoveEvent_;
        /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */ this.relayedListenerKey_ = (0, _eventsJs.listen)(element, (0, _eventTypeJsDefault1.default).POINTERMOVE, this.relayMoveEvent_, this);
        /**
     * @private
     */ this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
        this.element_.addEventListener((0, _eventTypeJsDefault.default).TOUCHMOVE, this.boundHandleTouchMove_, (0, _hasJs.PASSIVE_EVENT_LISTENERS) ? {
            passive: false
        } : false);
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ emulateClick_(pointerEvent) {
        let newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).CLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        if (this.clickTimeoutId_ !== undefined) {
            // double-click
            clearTimeout(this.clickTimeoutId_);
            this.clickTimeoutId_ = undefined;
            newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).DBLCLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
        } else // click
        this.clickTimeoutId_ = setTimeout(/** @this {MapBrowserEventHandler} */ (function() {
            this.clickTimeoutId_ = undefined;
            const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
        }).bind(this), 250);
    }
    /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ updateActivePointers_(pointerEvent) {
        const event = pointerEvent;
        const id = event.pointerId;
        if (event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERUP || event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERCANCEL) {
            delete this.trackedTouches_[id];
            for(const pointerId in this.trackedTouches_)if (this.trackedTouches_[pointerId].target !== event.target) {
                // Some platforms assign a new pointerId when the target changes.
                // If this happens, delete one tracked pointer. If there is more
                // than one tracked pointer for the old target, it will be cleared
                // by subsequent POINTERUP events from other pointers.
                delete this.trackedTouches_[pointerId];
                break;
            }
        } else if (event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN || event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE) this.trackedTouches_[id] = event;
        this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerUp_(pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
        // We emulate click events on left mouse button click, touch contact, and pen
        // contact. isMouseActionButton returns true in these cases (evt.button is set
        // to 0).
        // See http://www.w3.org/TR/pointerevents/#button-states
        // We only fire click, singleclick, and doubleclick if nobody has called
        // event.preventDefault().
        if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) this.emulateClick_(this.down_);
        if (this.activePointers_.length === 0) {
            this.dragListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
            this.dragListenerKeys_.length = 0;
            this.dragging_ = false;
            this.down_ = null;
        }
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */ isMouseActionButton_(pointerEvent) {
        return pointerEvent.button === 0;
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerDown_(pointerEvent) {
        this.emulateClicks_ = this.activePointers_.length === 0;
        this.updateActivePointers_(pointerEvent);
        const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
        // Store a copy of the down event
        this.down_ = /** @type {PointerEvent} */ {};
        for(const property in pointerEvent){
            const value = pointerEvent[property];
            this.down_[property] = typeof value === "function" ? (0, _functionsJs.VOID) : value;
        }
        if (this.dragListenerKeys_.length === 0) {
            const doc = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push((0, _eventsJs.listen)(doc, (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE, this.handlePointerMove_, this), (0, _eventsJs.listen)(doc, (0, _mapBrowserEventTypeJsDefault.default).POINTERUP, this.handlePointerUp_, this), /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */ (0, _eventsJs.listen)(this.element_, (0, _mapBrowserEventTypeJsDefault.default).POINTERCANCEL, this.handlePointerUp_, this));
            if (this.element_.getRootNode && this.element_.getRootNode() !== doc) this.dragListenerKeys_.push((0, _eventsJs.listen)(this.element_.getRootNode(), (0, _mapBrowserEventTypeJsDefault.default).POINTERUP, this.handlePointerUp_, this));
        }
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerMove_(pointerEvent) {
        // Between pointerdown and pointerup, pointermove events are triggered.
        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
        // moved a significant distance.
        if (this.isMoving_(pointerEvent)) {
            this.updateActivePointers_(pointerEvent);
            this.dragging_ = true;
            const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);
            this.dispatchEvent(newEvent);
        }
    }
    /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ relayMoveEvent_(pointerEvent) {
        this.originalPointerMoveEvent_ = pointerEvent;
        const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
        this.dispatchEvent(new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE, this.map_, pointerEvent, dragging));
    }
    /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */ handleTouchMove_(event) {
        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
        // may not be initialized yet when we get here on a platform without native pointer events.
        const originalEvent = this.originalPointerMoveEvent_;
        if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) event.preventDefault();
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */ isMoving_(pointerEvent) {
        return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.relayedListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.relayedListenerKey_);
            this.relayedListenerKey_ = null;
        }
        this.element_.removeEventListener((0, _eventTypeJsDefault.default).TOUCHMOVE, this.boundHandleTouchMove_);
        if (this.pointerdownListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.pointerdownListenerKey_);
            this.pointerdownListenerKey_ = null;
        }
        this.dragListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.dragListenerKeys_.length = 0;
        this.element_ = null;
        super.disposeInternal();
    }
}
exports.default = MapBrowserEventHandler;

},{"./events/EventType.js":"hrQJ6","./MapBrowserEvent.js":"32Can","./MapBrowserEventType.js":"fB9ae","./pointer/EventType.js":"cVfVH","./events/Target.js":"7T5Yi","./has.js":"6BDNi","./functions.js":"iqv8I","./events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fB9ae":[function(require,module,exports) {
/**
 * @module ol/MapBrowserEventType
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
/**
 * Constants for event names.
 * @enum {string}
 */ exports.default = {
    /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */ SINGLECLICK: "singleclick",
    /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */ CLICK: (0, _eventTypeJsDefault.default).CLICK,
    /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */ DBLCLICK: (0, _eventTypeJsDefault.default).DBLCLICK,
    /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */ POINTERDRAG: "pointerdrag",
    /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */ POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
}; /***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */ 

},{"./events/EventType.js":"hrQJ6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVfVH":[function(require,module,exports) {
/**
 * @module ol/pointer/EventType
 */ /**
 * Constants for event names.
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1cFF9":[function(require,module,exports) {
/**
 * @module ol/MapEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */ POSTRENDER: "postrender",
    /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */ MOVESTART: "movestart",
    /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */ MOVEEND: "moveend",
    /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */ LOADSTART: "loadstart",
    /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */ LOADEND: "loadend"
}; /***
 * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jMfsr":[function(require,module,exports) {
/**
 * @module ol/MapProperty
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LAYERGROUP: "layergroup",
    SIZE: "size",
    TARGET: "target",
    VIEW: "view"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iKkF5":[function(require,module,exports) {
/**
 * @module ol/TileQueue
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import('./Map.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */ parcelHelpers.export(exports, "getTilePriority", ()=>getTilePriority);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _priorityQueueJs = require("./structs/PriorityQueue.js");
var _priorityQueueJsDefault = parcelHelpers.interopDefault(_priorityQueueJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */ class TileQueue extends (0, _priorityQueueJsDefault.default) {
    /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */ constructor(tilePriorityFunction, tileChangeCallback){
        super(/**
       * @param {Array} element Element.
       * @return {number} Priority.
       */ function(element) {
            return tilePriorityFunction.apply(null, element);
        }, /**
       * @param {Array} element Element.
       * @return {string} Key.
       */ function(element) {
            return /** @type {import("./Tile.js").default} */ element[0].getKey();
        });
        /** @private */ this.boundHandleTileChange_ = this.handleTileChange.bind(this);
        /**
     * @private
     * @type {function(): ?}
     */ this.tileChangeCallback_ = tileChangeCallback;
        /**
     * @private
     * @type {number}
     */ this.tilesLoading_ = 0;
        /**
     * @private
     * @type {!Object<string,boolean>}
     */ this.tilesLoadingKeys_ = {};
    }
    /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */ enqueue(element) {
        const added = super.enqueue(element);
        if (added) {
            const tile = element[0];
            tile.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleTileChange_);
        }
        return added;
    }
    /**
   * @return {number} Number of tiles loading.
   */ getTilesLoading() {
        return this.tilesLoading_;
    }
    /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */ handleTileChange(event) {
        const tile = /** @type {import("./Tile.js").default} */ event.target;
        const state = tile.getState();
        if (state === (0, _tileStateJsDefault.default).LOADED || state === (0, _tileStateJsDefault.default).ERROR || state === (0, _tileStateJsDefault.default).EMPTY) {
            if (state !== (0, _tileStateJsDefault.default).ERROR) tile.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleTileChange_);
            const tileKey = tile.getKey();
            if (tileKey in this.tilesLoadingKeys_) {
                delete this.tilesLoadingKeys_[tileKey];
                --this.tilesLoading_;
            }
            this.tileChangeCallback_();
        }
    }
    /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */ loadMoreTiles(maxTotalLoading, maxNewLoads) {
        let newLoads = 0;
        let state, tile, tileKey;
        while(this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0){
            tile = /** @type {import("./Tile.js").default} */ this.dequeue()[0];
            tileKey = tile.getKey();
            state = tile.getState();
            if (state === (0, _tileStateJsDefault.default).IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                this.tilesLoadingKeys_[tileKey] = true;
                ++this.tilesLoading_;
                ++newLoads;
                tile.load();
            }
        }
    }
}
exports.default = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) return 0, _priorityQueueJs.DROP;
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) return 0, _priorityQueueJs.DROP;
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels between
    // the center of the tile and the center of the viewport.  The factor of 65536
    // means that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    const center = frameState.viewState.center;
    const deltaX = tileCenter[0] - center[0];
    const deltaY = tileCenter[1] - center[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

},{"./events/EventType.js":"hrQJ6","./structs/PriorityQueue.js":"jDGXE","./TileState.js":"2fodI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jDGXE":[function(require,module,exports) {
/**
 * @module ol/structs/PriorityQueue
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DROP", ()=>DROP);
var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
const DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */ class PriorityQueue {
    /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */ constructor(priorityFunction, keyFunction){
        /**
     * @type {function(T): number}
     * @private
     */ this.priorityFunction_ = priorityFunction;
        /**
     * @type {function(T): string}
     * @private
     */ this.keyFunction_ = keyFunction;
        /**
     * @type {Array<T>}
     * @private
     */ this.elements_ = [];
        /**
     * @type {Array<number>}
     * @private
     */ this.priorities_ = [];
        /**
     * @type {!Object<string, boolean>}
     * @private
     */ this.queuedElements_ = {};
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.elements_.length = 0;
        this.priorities_.length = 0;
        (0, _objJs.clear)(this.queuedElements_);
    }
    /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */ dequeue() {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[0];
        if (elements.length == 1) {
            elements.length = 0;
            priorities.length = 0;
        } else {
            elements[0] = elements.pop();
            priorities[0] = priorities.pop();
            this.siftUp_(0);
        }
        const elementKey = this.keyFunction_(element);
        delete this.queuedElements_[elementKey];
        return element;
    }
    /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */ enqueue(element) {
        (0, _assertsJs.assert)(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
        const priority = this.priorityFunction_(element);
        if (priority != DROP) {
            this.elements_.push(element);
            this.priorities_.push(priority);
            this.queuedElements_[this.keyFunction_(element)] = true;
            this.siftDown_(0, this.elements_.length - 1);
            return true;
        }
        return false;
    }
    /**
   * @return {number} Count.
   */ getCount() {
        return this.elements_.length;
    }
    /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */ getLeftChildIndex_(index) {
        return index * 2 + 1;
    }
    /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */ getRightChildIndex_(index) {
        return index * 2 + 2;
    }
    /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */ getParentIndex_(index) {
        return index - 1 >> 1;
    }
    /**
   * Make this a heap. O(N).
   * @private
   */ heapify_() {
        let i;
        for(i = (this.elements_.length >> 1) - 1; i >= 0; i--)this.siftUp_(i);
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return this.elements_.length === 0;
    }
    /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */ isKeyQueued(key) {
        return key in this.queuedElements_;
    }
    /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */ isQueued(element) {
        return this.isKeyQueued(this.keyFunction_(element));
    }
    /**
   * @param {number} index The index of the node to move down.
   * @private
   */ siftUp_(index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const count = elements.length;
        const element = elements[index];
        const priority = priorities[index];
        const startIndex = index;
        while(index < count >> 1){
            const lIndex = this.getLeftChildIndex_(index);
            const rIndex = this.getRightChildIndex_(index);
            const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
            elements[index] = elements[smallerChildIndex];
            priorities[index] = priorities[smallerChildIndex];
            index = smallerChildIndex;
        }
        elements[index] = element;
        priorities[index] = priority;
        this.siftDown_(startIndex, index);
    }
    /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */ siftDown_(startIndex, index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[index];
        const priority = priorities[index];
        while(index > startIndex){
            const parentIndex = this.getParentIndex_(index);
            if (priorities[parentIndex] > priority) {
                elements[index] = elements[parentIndex];
                priorities[index] = priorities[parentIndex];
                index = parentIndex;
            } else break;
        }
        elements[index] = element;
        priorities[index] = priority;
    }
    /**
   * FIXME empty description for jsdoc
   */ reprioritize() {
        const priorityFunction = this.priorityFunction_;
        const elements = this.elements_;
        const priorities = this.priorities_;
        let index = 0;
        const n = elements.length;
        let element, i, priority;
        for(i = 0; i < n; ++i){
            element = elements[i];
            priority = priorityFunction(element);
            if (priority == DROP) delete this.queuedElements_[this.keyFunction_(element)];
            else {
                priorities[index] = priority;
                elements[index++] = element;
            }
        }
        elements.length = index;
        priorities.length = index;
        this.heapify_();
    }
}
exports.default = PriorityQueue;

},{"../asserts.js":"e4TiF","../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2fodI":[function(require,module,exports) {
/**
 * @module ol/TileState
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
   * Indicates that tile loading failed
   * @type {number}
   */ ERROR: 3,
    EMPTY: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8xbkS":[function(require,module,exports) {
/**
 * @module ol/View
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */ parcelHelpers.export(exports, "createCenterConstraint", ()=>createCenterConstraint);
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */ parcelHelpers.export(exports, "createResolutionConstraint", ()=>createResolutionConstraint);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createRotationConstraint", ()=>createRotationConstraint);
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */ parcelHelpers.export(exports, "isNoopAnimation", ()=>isNoopAnimation);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _viewHintJs = require("./ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _viewPropertyJs = require("./ViewProperty.js");
var _viewPropertyJsDefault = parcelHelpers.interopDefault(_viewPropertyJs);
var _commonJs = require("./tilegrid/common.js");
var _projJs = require("./proj.js");
var _functionsJs = require("./functions.js");
var _coordinateJs = require("./coordinate.js");
var _assertsJs = require("./asserts.js");
var _centerconstraintJs = require("./centerconstraint.js");
var _mathJs = require("./math.js");
var _resolutionconstraintJs = require("./resolutionconstraint.js");
var _rotationconstraintJs = require("./rotationconstraint.js");
var _easingJs = require("./easing.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
var _polygonJs = require("./geom/Polygon.js");
/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */ /**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */ /**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */ /**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */ /**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */ /**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center.
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */ /**
 * Default min zoom level for the map view.
 * @type {number}
 */ const DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */ /**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */ class View extends (0, _objectJsDefault.default) {
    /**
   * @param {ViewOptions} [options] View options.
   */ constructor(options){
        super();
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ViewOnSignature<void>}
     */ this.un;
        options = Object.assign({}, options);
        /**
     * @private
     * @type {Array<number>}
     */ this.hints_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {Array<Array<Animation>>}
     */ this.animations_ = [];
        /**
     * @private
     * @type {number|undefined}
     */ this.updateAnimationKey_;
        /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */ this.projection_ = (0, _projJs.createProjection)(options.projection, "EPSG:3857");
        /**
     * @private
     * @type {import("./size.js").Size}
     */ this.viewportSize_ = [
            100,
            100
        ];
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.targetCenter_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetResolution_;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */ this.nextCenter_ = null;
        /**
     * @private
     * @type {number}
     */ this.nextResolution_;
        /**
     * @private
     * @type {number}
     */ this.nextRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.cancelAnchor_ = undefined;
        if (options.projection) (0, _projJs.disableCoordinateWarning)();
        if (options.center) options.center = (0, _projJs.fromUserCoordinate)(options.center, this.projection_);
        if (options.extent) options.extent = (0, _projJs.fromUserExtent)(options.extent, this.projection_);
        this.applyOptions_(options);
    }
    /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */ applyOptions_(options) {
        const properties = Object.assign({}, options);
        for(const key in 0, _viewPropertyJsDefault.default)delete properties[key];
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        /**
     * @private
     * @type {number}
     */ this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        /**
     * @private
     * @type {number}
     */ this.minResolution_ = resolutionConstraintInfo.minResolution;
        /**
     * @private
     * @type {number}
     */ this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        /**
     * @private
     * @type {Array<number>|undefined}
     */ this.resolutions_ = options.resolutions;
        /**
     * @type {Array<number>|undefined}
     * @private
     */ this.padding_ = options.padding;
        /**
     * @private
     * @type {number}
     */ this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        /**
     * @private
     * @type {Constraints}
     */ this.constraints_ = {
            center: centerConstraint,
            resolution: resolutionConstraint,
            rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== undefined ? options.rotation : 0);
        this.setCenterInternal(options.center !== undefined ? options.center : null);
        if (options.resolution !== undefined) this.setResolution(options.resolution);
        else if (options.zoom !== undefined) this.setZoom(options.zoom);
    }
    /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */ get padding() {
        return this.padding_;
    }
    set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenter();
        if (center) {
            const newPadding = padding || [
                0,
                0,
                0,
                0
            ];
            oldPadding = oldPadding || [
                0,
                0,
                0,
                0
            ];
            const resolution = this.getResolution();
            const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
            const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
            this.setCenterInternal([
                center[0] + offsetX,
                center[1] - offsetY
            ]);
        }
    }
    /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */ getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        // preserve resolution (or zoom)
        if (options.resolution !== undefined) options.resolution = this.getResolution();
        else options.zoom = this.getZoom();
        // preserve center
        options.center = this.getCenterInternal();
        // preserve rotation
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
    }
    /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */ animate(var_args) {
        if (this.isDef() && !this.getAnimating()) this.resolveConstraints(0);
        const args = new Array(arguments.length);
        for(let i = 0; i < args.length; ++i){
            let options = arguments[i];
            if (options.center) {
                options = Object.assign({}, options);
                options.center = (0, _projJs.fromUserCoordinate)(options.center, this.getProjection());
            }
            if (options.anchor) {
                options = Object.assign({}, options);
                options.anchor = (0, _projJs.fromUserCoordinate)(options.anchor, this.getProjection());
            }
            args[i] = options;
        }
        this.animateInternal.apply(this, args);
    }
    /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */ animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
            callback = arguments[animationCount - 1];
            --animationCount;
        }
        let i = 0;
        for(; i < animationCount && !this.isDef(); ++i){
            // if view properties are not yet set, shortcut to the final state
            const state = arguments[i];
            if (state.center) this.setCenterInternal(state.center);
            if (state.zoom !== undefined) this.setZoom(state.zoom);
            else if (state.resolution) this.setResolution(state.resolution);
            if (state.rotation !== undefined) this.setRotation(state.rotation);
        }
        if (i === animationCount) {
            if (callback) animationCallback(callback, true);
            return;
        }
        let start = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for(; i < animationCount; ++i){
            const options = /** @type {AnimationOptions} */ arguments[i];
            const animation = {
                start: start,
                complete: false,
                anchor: options.anchor,
                duration: options.duration !== undefined ? options.duration : 1000,
                easing: options.easing || (0, _easingJs.inAndOut),
                callback: callback
            };
            if (options.center) {
                animation.sourceCenter = center;
                animation.targetCenter = options.center.slice();
                center = animation.targetCenter;
            }
            if (options.zoom !== undefined) {
                animation.sourceResolution = resolution;
                animation.targetResolution = this.getResolutionForZoom(options.zoom);
                resolution = animation.targetResolution;
            } else if (options.resolution) {
                animation.sourceResolution = resolution;
                animation.targetResolution = options.resolution;
                resolution = animation.targetResolution;
            }
            if (options.rotation !== undefined) {
                animation.sourceRotation = rotation;
                const delta = (0, _mathJs.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                animation.targetRotation = rotation + delta;
                rotation = animation.targetRotation;
            }
            // check if animation is a no-op
            if (isNoopAnimation(animation)) animation.complete = true;
            else start += animation.duration;
            series.push(animation);
        }
        this.animations_.push(series);
        this.setHint((0, _viewHintJsDefault.default).ANIMATING, 1);
        this.updateAnimations_();
    }
    /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */ getAnimating() {
        return this.hints_[(0, _viewHintJsDefault.default).ANIMATING] > 0;
    }
    /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */ getInteracting() {
        return this.hints_[(0, _viewHintJsDefault.default).INTERACTING] > 0;
    }
    /**
   * Cancel any ongoing animations.
   * @api
   */ cancelAnimations() {
        this.setHint((0, _viewHintJsDefault.default).ANIMATING, -this.hints_[(0, _viewHintJsDefault.default).ANIMATING]);
        let anchor;
        for(let i = 0, ii = this.animations_.length; i < ii; ++i){
            const series = this.animations_[i];
            if (series[0].callback) animationCallback(series[0].callback, false);
            if (!anchor) for(let j = 0, jj = series.length; j < jj; ++j){
                const animation = series[j];
                if (!animation.complete) {
                    anchor = animation.anchor;
                    break;
                }
            }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
    }
    /**
   * Update all animations.
   */ updateAnimations_() {
        if (this.updateAnimationKey_ !== undefined) {
            cancelAnimationFrame(this.updateAnimationKey_);
            this.updateAnimationKey_ = undefined;
        }
        if (!this.getAnimating()) return;
        const now = Date.now();
        let more = false;
        for(let i = this.animations_.length - 1; i >= 0; --i){
            const series = this.animations_[i];
            let seriesComplete = true;
            for(let j = 0, jj = series.length; j < jj; ++j){
                const animation = series[j];
                if (animation.complete) continue;
                const elapsed = now - animation.start;
                let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                if (fraction >= 1) {
                    animation.complete = true;
                    fraction = 1;
                } else seriesComplete = false;
                const progress = animation.easing(fraction);
                if (animation.sourceCenter) {
                    const x0 = animation.sourceCenter[0];
                    const y0 = animation.sourceCenter[1];
                    const x1 = animation.targetCenter[0];
                    const y1 = animation.targetCenter[1];
                    this.nextCenter_ = animation.targetCenter;
                    const x = x0 + progress * (x1 - x0);
                    const y = y0 + progress * (y1 - y0);
                    this.targetCenter_ = [
                        x,
                        y
                    ];
                }
                if (animation.sourceResolution && animation.targetResolution) {
                    const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
                    if (animation.anchor) {
                        const size = this.getViewportSize_(this.getRotation());
                        const constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                    }
                    this.nextResolution_ = animation.targetResolution;
                    this.targetResolution_ = resolution;
                    this.applyTargetState_(true);
                }
                if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
                    const rotation = progress === 1 ? (0, _mathJs.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
                    if (animation.anchor) {
                        const constrainedRotation = this.constraints_.rotation(rotation, true);
                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                    }
                    this.nextRotation_ = animation.targetRotation;
                    this.targetRotation_ = rotation;
                }
                this.applyTargetState_(true);
                more = true;
                if (!animation.complete) break;
            }
            if (seriesComplete) {
                this.animations_[i] = null;
                this.setHint((0, _viewHintJsDefault.default).ANIMATING, -1);
                this.nextCenter_ = null;
                this.nextResolution_ = NaN;
                this.nextRotation_ = NaN;
                const callback = series[0].callback;
                if (callback) animationCallback(callback, true);
            }
        }
        // prune completed series
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === undefined) this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
    /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */ calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== undefined) {
            center = [
                currentCenter[0] - anchor[0],
                currentCenter[1] - anchor[1]
            ];
            (0, _coordinateJs.rotate)(center, rotation - this.getRotation());
            (0, _coordinateJs.add)(center, anchor);
        }
        return center;
    }
    /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */ calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== undefined && currentResolution !== undefined) {
            const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
            const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
            center = [
                x,
                y
            ];
        }
        return center;
    }
    /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */ getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
            const w = size[0];
            const h = size[1];
            return [
                Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
                Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
            ];
        } else return size;
    }
    /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */ setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [
            100,
            100
        ];
        if (!this.getAnimating()) this.resolveConstraints(0);
    }
    /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */ getCenter() {
        const center = this.getCenterInternal();
        if (!center) return center;
        return (0, _projJs.toUserCoordinate)(center, this.getProjection());
    }
    /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */ getCenterInternal() {
        return /** @type {import("./coordinate.js").Coordinate|undefined} */ this.get((0, _viewPropertyJsDefault.default).CENTER);
    }
    /**
   * @return {Constraints} Constraints.
   */ getConstraints() {
        return this.constraints_;
    }
    /**
   * @return {boolean} Resolution constraint is set
   */ getConstrainResolution() {
        return this.get("constrainResolution");
    }
    /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */ getHints(hints) {
        if (hints !== undefined) {
            hints[0] = this.hints_[0];
            hints[1] = this.hints_[1];
            return hints;
        } else return this.hints_.slice();
    }
    /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */ calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return (0, _projJs.toUserExtent)(extent, this.getProjection());
    }
    /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */ calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = /** @type {!import("./coordinate.js").Coordinate} */ this.getCenterInternal();
        (0, _assertsJs.assert)(center, 1); // The view center is not defined
        const resolution = /** @type {!number} */ this.getResolution();
        (0, _assertsJs.assert)(resolution !== undefined, 2); // The view resolution is not defined
        const rotation = /** @type {!number} */ this.getRotation();
        (0, _assertsJs.assert)(rotation !== undefined, 3); // The view rotation is not defined
        return (0, _extentJs.getForViewAndSize)(center, resolution, rotation, size);
    }
    /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */ getMaxResolution() {
        return this.maxResolution_;
    }
    /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */ getMinResolution() {
        return this.minResolution_;
    }
    /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */ getMaxZoom() {
        return /** @type {number} */ this.getZoomForResolution(this.minResolution_);
    }
    /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */ setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            maxZoom: zoom
        }));
    }
    /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */ getMinZoom() {
        return /** @type {number} */ this.getZoomForResolution(this.maxResolution_);
    }
    /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */ setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            minZoom: zoom
        }));
    }
    /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */ setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({
            constrainResolution: enabled
        }));
    }
    /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */ getProjection() {
        return this.projection_;
    }
    /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */ getResolution() {
        return /** @type {number|undefined} */ this.get((0, _viewPropertyJsDefault.default).RESOLUTION);
    }
    /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */ getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal((0, _projJs.fromUserExtent)(extent, this.getProjection()), size);
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */ getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = (0, _extentJs.getWidth)(extent) / size[0];
        const yResolution = (0, _extentJs.getHeight)(extent) / size[1];
        return Math.max(xResolution, yResolution);
    }
    /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */ getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return(/**
       * @param {number} value Value.
       * @return {number} Resolution.
       */ function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
        });
    }
    /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */ getRotation() {
        return /** @type {number} */ this.get((0, _viewPropertyJsDefault.default).ROTATION);
    }
    /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */ getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return(/**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */ function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
        });
    }
    /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */ getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
        ];
        return size;
    }
    /**
   * @return {State} View state.
   */ getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = /** @type {import("./coordinate.js").Coordinate} */ this.getCenterInternal();
        const padding = this.padding_;
        if (padding) {
            const reducedSize = this.getViewportSizeMinusPadding_();
            center = calculateCenterOn(center, this.getViewportSize_(), [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
        }
        return {
            center: center.slice(0),
            projection: projection !== undefined ? projection : null,
            resolution: resolution,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: rotation,
            zoom: this.getZoom()
        };
    }
    /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */ getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== undefined) zoom = this.getZoomForResolution(resolution);
        return zoom;
    }
    /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */ getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
            const nearest = (0, _arrayJs.linearFindNearest)(this.resolutions_, resolution, 1);
            offset = nearest;
            max = this.resolutions_[nearest];
            if (nearest == this.resolutions_.length - 1) zoomFactor = 2;
            else zoomFactor = max / this.resolutions_[nearest + 1];
        } else {
            max = this.maxResolution_;
            zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    }
    /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */ getResolutionForZoom(zoom) {
        if (this.resolutions_) {
            if (this.resolutions_.length <= 1) return 0;
            const baseLevel = (0, _mathJs.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
            const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
            return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0, _mathJs.clamp)(zoom - baseLevel, 0, 1));
        } else return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
    /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */ fit(geometryOrExtent, options) {
        /** @type {import("./geom/SimpleGeometry.js").default} */ let geometry;
        (0, _assertsJs.assert)(Array.isArray(geometryOrExtent) || typeof /** @type {?} */ geometryOrExtent.getSimplifiedGeometry === "function", 24); // Invalid extent or geometry provided as `geometry`
        if (Array.isArray(geometryOrExtent)) {
            (0, _assertsJs.assert)(!(0, _extentJs.isEmpty)(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
            const extent = (0, _projJs.fromUserExtent)(geometryOrExtent, this.getProjection());
            geometry = (0, _polygonJs.fromExtent)(extent);
        } else if (geometryOrExtent.getType() === "Circle") {
            const extent1 = (0, _projJs.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
            geometry = (0, _polygonJs.fromExtent)(extent1);
            geometry.rotate(this.getRotation(), (0, _extentJs.getCenter)(extent1));
        } else {
            const userProjection = (0, _projJs.getUserProjection)();
            if (userProjection) geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ geometryOrExtent.clone().transform(userProjection, this.getProjection());
            else geometry = geometryOrExtent;
        }
        this.fitInternal(geometry, options);
    }
    /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */ rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for(let i = 0, ii = coords.length; i < ii; i += stride){
            const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
            const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
            minRotX = Math.min(minRotX, rotX);
            minRotY = Math.min(minRotY, rotY);
            maxRotX = Math.max(maxRotX, rotX);
            maxRotY = Math.max(maxRotY, rotY);
        }
        return [
            minRotX,
            minRotY,
            maxRotX,
            maxRotY
        ];
    }
    /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */ fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) size = this.getViewportSizeMinusPadding_();
        const padding = options.padding !== undefined ? options.padding : [
            0,
            0,
            0,
            0
        ];
        const nearest = options.nearest !== undefined ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== undefined) minResolution = options.minResolution;
        else if (options.maxZoom !== undefined) minResolution = this.getResolutionForZoom(options.maxZoom);
        else minResolution = 0;
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        // calculate resolution
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        // calculate center
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = (0, _extentJs.getCenter)(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([
            centerX,
            centerY
        ], resolution);
        const callback = options.callback ? options.callback : (0, _functionsJs.VOID);
        if (options.duration !== undefined) this.animateInternal({
            resolution: resolution,
            center: center,
            duration: options.duration,
            easing: options.easing
        }, callback);
        else {
            this.targetResolution_ = resolution;
            this.targetCenter_ = center;
            this.applyTargetState_(false, true);
            animationCallback(callback, true);
        }
    }
    /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */ centerOn(coordinate, size, position) {
        this.centerOnInternal((0, _projJs.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
    }
    /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */ centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    }
    /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */ calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
            const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
            const shiftedCenter = calculateCenterOn(center, size, [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
            centerShift = [
                center[0] - shiftedCenter[0],
                center[1] - shiftedCenter[1]
            ];
        }
        return centerShift;
    }
    /**
   * @return {boolean} Is defined.
   */ isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== undefined;
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */ adjustCenter(deltaCoordinates) {
        const center = (0, _projJs.toUserCoordinate)(this.targetCenter_, this.getProjection());
        this.setCenter([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */ adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustResolution(ratio, anchor) {
        anchor = anchor && (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
        if (anchor) this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
    }
    /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }
    /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */ adjustRotation(delta, anchor) {
        if (anchor) anchor = (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.adjustRotationInternal(delta, anchor);
    }
    /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */ adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
        if (anchor) this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        this.targetRotation_ += delta;
        this.applyTargetState_();
    }
    /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */ setCenter(center) {
        this.setCenterInternal(center ? (0, _projJs.fromUserCoordinate)(center, this.getProjection()) : center);
    }
    /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */ setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
    }
    /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */ setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
    }
    /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */ setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
    }
    /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */ setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
    }
    /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */ setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
    }
    /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */ applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        // compute rotation
        const newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (this.get((0, _viewPropertyJsDefault.default).ROTATION) !== newRotation) this.set((0, _viewPropertyJsDefault.default).ROTATION, newRotation);
        if (this.get((0, _viewPropertyJsDefault.default).RESOLUTION) !== newResolution) {
            this.set((0, _viewPropertyJsDefault.default).RESOLUTION, newResolution);
            this.set("zoom", this.getZoom(), true);
        }
        if (!newCenter || !this.get((0, _viewPropertyJsDefault.default).CENTER) || !(0, _coordinateJs.equals)(this.get((0, _viewPropertyJsDefault.default).CENTER), newCenter)) this.set((0, _viewPropertyJsDefault.default).CENTER, newCenter);
        if (this.getAnimating() && !doNotCancelAnims) this.cancelAnimations();
        this.cancelAnchor_ = undefined;
    }
    /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== undefined ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (duration === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = newResolution;
            this.targetRotation_ = newRotation;
            this.targetCenter_ = newCenter;
            this.applyTargetState_();
            return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
        this.cancelAnchor_ = undefined;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0, _coordinateJs.equals)(this.getCenterInternal(), newCenter)) {
            if (this.getAnimating()) this.cancelAnimations();
            this.animateInternal({
                rotation: newRotation,
                center: newCenter,
                resolution: newResolution,
                duration: duration,
                easing: (0, _easingJs.easeOut),
                anchor: anchor
            });
        }
    }
    /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */ beginInteraction() {
        this.resolveConstraints(0);
        this.setHint((0, _viewHintJsDefault.default).INTERACTING, 1);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ endInteractionInternal(duration, resolutionDirection, anchor) {
        this.setHint((0, _viewHintJsDefault.default).INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
    }
    /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */ getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
    }
    /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */ getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));
    }
    /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */ getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
    }
}
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */ function animationCallback(callback, returnValue) {
    setTimeout(function() {
        callback(returnValue);
    }, 0);
}
function createCenterConstraint(options) {
    if (options.extent !== undefined) {
        const smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
        return (0, _centerconstraintJs.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
    }
    const projection = (0, _projJs.createProjection)(options.projection, "EPSG:3857");
    if (options.multiWorld !== true && projection.isGlobal()) {
        const extent = projection.getExtent().slice();
        extent[0] = -Infinity;
        extent[2] = Infinity;
        return (0, _centerconstraintJs.createExtent)(extent, false, false);
    }
    return 0, _centerconstraintJs.none;
}
function createResolutionConstraint(options) {
    let resolutionConstraint;
    let maxResolution;
    let minResolution;
    // TODO: move these to be ol constants
    // see https://github.com/openlayers/openlayers/issues/2076
    const defaultMaxZoom = 28;
    const defaultZoomFactor = 2;
    let minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
    let maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
    const zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
    const multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
    const smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
    const showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
    const projection = (0, _projJs.createProjection)(options.projection, "EPSG:3857");
    const projExtent = projection.getExtent();
    let constrainOnlyCenter = options.constrainOnlyCenter;
    let extent = options.extent;
    if (!multiWorld && !extent && projection.isGlobal()) {
        constrainOnlyCenter = false;
        extent = projExtent;
    }
    if (options.resolutions !== undefined) {
        const resolutions = options.resolutions;
        maxResolution = resolutions[minZoom];
        minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
        if (options.constrainResolution) resolutionConstraint = (0, _resolutionconstraintJs.createSnapToResolutions)(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = (0, _resolutionconstraintJs.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
        // calculate the default min and max resolution
        const size = !projExtent ? 360 * (0, _projJs.METERS_PER_UNIT).degrees / projection.getMetersPerUnit() : Math.max((0, _extentJs.getWidth)(projExtent), (0, _extentJs.getHeight)(projExtent));
        const defaultMaxResolution = size / (0, _commonJs.DEFAULT_TILE_SIZE) / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
        const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
        // user provided maxResolution takes precedence
        maxResolution = options.maxResolution;
        if (maxResolution !== undefined) minZoom = 0;
        else maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
        // user provided minResolution takes precedence
        minResolution = options.minResolution;
        if (minResolution === undefined) {
            if (options.maxZoom !== undefined) {
                if (options.maxResolution !== undefined) minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                else minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
            } else minResolution = defaultMinResolution;
        }
        // given discrete zoom levels, minResolution may be different than provided
        maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
        if (options.constrainResolution) resolutionConstraint = (0, _resolutionconstraintJs.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = (0, _resolutionconstraintJs.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
    return {
        constraint: resolutionConstraint,
        maxResolution: maxResolution,
        minResolution: minResolution,
        minZoom: minZoom,
        zoomFactor: zoomFactor
    };
}
function createRotationConstraint(options) {
    const enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
    if (enableRotation) {
        const constrainRotation = options.constrainRotation;
        if (constrainRotation === undefined || constrainRotation === true) return (0, _rotationconstraintJs.createSnapToZero)();
        else if (constrainRotation === false) return 0, _rotationconstraintJs.none;
        else if (typeof constrainRotation === "number") return (0, _rotationconstraintJs.createSnapToN)(constrainRotation);
        else return 0, _rotationconstraintJs.none;
    } else return 0, _rotationconstraintJs.disable;
}
function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
        if (!(0, _coordinateJs.equals)(animation.sourceCenter, animation.targetCenter)) return false;
    }
    if (animation.sourceResolution !== animation.targetResolution) return false;
    if (animation.sourceRotation !== animation.targetRotation) return false;
    return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */ function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    // calculate rotated position
    const cosAngle = Math.cos(-rotation);
    let sinAngle = Math.sin(-rotation);
    let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;
    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    const centerX = rotX * cosAngle - rotY * sinAngle;
    const centerY = rotY * cosAngle + rotX * sinAngle;
    return [
        centerX,
        centerY
    ];
}
exports.default = View;

},{"./Object.js":"1zG8z","./ViewHint.js":"6THmF","./ViewProperty.js":"lWCek","./tilegrid/common.js":"bxYGl","./proj.js":"SznqC","./functions.js":"iqv8I","./coordinate.js":"85Vu7","./asserts.js":"e4TiF","./centerconstraint.js":"g3NLx","./math.js":"5jEFr","./resolutionconstraint.js":"j8WKZ","./rotationconstraint.js":"hSWd8","./easing.js":"fYITA","./extent.js":"6YrVc","./array.js":"1Fbic","./geom/Polygon.js":"cJuQF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lWCek":[function(require,module,exports) {
/**
 * @module ol/ViewProperty
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    CENTER: "center",
    RESOLUTION: "resolution",
    ROTATION: "rotation"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxYGl":[function(require,module,exports) {
/**
 * @module ol/tilegrid/common
 */ /**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_MAX_ZOOM", ()=>DEFAULT_MAX_ZOOM);
parcelHelpers.export(exports, "DEFAULT_TILE_SIZE", ()=>DEFAULT_TILE_SIZE);
const DEFAULT_MAX_ZOOM = 42;
const DEFAULT_TILE_SIZE = 256;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g3NLx":[function(require,module,exports) {
/**
 * @module ol/centerconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */ /**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */ parcelHelpers.export(exports, "createExtent", ()=>createExtent);
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */ parcelHelpers.export(exports, "none", ()=>none);
var _mathJs = require("./math.js");
function createExtent(extent, onlyCenter, smooth) {
    return(/**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */ function(center, resolution, size, isMoving, centerShift) {
        if (!center) return undefined;
        if (!resolution && !onlyCenter) return center;
        const viewWidth = onlyCenter ? 0 : size[0] * resolution;
        const viewHeight = onlyCenter ? 0 : size[1] * resolution;
        const shiftX = centerShift ? centerShift[0] : 0;
        const shiftY = centerShift ? centerShift[1] : 0;
        let minX = extent[0] + viewWidth / 2 + shiftX;
        let maxX = extent[2] - viewWidth / 2 + shiftX;
        let minY = extent[1] + viewHeight / 2 + shiftY;
        let maxY = extent[3] - viewHeight / 2 + shiftY;
        // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for
        if (minX > maxX) {
            minX = (maxX + minX) / 2;
            maxX = minX;
        }
        if (minY > maxY) {
            minY = (maxY + minY) / 2;
            maxY = minY;
        }
        let x = (0, _mathJs.clamp)(center[0], minX, maxX);
        let y = (0, _mathJs.clamp)(center[1], minY, maxY);
        // during an interaction, allow some overscroll
        if (isMoving && smooth && resolution) {
            const ratio = 30 * resolution;
            x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
            y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }
        return [
            x,
            y
        ];
    });
}
function none(center) {
    return center;
}

},{"./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j8WKZ":[function(require,module,exports) {
/**
 * @module ol/resolutionconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToResolutions", ()=>createSnapToResolutions);
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToPower", ()=>createSnapToPower);
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createMinMaxResolution", ()=>createMinMaxResolution);
var _mathJs = require("./math.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */ /**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */ function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    const xResolution = (0, _extentJs.getWidth)(maxExtent) / viewportSize[0];
    const yResolution = (0, _extentJs.getHeight)(maxExtent) / viewportSize[1];
    if (showFullExtent) return Math.min(resolution, Math.max(xResolution, yResolution));
    return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */ function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    let result = Math.min(resolution, maxResolution);
    const ratio = 50;
    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
    if (minResolution) {
        result = Math.max(result, minResolution);
        result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
    }
    return (0, _mathJs.clamp)(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const maxResolution = resolutions[0];
            const minResolution = resolutions[resolutions.length - 1];
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const capped = Math.min(cappedMaxRes, resolution);
            const z = Math.floor((0, _arrayJs.linearFindNearest)(resolutions, capped, direction));
            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) return resolutions[z + 1];
            return resolutions[z];
        } else return undefined;
    });
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    minResolution = minResolution !== undefined ? minResolution : 0;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const tolerance = 1e-9;
            const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
            const offset = -direction * (0.5 - tolerance) + 0.5;
            const capped = Math.min(cappedMaxRes, resolution);
            const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
            const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
            const newResolution = maxResolution / Math.pow(power, zoomLevel);
            return (0, _mathJs.clamp)(newResolution, minResolution, cappedMaxRes);
        } else return undefined;
    });
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            if (!smooth || !isMoving) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        } else return undefined;
    });
}

},{"./math.js":"5jEFr","./extent.js":"6YrVc","./array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hSWd8":[function(require,module,exports) {
/**
 * @module ol/rotationconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */ /**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "disable", ()=>disable);
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "none", ()=>none);
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToN", ()=>createSnapToN);
/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToZero", ()=>createSnapToZero);
var _mathJs = require("./math.js");
function disable(rotation) {
    if (rotation !== undefined) return 0;
    else return undefined;
}
function none(rotation) {
    if (rotation !== undefined) return rotation;
    else return undefined;
}
function createSnapToN(n) {
    const theta = 2 * Math.PI / n;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving) return rotation;
        if (rotation !== undefined) {
            rotation = Math.floor(rotation / theta + 0.5) * theta;
            return rotation;
        } else return undefined;
    });
}
function createSnapToZero(tolerance) {
    tolerance = tolerance || (0, _mathJs.toRadians)(5);
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving) return rotation;
        if (rotation !== undefined) {
            if (Math.abs(rotation) <= tolerance) return 0;
            else return rotation;
        } else return undefined;
    });
}

},{"./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fYITA":[function(require,module,exports) {
/**
 * @module ol/easing
 */ /**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "easeIn", ()=>easeIn);
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "easeOut", ()=>easeOut);
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "inAndOut", ()=>inAndOut);
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "linear", ()=>linear);
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "upAndDown", ()=>upAndDown);
function easeIn(t) {
    return Math.pow(t, 3);
}
function easeOut(t) {
    return 1 - easeIn(1 - t);
}
function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
    return t;
}
function upAndDown(t) {
    if (t < 0.5) return inAndOut(2 * t);
    else return 1 - inAndOut(2 * (t - 0.5));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kVrDf":[function(require,module,exports) {
/**
 * @module ol/control/defaults
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 */ /**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [options] Options for the default controls.
 * @return {Collection<import("./Control.js").default>} A collection of controls
 * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
 * @api
 */ parcelHelpers.export(exports, "defaults", ()=>defaults);
var _attributionJs = require("./Attribution.js");
var _attributionJsDefault = parcelHelpers.interopDefault(_attributionJs);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _rotateJs = require("./Rotate.js");
var _rotateJsDefault = parcelHelpers.interopDefault(_rotateJs);
var _zoomJs = require("./Zoom.js");
var _zoomJsDefault = parcelHelpers.interopDefault(_zoomJs);
function defaults(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Control.js").default>} */ const controls = new (0, _collectionJsDefault.default)();
    const zoomControl = options.zoom !== undefined ? options.zoom : true;
    if (zoomControl) controls.push(new (0, _zoomJsDefault.default)(options.zoomOptions));
    const rotateControl = options.rotate !== undefined ? options.rotate : true;
    if (rotateControl) controls.push(new (0, _rotateJsDefault.default)(options.rotateOptions));
    const attributionControl = options.attribution !== undefined ? options.attribution : true;
    if (attributionControl) controls.push(new (0, _attributionJsDefault.default)(options.attributionOptions));
    return controls;
}

},{"./Attribution.js":"34CRm","../Collection.js":"gReoh","./Rotate.js":"h01dD","./Zoom.js":"956F8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34CRm":[function(require,module,exports) {
/**
 * @module ol/control/Attribution
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _arrayJs = require("../array.js");
var _layerJs = require("../layer/Layer.js");
var _domJs = require("../dom.js");
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */ /**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */ class Attribution extends (0, _controlJsDefault.default) {
    /**
   * @param {Options} [options] Attribution options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement("div"),
            render: options.render,
            target: options.target
        });
        /**
     * @private
     * @type {HTMLElement}
     */ this.ulElement_ = document.createElement("ul");
        /**
     * @private
     * @type {boolean}
     */ this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
        /**
     * @private
     * @type {boolean}
     */ this.userCollapsed_ = this.collapsed_;
        /**
     * @private
     * @type {boolean}
     */ this.overrideCollapsible_ = options.collapsible !== undefined;
        /**
     * @private
     * @type {boolean}
     */ this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
        if (!this.collapsible_) this.collapsed_ = false;
        const className = options.className !== undefined ? options.className : "ol-attribution";
        const tipLabel = options.tipLabel !== undefined ? options.tipLabel : "Attributions";
        const expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + "-expand";
        const collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "›";
        const collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + "-collapse";
        if (typeof collapseLabel === "string") {
            /**
       * @private
       * @type {HTMLElement}
       */ this.collapseLabel_ = document.createElement("span");
            this.collapseLabel_.textContent = collapseLabel;
            this.collapseLabel_.className = collapseClassName;
        } else this.collapseLabel_ = collapseLabel;
        const label = options.label !== undefined ? options.label : "i";
        if (typeof label === "string") {
            /**
       * @private
       * @type {HTMLElement}
       */ this.label_ = document.createElement("span");
            this.label_.textContent = label;
            this.label_.className = expandClassName;
        } else this.label_ = label;
        const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
        /**
     * @private
     * @type {HTMLElement}
     */ this.toggleButton_ = document.createElement("button");
        this.toggleButton_.setAttribute("type", "button");
        this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
        this.toggleButton_.title = tipLabel;
        this.toggleButton_.appendChild(activeLabel);
        this.toggleButton_.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this), false);
        const cssClasses = className + " " + (0, _cssJs.CLASS_UNSELECTABLE) + " " + (0, _cssJs.CLASS_CONTROL) + (this.collapsed_ && this.collapsible_ ? " " + (0, _cssJs.CLASS_COLLAPSED) : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(this.toggleButton_);
        element.appendChild(this.ulElement_);
        /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */ this.renderedAttributions_ = [];
        /**
     * @private
     * @type {boolean}
     */ this.renderedVisible_ = true;
    }
    /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */ collectSourceAttributions_(frameState) {
        /**
     * Used to determine if an attribution already exists.
     * @type {!Object<string, boolean>}
     */ const lookup = {};
        /**
     * A list of visible attributions.
     * @type {Array<string>}
     */ const visibleAttributions = [];
        let collapsible = true;
        const layerStatesArray = frameState.layerStatesArray;
        for(let i = 0, ii = layerStatesArray.length; i < ii; ++i){
            const layerState = layerStatesArray[i];
            if (!(0, _layerJs.inView)(layerState, frameState.viewState)) continue;
            const source = /** @type {import("../layer/Layer.js").default} */ layerState.layer.getSource();
            if (!source) continue;
            const attributionGetter = source.getAttributions();
            if (!attributionGetter) continue;
            const attributions = attributionGetter(frameState);
            if (!attributions) continue;
            collapsible = collapsible && source.getAttributionsCollapsible() !== false;
            if (Array.isArray(attributions)) {
                for(let j = 0, jj = attributions.length; j < jj; ++j)if (!(attributions[j] in lookup)) {
                    visibleAttributions.push(attributions[j]);
                    lookup[attributions[j]] = true;
                }
            } else if (!(attributions in lookup)) {
                visibleAttributions.push(attributions);
                lookup[attributions] = true;
            }
        }
        if (!this.overrideCollapsible_) this.setCollapsible(collapsible);
        return visibleAttributions;
    }
    /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ updateElement_(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element.style.display = "none";
                this.renderedVisible_ = false;
            }
            return;
        }
        const attributions = this.collectSourceAttributions_(frameState);
        const visible = attributions.length > 0;
        if (this.renderedVisible_ != visible) {
            this.element.style.display = visible ? "" : "none";
            this.renderedVisible_ = visible;
        }
        if ((0, _arrayJs.equals)(attributions, this.renderedAttributions_)) return;
        (0, _domJs.removeChildren)(this.ulElement_);
        // append the attributions
        for(let i = 0, ii = attributions.length; i < ii; ++i){
            const element = document.createElement("li");
            element.innerHTML = attributions[i];
            this.ulElement_.appendChild(element);
        }
        this.renderedAttributions_ = attributions;
    }
    /**
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(event) {
        event.preventDefault();
        this.handleToggle_();
        this.userCollapsed_ = this.collapsed_;
    }
    /**
   * @private
   */ handleToggle_() {
        this.element.classList.toggle((0, _cssJs.CLASS_COLLAPSED));
        if (this.collapsed_) (0, _domJs.replaceNode)(this.collapseLabel_, this.label_);
        else (0, _domJs.replaceNode)(this.label_, this.collapseLabel_);
        this.collapsed_ = !this.collapsed_;
        this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    }
    /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */ getCollapsible() {
        return this.collapsible_;
    }
    /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */ setCollapsible(collapsible) {
        if (this.collapsible_ === collapsible) return;
        this.collapsible_ = collapsible;
        this.element.classList.toggle("ol-uncollapsible");
        if (this.userCollapsed_) this.handleToggle_();
    }
    /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */ setCollapsed(collapsed) {
        this.userCollapsed_ = collapsed;
        if (!this.collapsible_ || this.collapsed_ === collapsed) return;
        this.handleToggle_();
    }
    /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */ getCollapsed() {
        return this.collapsed_;
    }
    /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */ render(mapEvent) {
        this.updateElement_(mapEvent.frameState);
    }
}
exports.default = Attribution;

},{"./Control.js":"a2mnq","../events/EventType.js":"hrQJ6","../css.js":"lDlNi","../array.js":"1Fbic","../layer/Layer.js":"8J9Kf","../dom.js":"84QzQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a2mnq":[function(require,module,exports) {
/**
 * @module ol/control/Control
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _mapEventTypeJs = require("../MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _functionsJs = require("../functions.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */ class Control extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Control options.
   */ constructor(options){
        super();
        const element = options.element;
        if (element && !options.target && !element.style.pointerEvents) element.style.pointerEvents = "auto";
        /**
     * @protected
     * @type {HTMLElement}
     */ this.element = element ? element : null;
        /**
     * @private
     * @type {HTMLElement}
     */ this.target_ = null;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */ this.listenerKeys = [];
        if (options.render) this.render = options.render;
        if (options.target) this.setTarget(options.target);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        (0, _domJs.removeNode)(this.element);
        super.disposeInternal();
    }
    /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */ getMap() {
        return this.map_;
    }
    /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        if (this.map_) (0, _domJs.removeNode)(this.element);
        for(let i = 0, ii = this.listenerKeys.length; i < ii; ++i)(0, _eventsJs.unlistenByKey)(this.listenerKeys[i]);
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
            const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
            target.appendChild(this.element);
            if (this.render !== (0, _functionsJs.VOID)) this.listenerKeys.push((0, _eventsJs.listen)(map, (0, _mapEventTypeJsDefault.default).POSTRENDER, this.render, this));
            map.render();
        }
    }
    /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */ render(mapEvent) {}
    /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */ setTarget(target) {
        this.target_ = typeof target === "string" ? document.getElementById(target) : target;
    }
}
exports.default = Control;

},{"../Object.js":"1zG8z","../MapEventType.js":"1cFF9","../functions.js":"iqv8I","../events.js":"dcspA","../dom.js":"84QzQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h01dD":[function(require,module,exports) {
/**
 * @module ol/control/Rotate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _easingJs = require("../easing.js");
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */ class Rotate extends (0, _controlJsDefault.default) {
    /**
   * @param {Options} [options] Rotate options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement("div"),
            render: options.render,
            target: options.target
        });
        const className = options.className !== undefined ? options.className : "ol-rotate";
        const label = options.label !== undefined ? options.label : "⇧";
        const compassClassName = options.compassClassName !== undefined ? options.compassClassName : "ol-compass";
        /**
     * @type {HTMLElement}
     * @private
     */ this.label_ = null;
        if (typeof label === "string") {
            this.label_ = document.createElement("span");
            this.label_.className = compassClassName;
            this.label_.textContent = label;
        } else {
            this.label_ = label;
            this.label_.classList.add(compassClassName);
        }
        const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
        const button = document.createElement("button");
        button.className = className + "-reset";
        button.setAttribute("type", "button");
        button.title = tipLabel;
        button.appendChild(this.label_);
        button.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this), false);
        const cssClasses = className + " " + (0, _cssJs.CLASS_UNSELECTABLE) + " " + (0, _cssJs.CLASS_CONTROL);
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(button);
        this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
        /**
     * @type {number}
     * @private
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
     * @type {boolean}
     * @private
     */ this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = undefined;
        if (this.autoHide_) this.element.classList.add((0, _cssJs.CLASS_HIDDEN));
    }
    /**
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(event) {
        event.preventDefault();
        if (this.callResetNorth_ !== undefined) this.callResetNorth_();
        else this.resetNorth_();
    }
    /**
   * @private
   */ resetNorth_() {
        const map = this.getMap();
        const view = map.getView();
        if (!view) // the map does not have a view, so we can't act
        // upon it
        return;
        const rotation = view.getRotation();
        if (rotation !== undefined) {
            if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) view.animate({
                rotation: 0,
                duration: this.duration_,
                easing: (0, _easingJs.easeOut)
            });
            else view.setRotation(0);
        }
    }
    /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */ render(mapEvent) {
        const frameState = mapEvent.frameState;
        if (!frameState) return;
        const rotation = frameState.viewState.rotation;
        if (rotation != this.rotation_) {
            const transform = "rotate(" + rotation + "rad)";
            if (this.autoHide_) {
                const contains = this.element.classList.contains((0, _cssJs.CLASS_HIDDEN));
                if (!contains && rotation === 0) this.element.classList.add((0, _cssJs.CLASS_HIDDEN));
                else if (contains && rotation !== 0) this.element.classList.remove((0, _cssJs.CLASS_HIDDEN));
            }
            this.label_.style.transform = transform;
        }
        this.rotation_ = rotation;
    }
}
exports.default = Rotate;

},{"./Control.js":"a2mnq","../events/EventType.js":"hrQJ6","../css.js":"lDlNi","../easing.js":"fYITA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"956F8":[function(require,module,exports) {
/**
 * @module ol/control/Zoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _easingJs = require("../easing.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */ class Zoom extends (0, _controlJsDefault.default) {
    /**
   * @param {Options} [options] Zoom options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement("div"),
            target: options.target
        });
        const className = options.className !== undefined ? options.className : "ol-zoom";
        const delta = options.delta !== undefined ? options.delta : 1;
        const zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + "-in";
        const zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + "-out";
        const zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : "+";
        const zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : "–";
        const zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : "Zoom in";
        const zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : "Zoom out";
        const inElement = document.createElement("button");
        inElement.className = zoomInClassName;
        inElement.setAttribute("type", "button");
        inElement.title = zoomInTipLabel;
        inElement.appendChild(typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel);
        inElement.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this, delta), false);
        const outElement = document.createElement("button");
        outElement.className = zoomOutClassName;
        outElement.setAttribute("type", "button");
        outElement.title = zoomOutTipLabel;
        outElement.appendChild(typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
        outElement.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this, -delta), false);
        const cssClasses = className + " " + (0, _cssJs.CLASS_UNSELECTABLE) + " " + (0, _cssJs.CLASS_CONTROL);
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(inElement);
        element.appendChild(outElement);
        /**
     * @type {number}
     * @private
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(delta, event) {
        event.preventDefault();
        this.zoomByDelta_(delta);
    }
    /**
   * @param {number} delta Zoom delta.
   * @private
   */ zoomByDelta_(delta) {
        const map = this.getMap();
        const view = map.getView();
        if (!view) // the map does not have a view, so we can't act
        // upon it
        return;
        const currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            const newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (this.duration_ > 0) {
                if (view.getAnimating()) view.cancelAnimations();
                view.animate({
                    zoom: newZoom,
                    duration: this.duration_,
                    easing: (0, _easingJs.easeOut)
                });
            } else view.setZoom(newZoom);
        }
    }
}
exports.default = Zoom;

},{"./Control.js":"a2mnq","../events/EventType.js":"hrQJ6","../css.js":"lDlNi","../easing.js":"fYITA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1L9Hg":[function(require,module,exports) {
/**
 * @module ol/interaction/defaults
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */ /**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [options] Defaults options.
 * @return {Collection<import("./Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */ parcelHelpers.export(exports, "defaults", ()=>defaults);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _doubleClickZoomJs = require("./DoubleClickZoom.js");
var _doubleClickZoomJsDefault = parcelHelpers.interopDefault(_doubleClickZoomJs);
var _dragPanJs = require("./DragPan.js");
var _dragPanJsDefault = parcelHelpers.interopDefault(_dragPanJs);
var _dragRotateJs = require("./DragRotate.js");
var _dragRotateJsDefault = parcelHelpers.interopDefault(_dragRotateJs);
var _dragZoomJs = require("./DragZoom.js");
var _dragZoomJsDefault = parcelHelpers.interopDefault(_dragZoomJs);
var _keyboardPanJs = require("./KeyboardPan.js");
var _keyboardPanJsDefault = parcelHelpers.interopDefault(_keyboardPanJs);
var _keyboardZoomJs = require("./KeyboardZoom.js");
var _keyboardZoomJsDefault = parcelHelpers.interopDefault(_keyboardZoomJs);
var _kineticJs = require("../Kinetic.js");
var _kineticJsDefault = parcelHelpers.interopDefault(_kineticJs);
var _mouseWheelZoomJs = require("./MouseWheelZoom.js");
var _mouseWheelZoomJsDefault = parcelHelpers.interopDefault(_mouseWheelZoomJs);
var _pinchRotateJs = require("./PinchRotate.js");
var _pinchRotateJsDefault = parcelHelpers.interopDefault(_pinchRotateJs);
var _pinchZoomJs = require("./PinchZoom.js");
var _pinchZoomJsDefault = parcelHelpers.interopDefault(_pinchZoomJs);
function defaults(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Interaction.js").default>} */ const interactions = new (0, _collectionJsDefault.default)();
    const kinetic = new (0, _kineticJsDefault.default)(-0.005, 0.05, 100);
    const altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
    if (altShiftDragRotate) interactions.push(new (0, _dragRotateJsDefault.default)());
    const doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
    if (doubleClickZoom) interactions.push(new (0, _doubleClickZoomJsDefault.default)({
        delta: options.zoomDelta,
        duration: options.zoomDuration
    }));
    const dragPan = options.dragPan !== undefined ? options.dragPan : true;
    if (dragPan) interactions.push(new (0, _dragPanJsDefault.default)({
        onFocusOnly: options.onFocusOnly,
        kinetic: kinetic
    }));
    const pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
    if (pinchRotate) interactions.push(new (0, _pinchRotateJsDefault.default)());
    const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
    if (pinchZoom) interactions.push(new (0, _pinchZoomJsDefault.default)({
        duration: options.zoomDuration
    }));
    const keyboard = options.keyboard !== undefined ? options.keyboard : true;
    if (keyboard) {
        interactions.push(new (0, _keyboardPanJsDefault.default)());
        interactions.push(new (0, _keyboardZoomJsDefault.default)({
            delta: options.zoomDelta,
            duration: options.zoomDuration
        }));
    }
    const mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
    if (mouseWheelZoom) interactions.push(new (0, _mouseWheelZoomJsDefault.default)({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
    }));
    const shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
    if (shiftDragZoom) interactions.push(new (0, _dragZoomJsDefault.default)({
        duration: options.zoomDuration
    }));
    return interactions;
}

},{"../Collection.js":"gReoh","./DoubleClickZoom.js":"kVR84","./DragPan.js":"4zDnZ","./DragRotate.js":"83edZ","./DragZoom.js":"8xtsQ","./KeyboardPan.js":"49Q4F","./KeyboardZoom.js":"4RjL4","../Kinetic.js":"aWbSH","./MouseWheelZoom.js":"gKXuR","./PinchRotate.js":"5f8eF","./PinchZoom.js":"5RZxv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kVR84":[function(require,module,exports) {
/**
 * @module ol/interaction/DoubleClickZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */ /**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */ class DoubleClickZoom extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {number}
     */ this.delta_ = options.delta ? options.delta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).DBLCLICK) {
            const browserEvent = /** @type {MouseEvent} */ mapBrowserEvent.originalEvent;
            const map = mapBrowserEvent.map;
            const anchor = mapBrowserEvent.coordinate;
            const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
            const view = map.getView();
            (0, _interactionJs.zoomByDelta)(view, delta, anchor, this.duration_);
            browserEvent.preventDefault();
            stopEvent = true;
        }
        return !stopEvent;
    }
}
exports.default = DoubleClickZoom;

},{"./Interaction.js":"g1FUs","../MapBrowserEventType.js":"fB9ae","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g1FUs":[function(require,module,exports) {
/**
 * @module ol/interaction/Interaction
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [duration] Duration.
 */ parcelHelpers.export(exports, "pan", ()=>pan);
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
 * @param {number} [duration] Duration.
 */ parcelHelpers.export(exports, "zoomByDelta", ()=>zoomByDelta);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _easingJs = require("../easing.js");
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */ /**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */ class Interaction extends (0, _objectJsDefault.default) {
    /**
   * @param {InteractionOptions} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {InteractionOnSignature<void>}
     */ this.un;
        if (options && options.handleEvent) this.handleEvent = options.handleEvent;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        this.setActive(true);
    }
    /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */ getActive() {
        return /** @type {boolean} */ this.get((0, _propertyJsDefault.default).ACTIVE);
    }
    /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */ getMap() {
        return this.map_;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(mapBrowserEvent) {
        return true;
    }
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */ setActive(active) {
        this.set((0, _propertyJsDefault.default).ACTIVE, active);
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */ setMap(map) {
        this.map_ = map;
    }
}
function pan(view, delta, duration) {
    const currentCenter = view.getCenterInternal();
    if (currentCenter) {
        const center = [
            currentCenter[0] + delta[0],
            currentCenter[1] + delta[1]
        ];
        view.animateInternal({
            duration: duration !== undefined ? duration : 250,
            easing: (0, _easingJs.linear),
            center: view.getConstrainedCenter(center)
        });
    }
}
function zoomByDelta(view, delta, anchor, duration) {
    const currentZoom = view.getZoom();
    if (currentZoom === undefined) return;
    const newZoom = view.getConstrainedZoom(currentZoom + delta);
    const newResolution = view.getResolutionForZoom(newZoom);
    if (view.getAnimating()) view.cancelAnimations();
    view.animate({
        resolution: newResolution,
        anchor: anchor,
        duration: duration !== undefined ? duration : 250,
        easing: (0, _easingJs.easeOut)
    });
}
exports.default = Interaction;

},{"../Object.js":"1zG8z","./Property.js":"lHt12","../easing.js":"fYITA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lHt12":[function(require,module,exports) {
/**
 * @module ol/interaction/Property
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ACTIVE: "active"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4zDnZ":[function(require,module,exports) {
/**
 * @module ol/interaction/DragPan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _easingJs = require("../easing.js");
var _coordinateJs = require("../coordinate.js");
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */ /**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */ class DragPan extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super({
            stopDown: (0, _functionsJs.FALSE)
        });
        options = options ? options : {};
        /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */ this.kinetic_ = options.kinetic;
        /**
     * @type {import("../pixel.js").Pixel}
     */ this.lastCentroid = null;
        /**
     * @type {number}
     */ this.lastPointersCount_;
        /**
     * @type {boolean}
     */ this.panning_ = false;
        const condition = options.condition ? options.condition : (0, _conditionJs.all)((0, _conditionJs.noModifierKeys), (0, _conditionJs.primaryAction));
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.onFocusOnly ? (0, _conditionJs.all)((0, _conditionJs.focusWithTabindex), condition) : condition;
        /**
     * @private
     * @type {boolean}
     */ this.noKinetic_ = false;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        if (!this.panning_) {
            this.panning_ = true;
            this.getMap().getView().beginInteraction();
        }
        const targetPointers = this.targetPointers;
        const centroid = (0, _pointerJs.centroid)(targetPointers);
        if (targetPointers.length == this.lastPointersCount_) {
            if (this.kinetic_) this.kinetic_.update(centroid[0], centroid[1]);
            if (this.lastCentroid) {
                const delta = [
                    this.lastCentroid[0] - centroid[0],
                    centroid[1] - this.lastCentroid[1]
                ];
                const map = mapBrowserEvent.map;
                const view = map.getView();
                (0, _coordinateJs.scale)(delta, view.getResolution());
                (0, _coordinateJs.rotate)(delta, view.getRotation());
                view.adjustCenterInternal(delta);
            }
        } else if (this.kinetic_) // reset so we don't overestimate the kinetic energy after
        // after one finger down, tiny drag, second finger down
        this.kinetic_.begin();
        this.lastCentroid = centroid;
        this.lastPointersCount_ = targetPointers.length;
        mapBrowserEvent.originalEvent.preventDefault();
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                const distance = this.kinetic_.getDistance();
                const angle = this.kinetic_.getAngle();
                const center = view.getCenterInternal();
                const centerpx = map.getPixelFromCoordinateInternal(center);
                const dest = map.getCoordinateFromPixelInternal([
                    centerpx[0] - distance * Math.cos(angle),
                    centerpx[1] - distance * Math.sin(angle)
                ]);
                view.animateInternal({
                    center: view.getConstrainedCenter(dest),
                    duration: 500,
                    easing: (0, _easingJs.easeOut)
                });
            }
            if (this.panning_) {
                this.panning_ = false;
                view.endInteraction();
            }
            return false;
        } else {
            if (this.kinetic_) // reset so we don't overestimate the kinetic energy after
            // after one finger up, tiny drag, second finger up
            this.kinetic_.begin();
            this.lastCentroid = null;
            return true;
        }
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            this.lastCentroid = null;
            // stop any current animation
            if (view.getAnimating()) view.cancelAnimations();
            if (this.kinetic_) this.kinetic_.begin();
            // No kinetic as soon as more than one pointer on the screen is
            // detected. This is to prevent nasty pans after pinch.
            this.noKinetic_ = this.targetPointers.length > 1;
            return true;
        } else return false;
    }
}
exports.default = DragPan;

},{"./Pointer.js":"1GIxf","../functions.js":"iqv8I","../events/condition.js":"iQTYY","../easing.js":"fYITA","../coordinate.js":"85Vu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1GIxf":[function(require,module,exports) {
/**
 * @module ol/interaction/Pointer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */ parcelHelpers.export(exports, "centroid", ()=>centroid);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */ /**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */ class PointerInteraction extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super(/** @type {import("./Interaction.js").InteractionOptions} */ options);
        if (options.handleDownEvent) this.handleDownEvent = options.handleDownEvent;
        if (options.handleDragEvent) this.handleDragEvent = options.handleDragEvent;
        if (options.handleMoveEvent) this.handleMoveEvent = options.handleMoveEvent;
        if (options.handleUpEvent) this.handleUpEvent = options.handleUpEvent;
        if (options.stopDown) this.stopDown = options.stopDown;
        /**
     * @type {boolean}
     * @protected
     */ this.handlingDownUpSequence = false;
        /**
     * @type {Array<PointerEvent>}
     * @protected
     */ this.targetPointers = [];
    }
    /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */ getPointerCount() {
        return this.targetPointers.length;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleDownEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleDragEvent(mapBrowserEvent) {}
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) return true;
        let stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);
        if (this.handlingDownUpSequence) {
            if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG) {
                this.handleDragEvent(mapBrowserEvent);
                // prevent page scrolling during dragging
                mapBrowserEvent.originalEvent.preventDefault();
            } else if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERUP) {
                const handledUp = this.handleUpEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
            }
        } else {
            if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN) {
                const handled = this.handleDownEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handled;
                stopEvent = this.stopDown(handled);
            } else if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE) this.handleMoveEvent(mapBrowserEvent);
        }
        return !stopEvent;
    }
    /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleMoveEvent(mapBrowserEvent) {}
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleUpEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */ stopDown(handled) {
        return handled;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */ updateTrackedPointers_(mapBrowserEvent) {
        if (mapBrowserEvent.activePointers) this.targetPointers = mapBrowserEvent.activePointers;
    }
}
function centroid(pointerEvents) {
    const length = pointerEvents.length;
    let clientX = 0;
    let clientY = 0;
    for(let i = 0; i < length; i++){
        clientX += pointerEvents[i].clientX;
        clientY += pointerEvents[i].clientY;
    }
    return [
        clientX / length,
        clientY / length
    ];
}
exports.default = PointerInteraction;

},{"./Interaction.js":"g1FUs","../MapBrowserEventType.js":"fB9ae","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQTYY":[function(require,module,exports) {
/**
 * @module ol/events/condition
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */ /**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */ parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "altKeyOnly", ()=>altKeyOnly);
parcelHelpers.export(exports, "altShiftKeysOnly", ()=>altShiftKeysOnly);
parcelHelpers.export(exports, "focus", ()=>focus);
parcelHelpers.export(exports, "focusWithTabindex", ()=>focusWithTabindex);
parcelHelpers.export(exports, "always", ()=>always);
parcelHelpers.export(exports, "click", ()=>click);
parcelHelpers.export(exports, "mouseActionButton", ()=>mouseActionButton);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "pointerMove", ()=>pointerMove);
parcelHelpers.export(exports, "singleClick", ()=>singleClick);
parcelHelpers.export(exports, "doubleClick", ()=>doubleClick);
parcelHelpers.export(exports, "noModifierKeys", ()=>noModifierKeys);
parcelHelpers.export(exports, "platformModifierKeyOnly", ()=>platformModifierKeyOnly);
parcelHelpers.export(exports, "shiftKeyOnly", ()=>shiftKeyOnly);
parcelHelpers.export(exports, "targetNotEditable", ()=>targetNotEditable);
parcelHelpers.export(exports, "mouseOnly", ()=>mouseOnly);
parcelHelpers.export(exports, "touchOnly", ()=>touchOnly);
parcelHelpers.export(exports, "penOnly", ()=>penOnly);
parcelHelpers.export(exports, "primaryAction", ()=>primaryAction);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _functionsJs = require("../functions.js");
var _hasJs = require("../has.js");
var _assertsJs = require("../asserts.js");
function all(var_args) {
    const conditions = arguments;
    /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */ return function(event) {
        let pass = true;
        for(let i = 0, ii = conditions.length; i < ii; ++i){
            pass = pass && conditions[i](event);
            if (!pass) break;
        }
        return pass;
    };
}
const altKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const altShiftKeysOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const focus = function(event) {
    const targetElement = event.map.getTargetElement();
    const activeElement = event.map.getOwnerDocument().activeElement;
    return targetElement.contains(activeElement);
};
const focusWithTabindex = function(event) {
    return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
};
const always = (0, _functionsJs.TRUE);
const click = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).CLICK;
};
const mouseActionButton = function(mapBrowserEvent) {
    const originalEvent = /** @type {MouseEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.button == 0 && !((0, _hasJs.WEBKIT) && (0, _hasJs.MAC) && originalEvent.ctrlKey);
};
const never = (0, _functionsJs.FALSE);
const pointerMove = function(mapBrowserEvent) {
    return mapBrowserEvent.type == "pointermove";
};
const singleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK;
};
const doubleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).DBLCLICK;
};
const noModifierKeys = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && ((0, _hasJs.MAC) ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const shiftKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const targetNotEditable = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    const tagName = /** @type {Element} */ originalEvent.target.tagName;
    return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable;
};
const mouseOnly = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvent.pointerType == "mouse";
};
const touchOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === "touch";
};
const penOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === "pen";
};
const primaryAction = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    return pointerEvent.isPrimary && pointerEvent.button === 0;
};

},{"../MapBrowserEventType.js":"fB9ae","../functions.js":"iqv8I","../has.js":"6BDNi","../asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"83edZ":[function(require,module,exports) {
/**
 * @module ol/interaction/DragRotate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _rotationconstraintJs = require("../rotationconstraint.js");
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */ class DragRotate extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super({
            stopDown: (0, _functionsJs.FALSE)
        });
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.altShiftKeysOnly);
        /**
     * @private
     * @type {number|undefined}
     */ this.lastAngle_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        if (!(0, _conditionJs.mouseOnly)(mapBrowserEvent)) return;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (view.getConstraints().rotation === (0, _rotationconstraintJs.disable)) return;
        const size = map.getSize();
        const offset = mapBrowserEvent.pixel;
        const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
        if (this.lastAngle_ !== undefined) {
            const delta = theta - this.lastAngle_;
            view.adjustRotationInternal(-delta);
        }
        this.lastAngle_ = theta;
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        if (!(0, _conditionJs.mouseOnly)(mapBrowserEvent)) return true;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        view.endInteraction(this.duration_);
        return false;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (!(0, _conditionJs.mouseOnly)(mapBrowserEvent)) return false;
        if ((0, _conditionJs.mouseActionButton)(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
            const map = mapBrowserEvent.map;
            map.getView().beginInteraction();
            this.lastAngle_ = undefined;
            return true;
        } else return false;
    }
}
exports.default = DragRotate;

},{"./Pointer.js":"1GIxf","../functions.js":"iqv8I","../events/condition.js":"iQTYY","../rotationconstraint.js":"hSWd8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8xtsQ":[function(require,module,exports) {
/**
 * @module ol/interaction/DragZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dragBoxJs = require("./DragBox.js");
var _dragBoxJsDefault = parcelHelpers.interopDefault(_dragBoxJs);
var _easingJs = require("../easing.js");
var _conditionJs = require("../events/condition.js");
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */ class DragZoom extends (0, _dragBoxJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const condition = options.condition ? options.condition : (0, _conditionJs.shiftKeyOnly);
        super({
            condition: condition,
            className: options.className || "ol-dragzoom",
            minArea: options.minArea
        });
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 200;
        /**
     * @private
     * @type {boolean}
     */ this.out_ = options.out !== undefined ? options.out : false;
    }
    /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */ onBoxEnd(event) {
        const map = this.getMap();
        const view = /** @type {!import("../View.js").default} */ map.getView();
        let geometry = this.getGeometry();
        if (this.out_) {
            const rotatedExtent = view.rotatedExtentForGeometry(geometry);
            const resolution = view.getResolutionForExtentInternal(rotatedExtent);
            const factor = view.getResolution() / resolution;
            geometry = geometry.clone();
            geometry.scale(factor * factor);
        }
        view.fitInternal(geometry, {
            duration: this.duration_,
            easing: (0, _easingJs.easeOut)
        });
    }
}
exports.default = DragZoom;

},{"./DragBox.js":"b4kkx","../easing.js":"fYITA","../events/condition.js":"iQTYY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b4kkx":[function(require,module,exports) {
/**
 * @module ol/interaction/DragBox
 */ // FIXME draw drag box
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */ parcelHelpers.export(exports, "DragBoxEvent", ()=>DragBoxEvent);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _boxJs = require("../render/Box.js");
var _boxJsDefault = parcelHelpers.interopDefault(_boxJs);
var _conditionJs = require("../events/condition.js");
/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */ /**
 * @enum {string}
 */ const DragBoxEventType = {
    /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */ BOXSTART: "boxstart",
    /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */ BOXDRAG: "boxdrag",
    /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */ BOXEND: "boxend",
    /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */ BOXCANCEL: "boxcancel"
};
class DragBoxEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */ constructor(type, coordinate, mapBrowserEvent){
        super(type);
        /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */ this.coordinate = coordinate;
        /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */ /**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */ class DragBox extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {DragBoxOnSignature<void>}
     */ this.un;
        options = options ? options : {};
        /**
     * @type {import("../render/Box.js").default}
     * @private
     */ this.box_ = new (0, _boxJsDefault.default)(options.className || "ol-dragbox");
        /**
     * @type {number}
     * @private
     */ this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
        if (options.onBoxEnd) this.onBoxEnd = options.onBoxEnd;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.startPixel_ = null;
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.mouseActionButton);
        /**
     * @private
     * @type {EndCondition}
     */ this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
    }
    /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */ defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
        const width = endPixel[0] - startPixel[0];
        const height = endPixel[1] - startPixel[1];
        return width * width + height * height >= this.minArea_;
    }
    /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */ getGeometry() {
        return this.box_.getGeometry();
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        this.box_.setMap(null);
        const completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
        if (completeBox) this.onBoxEnd(mapBrowserEvent);
        this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
        return false;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.condition_(mapBrowserEvent)) {
            this.startPixel_ = mapBrowserEvent.pixel;
            this.box_.setMap(mapBrowserEvent.map);
            this.box_.setPixels(this.startPixel_, this.startPixel_);
            this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
            return true;
        } else return false;
    }
    /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */ onBoxEnd(event) {}
}
exports.default = DragBox;

},{"../events/Event.js":"hwXQP","./Pointer.js":"1GIxf","../render/Box.js":"dUP5P","../events/condition.js":"iQTYY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dUP5P":[function(require,module,exports) {
/**
 * @module ol/render/Box
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
class RenderBox extends (0, _disposableJsDefault.default) {
    /**
   * @param {string} className CSS class name.
   */ constructor(className){
        super();
        /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */ this.geometry_ = null;
        /**
     * @type {HTMLDivElement}
     * @private
     */ this.element_ = document.createElement("div");
        this.element_.style.position = "absolute";
        this.element_.style.pointerEvents = "auto";
        this.element_.className = "ol-box " + className;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */ this.startPixel_ = null;
        /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */ this.endPixel_ = null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.setMap(null);
    }
    /**
   * @private
   */ render_() {
        const startPixel = this.startPixel_;
        const endPixel = this.endPixel_;
        const px = "px";
        const style = this.element_.style;
        style.left = Math.min(startPixel[0], endPixel[0]) + px;
        style.top = Math.min(startPixel[1], endPixel[1]) + px;
        style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
        style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
    }
    /**
   * @param {import("../Map.js").default|null} map Map.
   */ setMap(map) {
        if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const style = this.element_.style;
            style.left = "inherit";
            style.top = "inherit";
            style.width = "inherit";
            style.height = "inherit";
        }
        this.map_ = map;
        if (this.map_) this.map_.getOverlayContainer().appendChild(this.element_);
    }
    /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */ setPixels(startPixel, endPixel) {
        this.startPixel_ = startPixel;
        this.endPixel_ = endPixel;
        this.createOrUpdateGeometry();
        this.render_();
    }
    /**
   * Creates or updates the cached geometry.
   */ createOrUpdateGeometry() {
        const startPixel = this.startPixel_;
        const endPixel = this.endPixel_;
        const pixels = [
            startPixel,
            [
                startPixel[0],
                endPixel[1]
            ],
            endPixel,
            [
                endPixel[0],
                startPixel[1]
            ]
        ];
        const coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
        // close the polygon
        coordinates[4] = coordinates[0].slice();
        if (!this.geometry_) this.geometry_ = new (0, _polygonJsDefault.default)([
            coordinates
        ]);
        else this.geometry_.setCoordinates([
            coordinates
        ]);
    }
    /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */ getGeometry() {
        return this.geometry_;
    }
}
exports.default = RenderBox;

},{"../Disposable.js":"c0oTM","../geom/Polygon.js":"cJuQF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"49Q4F":[function(require,module,exports) {
/**
 * @module ol/interaction/KeyboardPan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _keyCodeJs = require("../events/KeyCode.js");
var _keyCodeJsDefault = parcelHelpers.interopDefault(_keyCodeJs);
var _conditionJs = require("../events/condition.js");
var _coordinateJs = require("../coordinate.js");
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */ /**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */ class KeyboardPan extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options || {};
        /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */ this.defaultCondition_ = function(mapBrowserEvent) {
            return (0, _conditionJs.noModifierKeys)(mapBrowserEvent) && (0, _conditionJs.targetNotEditable)(mapBrowserEvent);
        };
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 100;
        /**
     * @private
     * @type {number}
     */ this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardPan}
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == (0, _eventTypeJsDefault.default).KEYDOWN) {
            const keyEvent = /** @type {KeyboardEvent} */ mapBrowserEvent.originalEvent;
            const keyCode = keyEvent.keyCode;
            if (this.condition_(mapBrowserEvent) && (keyCode == (0, _keyCodeJsDefault.default).DOWN || keyCode == (0, _keyCodeJsDefault.default).LEFT || keyCode == (0, _keyCodeJsDefault.default).RIGHT || keyCode == (0, _keyCodeJsDefault.default).UP)) {
                const map = mapBrowserEvent.map;
                const view = map.getView();
                const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                let deltaX = 0, deltaY = 0;
                if (keyCode == (0, _keyCodeJsDefault.default).DOWN) deltaY = -mapUnitsDelta;
                else if (keyCode == (0, _keyCodeJsDefault.default).LEFT) deltaX = -mapUnitsDelta;
                else if (keyCode == (0, _keyCodeJsDefault.default).RIGHT) deltaX = mapUnitsDelta;
                else deltaY = mapUnitsDelta;
                const delta = [
                    deltaX,
                    deltaY
                ];
                (0, _coordinateJs.rotate)(delta, view.getRotation());
                (0, _interactionJs.pan)(view, delta, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    }
}
exports.default = KeyboardPan;

},{"../events/EventType.js":"hrQJ6","./Interaction.js":"g1FUs","../events/KeyCode.js":"hChv2","../events/condition.js":"iQTYY","../coordinate.js":"85Vu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hChv2":[function(require,module,exports) {
/**
 * @module ol/events/KeyCode
 */ /**
 * @enum {number}
 * @const
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4RjL4":[function(require,module,exports) {
/**
 * @module ol/interaction/KeyboardZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _conditionJs = require("../events/condition.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */ /**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */ class KeyboardZoom extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.targetNotEditable);
        /**
     * @private
     * @type {number}
     */ this.delta_ = options.delta ? options.delta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 100;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardZoom}
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == (0, _eventTypeJsDefault.default).KEYDOWN || mapBrowserEvent.type == (0, _eventTypeJsDefault.default).KEYPRESS) {
            const keyEvent = /** @type {KeyboardEvent} */ mapBrowserEvent.originalEvent;
            const charCode = keyEvent.charCode;
            if (this.condition_(mapBrowserEvent) && (charCode == "+".charCodeAt(0) || charCode == "-".charCodeAt(0))) {
                const map = mapBrowserEvent.map;
                const delta = charCode == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
                const view = map.getView();
                (0, _interactionJs.zoomByDelta)(view, delta, undefined, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    }
}
exports.default = KeyboardZoom;

},{"../events/EventType.js":"hrQJ6","./Interaction.js":"g1FUs","../events/condition.js":"iQTYY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aWbSH":[function(require,module,exports) {
/**
 * @module ol/Kinetic
 */ /**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Kinetic {
    /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */ constructor(decay, minVelocity, delay){
        /**
     * @private
     * @type {number}
     */ this.decay_ = decay;
        /**
     * @private
     * @type {number}
     */ this.minVelocity_ = minVelocity;
        /**
     * @private
     * @type {number}
     */ this.delay_ = delay;
        /**
     * @private
     * @type {Array<number>}
     */ this.points_ = [];
        /**
     * @private
     * @type {number}
     */ this.angle_ = 0;
        /**
     * @private
     * @type {number}
     */ this.initialVelocity_ = 0;
    }
    /**
   * FIXME empty description for jsdoc
   */ begin() {
        this.points_.length = 0;
        this.angle_ = 0;
        this.initialVelocity_ = 0;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   */ update(x, y) {
        this.points_.push(x, y, Date.now());
    }
    /**
   * @return {boolean} Whether we should do kinetic animation.
   */ end() {
        if (this.points_.length < 6) // at least 2 points are required (i.e. there must be at least 6 elements
        // in the array)
        return false;
        const delay = Date.now() - this.delay_;
        const lastIndex = this.points_.length - 3;
        if (this.points_[lastIndex + 2] < delay) // the last tracked point is too old, which means that the user stopped
        // panning before releasing the map
        return false;
        // get the first point which still falls into the delay time
        let firstIndex = lastIndex - 3;
        while(firstIndex > 0 && this.points_[firstIndex + 2] > delay)firstIndex -= 3;
        const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
        // we don't want a duration of 0 (divide by zero)
        // we also make sure the user panned for a duration of at least one frame
        // (1/60s) to compute sane displacement values
        if (duration < 1000 / 60) return false;
        const dx = this.points_[lastIndex] - this.points_[firstIndex];
        const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
        this.angle_ = Math.atan2(dy, dx);
        this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
        return this.initialVelocity_ > this.minVelocity_;
    }
    /**
   * @return {number} Total distance travelled (pixels).
   */ getDistance() {
        return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */ getAngle() {
        return this.angle_;
    }
}
exports.default = Kinetic;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKXuR":[function(require,module,exports) {
/**
 * @module ol/interaction/MouseWheelZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _hasJs = require("../has.js");
var _conditionJs = require("../events/condition.js");
var _mathJs = require("../math.js");
/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */ class MouseWheelZoom extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super(/** @type {import("./Interaction.js").InteractionOptions} */ options);
        /**
     * @private
     * @type {number}
     */ this.totalDelta_ = 0;
        /**
     * @private
     * @type {number}
     */ this.lastDelta_ = 0;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
     * @private
     * @type {number}
     */ this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
        /**
     * @private
     * @type {boolean}
     */ this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
        /**
     * @private
     * @type {boolean}
     */ this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
        const condition = options.condition ? options.condition : (0, _conditionJs.always);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.onFocusOnly ? (0, _conditionJs.all)((0, _conditionJs.focusWithTabindex), condition) : condition;
        /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */ this.lastAnchor_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.startTime_ = undefined;
        /**
     * @private
     * @type {?}
     */ this.timeoutId_;
        /**
     * @private
     * @type {Mode|undefined}
     */ this.mode_ = undefined;
        /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */ this.trackpadEventGap_ = 400;
        /**
     * @type {?}
     */ this.trackpadTimeoutId_;
        /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */ this.deltaPerZoom_ = 300;
    }
    /**
   * @private
   */ endInteraction_() {
        this.trackpadTimeoutId_ = undefined;
        const map = this.getMap();
        if (!map) return;
        const view = map.getView();
        view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) return true;
        const type = mapBrowserEvent.type;
        if (type !== (0, _eventTypeJsDefault.default).WHEEL) return true;
        const map = mapBrowserEvent.map;
        const wheelEvent = /** @type {WheelEvent} */ mapBrowserEvent.originalEvent;
        wheelEvent.preventDefault();
        if (this.useAnchor_) this.lastAnchor_ = mapBrowserEvent.coordinate;
        // Delta normalisation inspired by
        // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
        let delta;
        if (mapBrowserEvent.type == (0, _eventTypeJsDefault.default).WHEEL) {
            delta = wheelEvent.deltaY;
            if ((0, _hasJs.FIREFOX) && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) delta /= (0, _hasJs.DEVICE_PIXEL_RATIO);
            if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) delta *= 40;
        }
        if (delta === 0) return false;
        else this.lastDelta_ = delta;
        const now = Date.now();
        if (this.startTime_ === undefined) this.startTime_ = now;
        if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
        const view = map.getView();
        if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
            if (this.trackpadTimeoutId_) clearTimeout(this.trackpadTimeoutId_);
            else {
                if (view.getAnimating()) view.cancelAnimations();
                view.beginInteraction();
            }
            this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
            view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
            this.startTime_ = now;
            return false;
        }
        this.totalDelta_ += delta;
        const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
        clearTimeout(this.timeoutId_);
        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
        return false;
    }
    /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */ handleWheelZoom_(map) {
        const view = map.getView();
        if (view.getAnimating()) view.cancelAnimations();
        let delta = -(0, _mathJs.clamp)(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
        if (view.getConstrainResolution() || this.constrainResolution_) // view has a zoom constraint, zoom by 1
        delta = delta ? delta > 0 ? 1 : -1 : 0;
        (0, _interactionJs.zoomByDelta)(view, delta, this.lastAnchor_, this.duration_);
        this.mode_ = undefined;
        this.totalDelta_ = 0;
        this.lastAnchor_ = null;
        this.startTime_ = undefined;
        this.timeoutId_ = undefined;
    }
    /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */ setMouseAnchor(useAnchor) {
        this.useAnchor_ = useAnchor;
        if (!useAnchor) this.lastAnchor_ = null;
    }
}
exports.default = MouseWheelZoom;

},{"../events/EventType.js":"hrQJ6","./Interaction.js":"g1FUs","../has.js":"6BDNi","../events/condition.js":"iQTYY","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5f8eF":[function(require,module,exports) {
/**
 * @module ol/interaction/PinchRotate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _rotationconstraintJs = require("../rotationconstraint.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */ class PinchRotate extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.anchor_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.lastAngle_ = undefined;
        /**
     * @private
     * @type {boolean}
     */ this.rotating_ = false;
        /**
     * @private
     * @type {number}
     */ this.rotationDelta_ = 0.0;
        /**
     * @private
     * @type {number}
     */ this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        let rotationDelta = 0.0;
        const touch0 = this.targetPointers[0];
        const touch1 = this.targetPointers[1];
        // angle between touches
        const angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
        if (this.lastAngle_ !== undefined) {
            const delta = angle - this.lastAngle_;
            this.rotationDelta_ += delta;
            if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) this.rotating_ = true;
            rotationDelta = delta;
        }
        this.lastAngle_ = angle;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (view.getConstraints().rotation === (0, _rotationconstraintJs.disable)) return;
        // rotate anchor point.
        // FIXME: should be the intersection point between the lines:
        //     touch0,touch1 and previousTouch0,previousTouch1
        const viewportPosition = map.getViewport().getBoundingClientRect();
        const centroid = (0, _pointerJs.centroid)(this.targetPointers);
        centroid[0] -= viewportPosition.left;
        centroid[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
        // rotate
        if (this.rotating_) {
            map.render();
            view.adjustRotationInternal(rotationDelta, this.anchor_);
        }
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            view.endInteraction(this.duration_);
            return false;
        } else return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            const map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastAngle_ = undefined;
            this.rotating_ = false;
            this.rotationDelta_ = 0.0;
            if (!this.handlingDownUpSequence) map.getView().beginInteraction();
            return true;
        } else return false;
    }
}
exports.default = PinchRotate;

},{"./Pointer.js":"1GIxf","../functions.js":"iqv8I","../rotationconstraint.js":"hSWd8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5RZxv":[function(require,module,exports) {
/**
 * @module ol/interaction/PinchZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */ class PinchZoom extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.anchor_ = null;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 400;
        /**
     * @private
     * @type {number|undefined}
     */ this.lastDistance_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.lastScaleDelta_ = 1;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        let scaleDelta = 1.0;
        const touch0 = this.targetPointers[0];
        const touch1 = this.targetPointers[1];
        const dx = touch0.clientX - touch1.clientX;
        const dy = touch0.clientY - touch1.clientY;
        // distance between touches
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (this.lastDistance_ !== undefined) scaleDelta = this.lastDistance_ / distance;
        this.lastDistance_ = distance;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (scaleDelta != 1.0) this.lastScaleDelta_ = scaleDelta;
        // scale anchor point.
        const viewportPosition = map.getViewport().getBoundingClientRect();
        const centroid = (0, _pointerJs.centroid)(this.targetPointers);
        centroid[0] -= viewportPosition.left;
        centroid[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
        // scale, bypass the resolution constraint
        map.render();
        view.adjustResolutionInternal(scaleDelta, this.anchor_);
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
            view.endInteraction(this.duration_, direction);
            return false;
        } else return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            const map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastDistance_ = undefined;
            this.lastScaleDelta_ = 1;
            if (!this.handlingDownUpSequence) map.getView().beginInteraction();
            return true;
        } else return false;
    }
}
exports.default = PinchZoom;

},{"./Pointer.js":"1GIxf","../functions.js":"iqv8I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aRX8V":[function(require,module,exports) {
/**
 * @module ol/source/Raster
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Uint8ClampedArray} data Image data.
 * @param {number} width Number of columns.
 * @param {number} height Number of rows.
 * @return {ImageData} Image data.
 */ parcelHelpers.export(exports, "newImageData", ()=>newImageData);
/**
 * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback
 */ /**
 * @typedef {Object} Job
 * @property {Object} meta Job metadata.
 * @property {Array<ImageData>} inputs Array of input data.
 * @property {JobCallback} callback Called when the job is complete.
 */ /**
 * @typedef {Object} ProcessorOptions
 * @property {number} threads Number of workers to spawn.
 * @property {Operation} operation The operation.
 * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} queue The number of queued jobs to allow.
 * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.
 */ /**
 * @classdesc
 * A processor runs pixel or image operations in workers.
 */ parcelHelpers.export(exports, "Processor", ()=>Processor);
/**
 * @typedef {'pixel' | 'image'} RasterOperationType
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 */ /**
 * @typedef {import("./Image.js").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this
 * type.
 */ parcelHelpers.export(exports, "RasterSourceEvent", ()=>RasterSourceEvent);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageCanvasJs = require("../ImageCanvas.js");
var _imageCanvasJsDefault = parcelHelpers.interopDefault(_imageCanvasJs);
var _imageJs = require("../layer/Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _imageJs1 = require("./Image.js");
var _imageJsDefault1 = parcelHelpers.interopDefault(_imageJs1);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _tileJs = require("../layer/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileQueueJs = require("../TileQueue.js");
var _tileQueueJsDefault = parcelHelpers.interopDefault(_tileQueueJs);
var _tileJs1 = require("./Tile.js");
var _tileJsDefault1 = parcelHelpers.interopDefault(_tileJs1);
var _domJs = require("../dom.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var Buffer = require("buffer").Buffer;
let hasImageData = true;
try {
    new ImageData(10, 10);
} catch (_) {
    hasImageData = false;
}
/** @type {CanvasRenderingContext2D} */ let context;
function newImageData(data, width, height) {
    if (hasImageData) return new ImageData(data, width, height);
    if (!context) context = document.createElement("canvas").getContext("2d");
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    return imageData;
}
/**
 * @typedef {Object} MinionData
 * @property {Array<ArrayBuffer>} buffers Array of buffers.
 * @property {Object} meta Operation metadata.
 * @property {boolean} imageOps The operation is an image operation.
 * @property {number} width The width of the image.
 * @property {number} height The height of the image.
 */ /* istanbul ignore next */ /**
 * Create a function for running operations.  This function is serialized for
 * use in a worker.
 * @param {function(Array, Object):*} operation The operation.
 * @return {function(MinionData):ArrayBuffer} A function that takes an object with
 * buffers, meta, imageOps, width, and height properties and returns an array
 * buffer.
 */ function createMinion(operation) {
    let workerHasImageData = true;
    try {
        new ImageData(10, 10);
    } catch (_) {
        workerHasImageData = false;
    }
    function newWorkerImageData(data, width, height) {
        if (workerHasImageData) return new ImageData(data, width, height);
        else return {
            data: data,
            width: width,
            height: height
        };
    }
    return function(data) {
        // bracket notation for minification support
        const buffers = data["buffers"];
        const meta = data["meta"];
        const imageOps = data["imageOps"];
        const width = data["width"];
        const height = data["height"];
        const numBuffers = buffers.length;
        const numBytes = buffers[0].byteLength;
        if (imageOps) {
            const images = new Array(numBuffers);
            for(let b = 0; b < numBuffers; ++b)images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);
            const output = operation(images, meta).data;
            return output.buffer;
        }
        const output1 = new Uint8ClampedArray(numBytes);
        const arrays = new Array(numBuffers);
        const pixels = new Array(numBuffers);
        for(let b1 = 0; b1 < numBuffers; ++b1){
            arrays[b1] = new Uint8ClampedArray(buffers[b1]);
            pixels[b1] = [
                0,
                0,
                0,
                0
            ];
        }
        for(let i = 0; i < numBytes; i += 4){
            for(let j = 0; j < numBuffers; ++j){
                const array = arrays[j];
                pixels[j][0] = array[i];
                pixels[j][1] = array[i + 1];
                pixels[j][2] = array[i + 2];
                pixels[j][3] = array[i + 3];
            }
            const pixel = operation(pixels, meta);
            output1[i] = pixel[0];
            output1[i + 1] = pixel[1];
            output1[i + 2] = pixel[2];
            output1[i + 3] = pixel[3];
        }
        return output1.buffer;
    };
}
/**
 * Create a worker for running operations.
 * @param {ProcessorOptions} config Processor options.
 * @param {function(MessageEvent): void} onMessage Called with a message event.
 * @return {Worker} The worker.
 */ function createWorker(config, onMessage) {
    const lib = Object.keys(config.lib || {}).map(function(name) {
        return "const " + name + " = " + config.lib[name].toString() + ";";
    });
    const lines = lib.concat([
        "const __minion__ = (" + createMinion.toString() + ")(",
        config.operation.toString(),
        ");",
        'self.addEventListener("message", function(event) {',
        "  const buffer = __minion__(event.data);",
        "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);",
        "});"
    ]);
    const worker = new Worker(typeof Blob === "undefined" ? "data:text/javascript;base64," + Buffer.from(lines.join("\n"), "binary").toString("base64") : URL.createObjectURL(new Blob(lines, {
        type: "text/javascript"
    })));
    worker.addEventListener("message", onMessage);
    return worker;
}
/**
 * @typedef {Object} FauxMessageEvent
 * @property {Object} data Message data.
 */ /**
 * Create a faux worker for running operations.
 * @param {ProcessorOptions} config Configuration.
 * @param {function(FauxMessageEvent): void} onMessage Called with a message event.
 * @return {Object} The faux worker.
 */ function createFauxWorker(config, onMessage) {
    const minion = createMinion(config.operation);
    let terminated = false;
    return {
        postMessage: function(data) {
            setTimeout(function() {
                if (terminated) return;
                onMessage({
                    data: {
                        buffer: minion(data),
                        meta: data["meta"]
                    }
                });
            }, 0);
        },
        terminate: function() {
            terminated = true;
        }
    };
}
class Processor extends (0, _disposableJsDefault.default) {
    /**
   * @param {ProcessorOptions} config Configuration.
   */ constructor(config){
        super();
        this._imageOps = !!config.imageOps;
        let threads;
        if (config.threads === 0) threads = 0;
        else if (this._imageOps) threads = 1;
        else threads = config.threads || 1;
        /**
     * @type {Array<Worker>}
     */ const workers = new Array(threads);
        if (threads) for(let i = 0; i < threads; ++i)workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));
        else workers[0] = createFauxWorker(config, this._onWorkerMessage.bind(this, 0));
        this._workers = workers;
        /**
     * @type {Array<Job>}
     * @private
     */ this._queue = [];
        this._maxQueueLength = config.queue || Infinity;
        this._running = 0;
        /**
     * @type {Object<number, any>}
     * @private
     */ this._dataLookup = {};
        /**
     * @type {Job}
     * @private
     */ this._job = null;
    }
    /**
   * Run operation on input data.
   * @param {Array<ImageData>} inputs Array of image data.
   * @param {Object} meta A user data object.  This is passed to all operations
   *     and must be serializable.
   * @param {function(Error, ImageData, Object): void} callback Called when work
   *     completes.  The first argument is any error.  The second is the ImageData
   *     generated by operations.  The third is the user data object.
   */ process(inputs, meta, callback) {
        this._enqueue({
            inputs: inputs,
            meta: meta,
            callback: callback
        });
        this._dispatch();
    }
    /**
   * Add a job to the queue.
   * @param {Job} job The job.
   */ _enqueue(job) {
        this._queue.push(job);
        while(this._queue.length > this._maxQueueLength)this._queue.shift().callback(null, null);
    }
    /**
   * Dispatch a job.
   */ _dispatch() {
        if (this._running || this._queue.length === 0) return;
        const job = this._queue.shift();
        this._job = job;
        const width = job.inputs[0].width;
        const height = job.inputs[0].height;
        const buffers = job.inputs.map(function(input) {
            return input.data.buffer;
        });
        const threads = this._workers.length;
        this._running = threads;
        if (threads === 1) {
            this._workers[0].postMessage({
                buffers: buffers,
                meta: job.meta,
                imageOps: this._imageOps,
                width: width,
                height: height
            }, buffers);
            return;
        }
        const length = job.inputs[0].data.length;
        const segmentLength = 4 * Math.ceil(length / 4 / threads);
        for(let i = 0; i < threads; ++i){
            const offset = i * segmentLength;
            const slices = [];
            for(let j = 0, jj = buffers.length; j < jj; ++j)slices.push(buffers[j].slice(offset, offset + segmentLength));
            this._workers[i].postMessage({
                buffers: slices,
                meta: job.meta,
                imageOps: this._imageOps,
                width: width,
                height: height
            }, slices);
        }
    }
    /**
   * Handle messages from the worker.
   * @param {number} index The worker index.
   * @param {MessageEvent} event The message event.
   */ _onWorkerMessage(index, event) {
        if (this.disposed) return;
        this._dataLookup[index] = event.data;
        --this._running;
        if (this._running === 0) this._resolveJob();
    }
    /**
   * Resolve a job.  If there are no more worker threads, the processor callback
   * will be called.
   */ _resolveJob() {
        const job = this._job;
        const threads = this._workers.length;
        let data, meta;
        if (threads === 1) {
            data = new Uint8ClampedArray(this._dataLookup[0]["buffer"]);
            meta = this._dataLookup[0]["meta"];
        } else {
            const length = job.inputs[0].data.length;
            data = new Uint8ClampedArray(length);
            meta = new Array(threads);
            const segmentLength = 4 * Math.ceil(length / 4 / threads);
            for(let i = 0; i < threads; ++i){
                const buffer = this._dataLookup[i]["buffer"];
                const offset = i * segmentLength;
                data.set(new Uint8ClampedArray(buffer), offset);
                meta[i] = this._dataLookup[i]["meta"];
            }
        }
        this._job = null;
        this._dataLookup = {};
        job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);
        this._dispatch();
    }
    /**
   * Terminate all workers associated with the processor.
   */ disposeInternal() {
        for(let i = 0; i < this._workers.length; ++i)this._workers[i].terminate();
        this._workers.length = 0;
    }
}
/**
 * A function that takes an array of input data, performs some operation, and
 * returns an array of output data.
 * For `pixel` type operations, the function will be called with an array of
 * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the
 * range of 0 - 255. It should return a single pixel array.
 * For `'image'` type operations, functions will be called with an array of
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)
 * and should return a single
 * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).
 * The operations
 * are called with a second "data" argument, which can be used for storage.  The
 * data object is accessible from raster events, where it can be initialized in
 * "beforeoperations" and accessed again in "afteroperations".
 *
 * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):
 *     (Array<number>|ImageData)} Operation
 */ /**
 * @enum {string}
 */ const RasterEventType = {
    /**
   * Triggered before operations are run.  Listeners will receive an event object with
   * a `data` property that can be used to make data available to operations.
   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations
   * @api
   */ BEFOREOPERATIONS: "beforeoperations",
    /**
   * Triggered after operations are run.  Listeners will receive an event object with
   * a `data` property.  If more than one thread is used, `data` will be an array of
   * objects.  If a single thread is used, `data` will be a single object.
   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations
   * @api
   */ AFTEROPERATIONS: "afteroperations"
};
class RasterSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {import("../Map.js").FrameState} frameState The frame state.
   * @param {Object|Array<Object>} data An object made available to operations.  For "afteroperations" evenets
   * this will be an array of objects if more than one thread is used.
   */ constructor(type, frameState, data){
        super(type);
        /**
     * The raster extent.
     * @type {import("../extent.js").Extent}
     * @api
     */ this.extent = frameState.extent;
        /**
     * The pixel resolution (map units per pixel).
     * @type {number}
     * @api
     */ this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
        /**
     * An object made available to all operations.  This can be used by operations
     * as a storage object (e.g. for calculating statistics).
     * @type {Object}
     * @api
     */ this.data = data;
    }
}
/**
 * @typedef {Object} Options
 * @property {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources Input
 * sources or layers.  For vector data, use an VectorImage layer.
 * @property {Operation} [operation] Raster operation.
 * The operation will be called with data from input sources
 * and the output will be assigned to the raster source.
 * @property {Object} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} [threads] By default, operations will be run in a single worker thread.
 * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can
 * be run in multiple worker threads.  Note that there is additional overhead in
 * transferring data to multiple workers, and that depending on the user's
 * system, it may not be possible to parallelize the work.
 * @property {RasterOperationType} [operationType='pixel'] Operation type.
 * Supported values are `'pixel'` and `'image'`.  By default,
 * `'pixel'` operations are assumed, and operations will be called with an
 * array of pixels from input sources.  If set to `'image'`, operations will
 * be called with an array of ImageData objects from input sources.
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./Image.js").ImageSourceEventTypes, import("./Image.js").ImageSourceEvent, Return> &
 *   import("../Observable").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature
 */ /**
 * @classdesc
 * A source that transforms data from any number of input sources using an
 * {@link module:ol/source/Raster~Operation} function to transform input pixel values into
 * output pixel values.
 *
 * @fires module:ol/source/Raster.RasterSourceEvent
 * @api
 */ class RasterSource extends (0, _imageJsDefault1.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        super({
            projection: null
        });
        /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {RasterSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {RasterSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {Processor}
     */ this.processor_ = null;
        /**
     * @private
     * @type {RasterOperationType}
     */ this.operationType_ = options.operationType !== undefined ? options.operationType : "pixel";
        /**
     * @private
     * @type {number}
     */ this.threads_ = options.threads !== undefined ? options.threads : 1;
        /**
     * @private
     * @type {Array<import("../layer/Layer.js").default>}
     */ this.layers_ = createLayers(options.sources);
        const changed = this.changed.bind(this);
        for(let i = 0, ii = this.layers_.length; i < ii; ++i)this.layers_[i].addEventListener((0, _eventTypeJsDefault.default).CHANGE, changed);
        /**
     * @private
     * @type {import("../TileQueue.js").default}
     */ this.tileQueue_ = new (0, _tileQueueJsDefault.default)(function() {
            return 1;
        }, this.changed.bind(this));
        /**
     * The most recently requested frame state.
     * @type {import("../Map.js").FrameState}
     * @private
     */ this.requestedFrameState_;
        /**
     * The most recently rendered image canvas.
     * @type {import("../ImageCanvas.js").default}
     * @private
     */ this.renderedImageCanvas_ = null;
        /**
     * The most recently rendered revision.
     * @type {number}
     */ this.renderedRevision_;
        /**
     * @private
     * @type {import("../Map.js").FrameState}
     */ this.frameState_ = {
            animate: false,
            coordinateToPixelTransform: (0, _transformJs.create)(),
            declutterTree: null,
            extent: null,
            index: 0,
            layerIndex: 0,
            layerStatesArray: getLayerStatesArray(this.layers_),
            pixelRatio: 1,
            pixelToCoordinateTransform: (0, _transformJs.create)(),
            postRenderFunctions: [],
            size: [
                0,
                0
            ],
            tileQueue: this.tileQueue_,
            time: Date.now(),
            usedTiles: {},
            viewState: /** @type {import("../View.js").State} */ {
                rotation: 0
            },
            viewHints: [],
            wantedTiles: {},
            mapId: (0, _utilJs.getUid)(this),
            renderTargets: {}
        };
        this.setAttributions(function(frameState) {
            const attributions = [];
            for(let index = 0, iMax = options.sources.length; index < iMax; ++index){
                const sourceOrLayer = options.sources[index];
                const source = sourceOrLayer instanceof (0, _sourceJsDefault.default) ? sourceOrLayer : sourceOrLayer.getSource();
                const attributionGetter = source.getAttributions();
                if (typeof attributionGetter === "function") {
                    const sourceAttribution = attributionGetter(frameState);
                    attributions.push.apply(attributions, sourceAttribution);
                }
            }
            return attributions.length !== 0 ? attributions : null;
        });
        if (options.operation !== undefined) this.setOperation(options.operation, options.lib);
    }
    /**
   * Set the operation.
   * @param {Operation} operation New operation.
   * @param {Object} [lib] Functions that will be available to operations run
   *     in a worker.
   * @api
   */ setOperation(operation, lib) {
        if (this.processor_) this.processor_.dispose();
        this.processor_ = new Processor({
            operation: operation,
            imageOps: this.operationType_ === "image",
            queue: 1,
            lib: lib,
            threads: this.threads_
        });
        this.changed();
    }
    /**
   * Update the stored frame state.
   * @param {import("../extent.js").Extent} extent The view extent (in map units).
   * @param {number} resolution The view resolution.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {import("../Map.js").FrameState} The updated frame state.
   * @private
   */ updateFrameState_(extent, resolution, projection) {
        const frameState = /** @type {import("../Map.js").FrameState} */ Object.assign({}, this.frameState_);
        frameState.viewState = /** @type {import("../View.js").State} */ Object.assign({}, frameState.viewState);
        const center = (0, _extentJs.getCenter)(extent);
        frameState.extent = extent.slice();
        frameState.size[0] = Math.round((0, _extentJs.getWidth)(extent) / resolution);
        frameState.size[1] = Math.round((0, _extentJs.getHeight)(extent) / resolution);
        frameState.time = Date.now();
        const viewState = frameState.viewState;
        viewState.center = center;
        viewState.projection = projection;
        viewState.resolution = resolution;
        return frameState;
    }
    /**
   * Determine if all sources are ready.
   * @return {boolean} All sources are ready.
   * @private
   */ allSourcesReady_() {
        let ready = true;
        let source;
        for(let i = 0, ii = this.layers_.length; i < ii; ++i){
            source = this.layers_[i].getSource();
            if (source.getState() !== "ready") {
                ready = false;
                break;
            }
        }
        return ready;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */ getImage(extent, resolution, pixelRatio, projection) {
        if (!this.allSourcesReady_()) return null;
        const frameState = this.updateFrameState_(extent, resolution, projection);
        this.requestedFrameState_ = frameState;
        // check if we can't reuse the existing ol/ImageCanvas
        if (this.renderedImageCanvas_) {
            const renderedResolution = this.renderedImageCanvas_.getResolution();
            const renderedExtent = this.renderedImageCanvas_.getExtent();
            if (resolution !== renderedResolution || !(0, _extentJs.equals)(extent, renderedExtent)) this.renderedImageCanvas_ = null;
        }
        if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) this.processSources_();
        frameState.tileQueue.loadMoreTiles(16, 16);
        if (frameState.animate) requestAnimationFrame(this.changed.bind(this));
        return this.renderedImageCanvas_;
    }
    /**
   * Start processing source data.
   * @private
   */ processSources_() {
        const frameState = this.requestedFrameState_;
        const len = this.layers_.length;
        const imageDatas = new Array(len);
        for(let i = 0; i < len; ++i){
            frameState.layerIndex = i;
            const imageData = getImageData(this.layers_[i], frameState);
            if (imageData) imageDatas[i] = imageData;
            else return;
        }
        const data = {};
        this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));
        this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
    }
    /**
   * Called when pixel processing is complete.
   * @param {import("../Map.js").FrameState} frameState The frame state.
   * @param {Error} err Any error during processing.
   * @param {ImageData} output The output image data.
   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).
   * @private
   */ onWorkerComplete_(frameState, err, output, data) {
        if (err || !output) return;
        // do nothing if extent or resolution changed
        const extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        if (resolution !== this.requestedFrameState_.viewState.resolution || !(0, _extentJs.equals)(extent, this.requestedFrameState_.extent)) return;
        let context;
        if (this.renderedImageCanvas_) context = this.renderedImageCanvas_.getImage().getContext("2d");
        else {
            const width = Math.round((0, _extentJs.getWidth)(extent) / resolution);
            const height = Math.round((0, _extentJs.getHeight)(extent) / resolution);
            context = (0, _domJs.createCanvasContext2D)(width, height);
            this.renderedImageCanvas_ = new (0, _imageCanvasJsDefault.default)(extent, resolution, 1, context.canvas);
        }
        context.putImageData(output, 0, 0);
        this.changed();
        this.renderedRevision_ = this.getRevision();
        this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));
        if (frameState.animate) requestAnimationFrame(this.changed.bind(this));
    }
    disposeInternal() {
        if (this.processor_) this.processor_.dispose();
        super.disposeInternal();
    }
}
/**
 * Clean up and unregister the worker.
 * @function
 * @api
 */ RasterSource.prototype.dispose;
/**
 * A reusable canvas context.
 * @type {CanvasRenderingContext2D}
 * @private
 */ let sharedContext = null;
/**
 * Get image data from a layer.
 * @param {import("../layer/Layer.js").default} layer Layer to render.
 * @param {import("../Map.js").FrameState} frameState The frame state.
 * @return {ImageData} The image data.
 */ function getImageData(layer, frameState) {
    const renderer = layer.getRenderer();
    if (!renderer) throw new Error("Unsupported layer type: " + layer);
    if (!renderer.prepareFrame(frameState)) return null;
    const width = frameState.size[0];
    const height = frameState.size[1];
    if (width === 0 || height === 0) return null;
    const container = renderer.renderFrame(frameState, null);
    let element;
    if (container instanceof HTMLCanvasElement) element = container;
    else {
        if (container) element = container.firstElementChild;
        if (!(element instanceof HTMLCanvasElement)) throw new Error("Unsupported rendered element: " + element);
        if (element.width === width && element.height === height) {
            const context = element.getContext("2d");
            return context.getImageData(0, 0, width, height);
        }
    }
    if (!sharedContext) sharedContext = (0, _domJs.createCanvasContext2D)(width, height);
    else {
        const canvas = sharedContext.canvas;
        if (canvas.width !== width || canvas.height !== height) sharedContext = (0, _domJs.createCanvasContext2D)(width, height);
        else sharedContext.clearRect(0, 0, width, height);
    }
    sharedContext.drawImage(element, 0, 0, width, height);
    return sharedContext.getImageData(0, 0, width, height);
}
/**
 * Get a list of layer states from a list of layers.
 * @param {Array<import("../layer/Layer.js").default>} layers Layers.
 * @return {Array<import("../layer/Layer.js").State>} The layer states.
 */ function getLayerStatesArray(layers) {
    return layers.map(function(layer) {
        return layer.getLayerState();
    });
}
/**
 * Create layers for all sources.
 * @param {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources The sources.
 * @return {Array<import("../layer/Layer.js").default>} Array of layers.
 */ function createLayers(sources) {
    const len = sources.length;
    const layers = new Array(len);
    for(let i = 0; i < len; ++i)layers[i] = createLayer(sources[i]);
    return layers;
}
/**
 * Create a layer for the provided source.
 * @param {import("./Source.js").default|import("../layer/Layer.js").default} layerOrSource The layer or source.
 * @return {import("../layer/Layer.js").default} The layer.
 */ function createLayer(layerOrSource) {
    // @type {import("../layer/Layer.js").default}
    let layer;
    if (layerOrSource instanceof (0, _sourceJsDefault.default)) {
        if (layerOrSource instanceof (0, _tileJsDefault1.default)) layer = new (0, _tileJsDefault.default)({
            source: layerOrSource
        });
        else if (layerOrSource instanceof (0, _imageJsDefault1.default)) layer = new (0, _imageJsDefault.default)({
            source: layerOrSource
        });
    } else layer = layerOrSource;
    return layer;
}
exports.default = RasterSource;

},{"buffer":"fCgem","../Disposable.js":"c0oTM","../events/Event.js":"hwXQP","../events/EventType.js":"hrQJ6","../ImageCanvas.js":"3Sidv","../layer/Image.js":"4sfDX","./Image.js":"eEM2E","./Source.js":"bgZ4G","../layer/Tile.js":"3ytzs","../TileQueue.js":"iKkF5","./Tile.js":"3ySVS","../dom.js":"84QzQ","../transform.js":"1BqUf","../extent.js":"6YrVc","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
var base64 = require("base64-js");
var ieee754 = require("ieee754");
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"base64-js":"eIiSV","ieee754":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"3Sidv":[function(require,module,exports) {
/**
 * @module ol/ImageCanvas
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _imageBaseJs = require("./ImageBase.js");
var _imageBaseJsDefault = parcelHelpers.interopDefault(_imageBaseJs);
var _imageStateJs = require("./ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=): void): void} Loader
 */ class ImageCanvas extends (0, _imageBaseJsDefault.default) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */ constructor(extent, resolution, pixelRatio, canvas, loader){
        const state = loader !== undefined ? (0, _imageStateJsDefault.default).IDLE : (0, _imageStateJsDefault.default).LOADED;
        super(extent, resolution, pixelRatio, state);
        /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */ this.loader_ = loader !== undefined ? loader : null;
        /**
     * @private
     * @type {HTMLCanvasElement}
     */ this.canvas_ = canvas;
        /**
     * @private
     * @type {?Error}
     */ this.error_ = null;
    }
    /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */ getError() {
        return this.error_;
    }
    /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */ handleLoad_(err) {
        if (err) {
            this.error_ = err;
            this.state = (0, _imageStateJsDefault.default).ERROR;
        } else this.state = (0, _imageStateJsDefault.default).LOADED;
        this.changed();
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _imageStateJsDefault.default).IDLE) {
            this.state = (0, _imageStateJsDefault.default).LOADING;
            this.changed();
            this.loader_(this.handleLoad_.bind(this));
        }
    }
    /**
   * @return {HTMLCanvasElement} Canvas element.
   */ getImage() {
        return this.canvas_;
    }
}
exports.default = ImageCanvas;

},{"./ImageBase.js":"2yGE2","./ImageState.js":"c4jJS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eEM2E":[function(require,module,exports) {
/**
 * @module ol/source/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ImageSourceEventType", ()=>ImageSourceEventType);
/**
 * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */ parcelHelpers.export(exports, "ImageSourceEvent", ()=>ImageSourceEvent);
/**
 * Default image load function for image sources that use import("../Image.js").Image image
 * instances.
 * @param {import("../Image.js").default} image Image.
 * @param {string} src Source.
 */ parcelHelpers.export(exports, "defaultImageLoadFunction", ()=>defaultImageLoadFunction);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("../reproj/Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _utilJs = require("../util.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _arrayJs = require("../array.js");
const ImageSourceEventType = {
    /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */ IMAGELOADSTART: "imageloadstart",
    /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */ IMAGELOADEND: "imageloadend",
    /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */ IMAGELOADERROR: "imageloaderror"
};
class ImageSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */ constructor(type, image){
        super(type);
        /**
     * The image related to the event.
     * @type {import("../Image.js").default}
     * @api
     */ this.image = image;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {Array<number>} [resolutions] Resolutions.
 * @property {import("./Source.js").State} [state] State.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 * @abstract
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */ class ImageSource extends (0, _sourceJsDefault.default) {
    /**
   * @param {Options} options Single image source options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            projection: options.projection,
            state: options.state,
            interpolate: options.interpolate !== undefined ? options.interpolate : true
        });
        /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {ImageSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;
        /**
     * @private
     * @type {import("../reproj/Image.js").default}
     */ this.reprojectedImage_ = null;
        /**
     * @private
     * @type {number}
     */ this.reprojectedRevision_ = 0;
    }
    /**
   * @return {Array<number>|null} Resolutions.
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */ findNearestResolution(resolution) {
        if (this.resolutions_) {
            const idx = (0, _arrayJs.linearFindNearest)(this.resolutions_, resolution, 0);
            resolution = this.resolutions_[idx];
        }
        return resolution;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */ getImage(extent, resolution, pixelRatio, projection) {
        const sourceProjection = this.getProjection();
        if (!sourceProjection || !projection || (0, _projJs.equivalent)(sourceProjection, projection)) {
            if (sourceProjection) projection = sourceProjection;
            return this.getImageInternal(extent, resolution, pixelRatio, projection);
        } else {
            if (this.reprojectedImage_) {
                if (this.reprojectedRevision_ == this.getRevision() && (0, _projJs.equivalent)(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && (0, _extentJs.equals)(this.reprojectedImage_.getExtent(), extent)) return this.reprojectedImage_;
                this.reprojectedImage_.dispose();
                this.reprojectedImage_ = null;
            }
            this.reprojectedImage_ = new (0, _imageJsDefault.default)(sourceProjection, projection, extent, resolution, pixelRatio, (function(extent, resolution, pixelRatio) {
                return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
            }).bind(this), this.getInterpolate());
            this.reprojectedRevision_ = this.getRevision();
            return this.reprojectedImage_;
        }
    }
    /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */ getImageInternal(extent, resolution, pixelRatio, projection) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */ handleImageChange(event) {
        const image = /** @type {import("../Image.js").default} */ event.target;
        let type;
        switch(image.getState()){
            case (0, _imageStateJsDefault.default).LOADING:
                this.loading = true;
                type = ImageSourceEventType.IMAGELOADSTART;
                break;
            case (0, _imageStateJsDefault.default).LOADED:
                this.loading = false;
                type = ImageSourceEventType.IMAGELOADEND;
                break;
            case (0, _imageStateJsDefault.default).ERROR:
                this.loading = false;
                type = ImageSourceEventType.IMAGELOADERROR;
                break;
            default:
                return;
        }
        if (this.hasListener(type)) this.dispatchEvent(new ImageSourceEvent(type, image));
    }
}
function defaultImageLoadFunction(image, src) {
    /** @type {HTMLImageElement|HTMLVideoElement} */ image.getImage().src = src;
}
exports.default = ImageSource;

},{"../events/Event.js":"hwXQP","../ImageState.js":"c4jJS","../reproj/Image.js":"aCggd","./Source.js":"bgZ4G","../util.js":"pLBjQ","../extent.js":"6YrVc","../proj.js":"SznqC","../array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aCggd":[function(require,module,exports) {
/**
 * @module ol/reproj/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _commonJs = require("./common.js");
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageBaseJs = require("../ImageBase.js");
var _imageBaseJsDefault = parcelHelpers.interopDefault(_imageBaseJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _triangulationJs = require("./Triangulation.js");
var _triangulationJsDefault = parcelHelpers.interopDefault(_triangulationJs);
var _reprojJs = require("../reproj.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../ImageBase.js").default} FunctionType
 */ /**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */ class ReprojImage extends (0, _imageBaseJsDefault.default) {
    /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */ constructor(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate){
        const maxSourceExtent = sourceProj.getExtent();
        const maxTargetExtent = targetProj.getExtent();
        const limitedTargetExtent = maxTargetExtent ? (0, _extentJs.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
        const targetCenter = (0, _extentJs.getCenter)(limitedTargetExtent);
        const sourceResolution = (0, _reprojJs.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);
        const errorThresholdInPixels = (0, _commonJs.ERROR_THRESHOLD);
        const triangulation = new (0, _triangulationJsDefault.default)(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
        const sourceExtent = triangulation.calculateSourceExtent();
        const sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
        const state = sourceImage ? (0, _imageStateJsDefault.default).IDLE : (0, _imageStateJsDefault.default).EMPTY;
        const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
        super(targetExtent, targetResolution, sourcePixelRatio, state);
        /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */ this.targetProj_ = targetProj;
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.maxSourceExtent_ = maxSourceExtent;
        /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */ this.triangulation_ = triangulation;
        /**
     * @private
     * @type {number}
     */ this.targetResolution_ = targetResolution;
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.targetExtent_ = targetExtent;
        /**
     * @private
     * @type {import("../ImageBase.js").default}
     */ this.sourceImage_ = sourceImage;
        /**
     * @private
     * @type {number}
     */ this.sourcePixelRatio_ = sourcePixelRatio;
        /**
     * @private
     * @type {boolean}
     */ this.interpolate_ = interpolate;
        /**
     * @private
     * @type {HTMLCanvasElement}
     */ this.canvas_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.sourceListenerKey_ = null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.state == (0, _imageStateJsDefault.default).LOADING) this.unlistenSource_();
        super.disposeInternal();
    }
    /**
   * @return {HTMLCanvasElement} Image.
   */ getImage() {
        return this.canvas_;
    }
    /**
   * @return {import("../proj/Projection.js").default} Projection.
   */ getProjection() {
        return this.targetProj_;
    }
    /**
   * @private
   */ reproject_() {
        const sourceState = this.sourceImage_.getState();
        if (sourceState == (0, _imageStateJsDefault.default).LOADED) {
            const width = (0, _extentJs.getWidth)(this.targetExtent_) / this.targetResolution_;
            const height = (0, _extentJs.getHeight)(this.targetExtent_) / this.targetResolution_;
            this.canvas_ = (0, _reprojJs.render)(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
                {
                    extent: this.sourceImage_.getExtent(),
                    image: this.sourceImage_.getImage()
                }
            ], 0, undefined, this.interpolate_);
        }
        this.state = sourceState;
        this.changed();
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _imageStateJsDefault.default).IDLE) {
            this.state = (0, _imageStateJsDefault.default).LOADING;
            this.changed();
            const sourceState = this.sourceImage_.getState();
            if (sourceState == (0, _imageStateJsDefault.default).LOADED || sourceState == (0, _imageStateJsDefault.default).ERROR) this.reproject_();
            else {
                this.sourceListenerKey_ = (0, _eventsJs.listen)(this.sourceImage_, (0, _eventTypeJsDefault.default).CHANGE, function(e) {
                    const sourceState = this.sourceImage_.getState();
                    if (sourceState == (0, _imageStateJsDefault.default).LOADED || sourceState == (0, _imageStateJsDefault.default).ERROR) {
                        this.unlistenSource_();
                        this.reproject_();
                    }
                }, this);
                this.sourceImage_.load();
            }
        }
    }
    /**
   * @private
   */ unlistenSource_() {
        (0, _eventsJs.unlistenByKey)(/** @type {!import("../events.js").EventsKey} */ this.sourceListenerKey_);
        this.sourceListenerKey_ = null;
    }
}
exports.default = ReprojImage;

},{"./common.js":"qh92B","../events/EventType.js":"hrQJ6","../ImageBase.js":"2yGE2","../ImageState.js":"c4jJS","./Triangulation.js":"3jZUN","../reproj.js":"jbreX","../extent.js":"6YrVc","../events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"qh92B":[function(require,module,exports) {
/**
 * @module ol/reproj/common
 */ /**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ERROR_THRESHOLD", ()=>ERROR_THRESHOLD);
const ERROR_THRESHOLD = 0.5;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3jZUN":[function(require,module,exports) {
/**
 * @module ol/reproj/Triangulation
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _mathJs = require("../math.js");
/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */ /**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */ const MAX_SUBDIVISION = 10;
/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */ const MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */ class Triangulation {
    /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */ constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution){
        /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */ this.sourceProj_ = sourceProj;
        /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */ this.targetProj_ = targetProj;
        /** @type {!Object<string, import("../coordinate.js").Coordinate>} */ let transformInvCache = {};
        const transformInv = (0, _projJs.getTransform)(this.targetProj_, this.sourceProj_);
        /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */ this.transformInv_ = function(c) {
            const key = c[0] + "/" + c[1];
            if (!transformInvCache[key]) transformInvCache[key] = transformInv(c);
            return transformInvCache[key];
        };
        /**
     * @type {import("../extent.js").Extent}
     * @private
     */ this.maxSourceExtent_ = maxSourceExtent;
        /**
     * @type {number}
     * @private
     */ this.errorThresholdSquared_ = errorThreshold * errorThreshold;
        /**
     * @type {Array<Triangle>}
     * @private
     */ this.triangles_ = [];
        /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */ this.wrapsXInSource_ = false;
        /**
     * @type {boolean}
     * @private
     */ this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0, _extentJs.getWidth)(maxSourceExtent) == (0, _extentJs.getWidth)(this.sourceProj_.getExtent());
        /**
     * @type {?number}
     * @private
     */ this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0, _extentJs.getWidth)(this.sourceProj_.getExtent()) : null;
        /**
     * @type {?number}
     * @private
     */ this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0, _extentJs.getWidth)(this.targetProj_.getExtent()) : null;
        const destinationTopLeft = (0, _extentJs.getTopLeft)(targetExtent);
        const destinationTopRight = (0, _extentJs.getTopRight)(targetExtent);
        const destinationBottomRight = (0, _extentJs.getBottomRight)(targetExtent);
        const destinationBottomLeft = (0, _extentJs.getBottomLeft)(targetExtent);
        const sourceTopLeft = this.transformInv_(destinationTopLeft);
        const sourceTopRight = this.transformInv_(destinationTopRight);
        const sourceBottomRight = this.transformInv_(destinationBottomRight);
        const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
        /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overal reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */ const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2((0, _extentJs.getArea)(targetExtent) / (destinationResolution * destinationResolution * 65536)))) : 0);
        this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
        if (this.wrapsXInSource_) {
            let leftBound = Infinity;
            this.triangles_.forEach(function(triangle, i, arr) {
                leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
            });
            // Shift triangles to be as close to `leftBound` as possible
            // (if the distance is more than `worldWidth / 2` it can be closer.
            this.triangles_.forEach((function(triangle) {
                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
                    const newTriangle = [
                        [
                            triangle.source[0][0],
                            triangle.source[0][1]
                        ],
                        [
                            triangle.source[1][0],
                            triangle.source[1][1]
                        ],
                        [
                            triangle.source[2][0],
                            triangle.source[2][1]
                        ]
                    ];
                    if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) newTriangle[0][0] -= this.sourceWorldWidth_;
                    if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) newTriangle[1][0] -= this.sourceWorldWidth_;
                    if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) newTriangle[2][0] -= this.sourceWorldWidth_;
                    // Rarely (if the extent contains both the dateline and prime meridian)
                    // the shift can in turn break some triangles.
                    // Detect this here and don't shift in such cases.
                    const minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                    const maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                    if (maxX - minX < this.sourceWorldWidth_ / 2) triangle.source = newTriangle;
                }
            }).bind(this));
        }
        transformInvCache = {};
    }
    /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */ addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
        this.triangles_.push({
            source: [
                aSrc,
                bSrc,
                cSrc
            ],
            target: [
                a,
                b,
                c
            ]
        });
    }
    /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */ addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
        const sourceQuadExtent = (0, _extentJs.boundingExtent)([
            aSrc,
            bSrc,
            cSrc,
            dSrc
        ]);
        const sourceCoverageX = this.sourceWorldWidth_ ? (0, _extentJs.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
        const sourceWorldWidth = /** @type {number} */ this.sourceWorldWidth_;
        // when the quad is wrapped in the source projection
        // it covers most of the projection extent, but not fully
        const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
        let needsSubdivision = false;
        if (maxSubdivision > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                const targetQuadExtent = (0, _extentJs.boundingExtent)([
                    a,
                    b,
                    c,
                    d
                ]);
                const targetCoverageX = (0, _extentJs.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
                needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
            }
            if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }
        if (!needsSubdivision && this.maxSourceExtent_) {
            if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
                if (!(0, _extentJs.intersects)(sourceQuadExtent, this.maxSourceExtent_)) // whole quad outside source projection extent -> ignore
                return;
            }
        }
        let isNotFinite = 0;
        if (!needsSubdivision) {
            if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
                if (maxSubdivision > 0) needsSubdivision = true;
                else {
                    // It might be the case that only 1 of the points is infinite. In this case
                    // we can draw a single triangle with the other three points
                    isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                    if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) return;
                }
            }
        }
        if (maxSubdivision > 0) {
            if (!needsSubdivision) {
                const center = [
                    (a[0] + c[0]) / 2,
                    (a[1] + c[1]) / 2
                ];
                const centerSrc = this.transformInv_(center);
                let dx;
                if (wrapsX) {
                    const centerSrcEstimX = ((0, _mathJs.modulo)(aSrc[0], sourceWorldWidth) + (0, _mathJs.modulo)(cSrc[0], sourceWorldWidth)) / 2;
                    dx = centerSrcEstimX - (0, _mathJs.modulo)(centerSrc[0], sourceWorldWidth);
                } else dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                const centerSrcErrorSquared = dx * dx + dy * dy;
                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
            }
            if (needsSubdivision) {
                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                    // split horizontally (top & bottom)
                    const bc = [
                        (b[0] + c[0]) / 2,
                        (b[1] + c[1]) / 2
                    ];
                    const bcSrc = this.transformInv_(bc);
                    const da = [
                        (d[0] + a[0]) / 2,
                        (d[1] + a[1]) / 2
                    ];
                    const daSrc = this.transformInv_(da);
                    this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                    this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                } else {
                    // split vertically (left & right)
                    const ab = [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2
                    ];
                    const abSrc = this.transformInv_(ab);
                    const cd = [
                        (c[0] + d[0]) / 2,
                        (c[1] + d[1]) / 2
                    ];
                    const cdSrc = this.transformInv_(cd);
                    this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                    this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                }
                return;
            }
        }
        if (wrapsX) {
            if (!this.canWrapXInSource_) return;
            this.wrapsXInSource_ = true;
        }
        // Exactly zero or one of *Src is not finite
        // The triangles must have the diagonal line as the first side
        // This is to allow easy code in reproj.s to make it straight for broken
        // browsers that can't handle diagonal clipping
        if ((isNotFinite & 0xb) == 0) this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
        if ((isNotFinite & 0xe) == 0) this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
        if (isNotFinite) {
            // Try the other two triangles
            if ((isNotFinite & 0xd) == 0) this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
            if ((isNotFinite & 0x7) == 0) this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
        }
    }
    /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */ calculateSourceExtent() {
        const extent = (0, _extentJs.createEmpty)();
        this.triangles_.forEach(function(triangle, i, arr) {
            const src = triangle.source;
            (0, _extentJs.extendCoordinate)(extent, src[0]);
            (0, _extentJs.extendCoordinate)(extent, src[1]);
            (0, _extentJs.extendCoordinate)(extent, src[2]);
        });
        return extent;
    }
    /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */ getTriangles() {
        return this.triangles_;
    }
}
exports.default = Triangulation;

},{"../extent.js":"6YrVc","../proj.js":"SznqC","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jbreX":[function(require,module,exports) {
/**
 * @module ol/reproj
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canvasPool", ()=>canvasPool);
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */ parcelHelpers.export(exports, "calculateSourceResolution", ()=>calculateSourceResolution);
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */ parcelHelpers.export(exports, "calculateSourceExtentResolution", ()=>calculateSourceExtentResolution);
/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 */ /**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */ parcelHelpers.export(exports, "render", ()=>render);
var _extentJs = require("./extent.js");
var _domJs = require("./dom.js");
var _projJs = require("./proj.js");
var _mathJs = require("./math.js");
let brokenDiagonalRendering_;
const canvasPool = [];
/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */ function drawTestTriangle(ctx, u1, v1, u2, v2) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(u1, v1);
    ctx.lineTo(u2, v2);
    ctx.closePath();
    ctx.save();
    ctx.clip();
    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
    ctx.restore();
}
/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */ function verifyBrokenDiagonalRendering(data, offset) {
    // the values ought to be close to the rgba(210, 0, 0, 0.75)
    return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 191.25) > 2;
}
/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */ function isBrokenDiagonalRendering() {
    if (brokenDiagonalRendering_ === undefined) {
        const ctx = document.createElement("canvas").getContext("2d");
        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
        drawTestTriangle(ctx, 4, 5, 4, 0);
        drawTestTriangle(ctx, 4, 5, 0, 5);
        const data = ctx.getImageData(0, 0, 3, 3).data;
        brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    }
    return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
    const sourceCenter = (0, _projJs.transform)(targetCenter, targetProj, sourceProj);
    // calculate the ideal resolution of the source data
    let sourceResolution = (0, _projJs.getPointResolution)(targetProj, targetResolution, targetCenter);
    const targetMetersPerUnit = targetProj.getMetersPerUnit();
    if (targetMetersPerUnit !== undefined) sourceResolution *= targetMetersPerUnit;
    const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
    if (sourceMetersPerUnit !== undefined) sourceResolution /= sourceMetersPerUnit;
    // Based on the projection properties, the point resolution at the specified
    // coordinates may be slightly different. We need to reverse-compensate this
    // in order to achieve optimal results.
    const sourceExtent = sourceProj.getExtent();
    if (!sourceExtent || (0, _extentJs.containsCoordinate)(sourceExtent, sourceCenter)) {
        const compensationFactor = (0, _projJs.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
        if (isFinite(compensationFactor) && compensationFactor > 0) sourceResolution /= compensationFactor;
    }
    return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
    const targetCenter = (0, _extentJs.getCenter)(targetExtent);
    let sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) (0, _extentJs.forEachCorner)(targetExtent, function(corner) {
        sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
        return isFinite(sourceResolution) && sourceResolution > 0;
    });
    return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate) {
    const context = (0, _domJs.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);
    if (!interpolate) context.imageSmoothingEnabled = false;
    if (sources.length === 0) return context.canvas;
    context.scale(pixelRatio, pixelRatio);
    function pixelRound(value) {
        return Math.round(value * pixelRatio) / pixelRatio;
    }
    context.globalCompositeOperation = "lighter";
    const sourceDataExtent = (0, _extentJs.createEmpty)();
    sources.forEach(function(src, i, arr) {
        (0, _extentJs.extend)(sourceDataExtent, src.extent);
    });
    const canvasWidthInUnits = (0, _extentJs.getWidth)(sourceDataExtent);
    const canvasHeightInUnits = (0, _extentJs.getHeight)(sourceDataExtent);
    const stitchContext = (0, _domJs.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
    if (!interpolate) stitchContext.imageSmoothingEnabled = false;
    const stitchScale = pixelRatio / sourceResolution;
    sources.forEach(function(src, i, arr) {
        const xPos = src.extent[0] - sourceDataExtent[0];
        const yPos = -(src.extent[3] - sourceDataExtent[3]);
        const srcWidth = (0, _extentJs.getWidth)(src.extent);
        const srcHeight = (0, _extentJs.getHeight)(src.extent);
        // This test should never fail -- but it does. Need to find a fix the upstream condition
        if (src.image.width > 0 && src.image.height > 0) stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    });
    const targetTopLeft = (0, _extentJs.getTopLeft)(targetExtent);
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
        /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */ const source = triangle.source;
        const target = triangle.target;
        let x0 = source[0][0], y0 = source[0][1];
        let x1 = source[1][0], y1 = source[1][1];
        let x2 = source[2][0], y2 = source[2][1];
        // Make sure that everything is on pixel boundaries
        const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
        const v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
        const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
        const v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
        const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
        const v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
        // Shift all the source points to improve numerical stability
        // of all the subsequent calculations. The [x0, y0] is used here.
        // This is also used to simplify the linear system.
        const sourceNumericalShiftX = x0;
        const sourceNumericalShiftY = y0;
        x0 = 0;
        y0 = 0;
        x1 -= sourceNumericalShiftX;
        y1 -= sourceNumericalShiftY;
        x2 -= sourceNumericalShiftX;
        y2 -= sourceNumericalShiftY;
        const augmentedMatrix = [
            [
                x1,
                y1,
                0,
                0,
                u1 - u0
            ],
            [
                x2,
                y2,
                0,
                0,
                u2 - u0
            ],
            [
                0,
                0,
                x1,
                y1,
                v1 - v0
            ],
            [
                0,
                0,
                x2,
                y2,
                v2 - v0
            ]
        ];
        const affineCoefs = (0, _mathJs.solveLinearSystem)(augmentedMatrix);
        if (!affineCoefs) return;
        context.save();
        context.beginPath();
        if (isBrokenDiagonalRendering() || !interpolate) {
            // Make sure that all lines are horizontal or vertical
            context.moveTo(u1, v1);
            // This is the diagonal line. Do it in 4 steps
            const steps = 4;
            const ud = u0 - u1;
            const vd = v0 - v1;
            for(let step = 0; step < steps; step++){
                // Go horizontally
                context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
                // Go vertically
                if (step != steps - 1) context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
            }
            // We are almost at u0r, v0r
            context.lineTo(u2, v2);
        } else {
            context.moveTo(u1, v1);
            context.lineTo(u0, v0);
            context.lineTo(u2, v2);
        }
        context.clip();
        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
        context.drawImage(stitchContext.canvas, 0, 0);
        context.restore();
    });
    if (renderEdges) {
        context.save();
        context.globalCompositeOperation = "source-over";
        context.strokeStyle = "black";
        context.lineWidth = 1;
        triangulation.getTriangles().forEach(function(triangle, i, arr) {
            const target = triangle.target;
            const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
            const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
            const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
            const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
            const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
            const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
            context.beginPath();
            context.moveTo(u1, v1);
            context.lineTo(u0, v0);
            context.lineTo(u2, v2);
            context.closePath();
            context.stroke();
        });
        context.restore();
    }
    return context.canvas;
}

},{"./extent.js":"6YrVc","./dom.js":"84QzQ","./proj.js":"SznqC","./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bgZ4G":[function(require,module,exports) {
/**
 * @module ol/source/Source
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _utilJs = require("../util.js");
var _projJs = require("../proj.js");
/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */ /**
 * A function that takes a {@link module:ol/Map~FrameState} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../Map.js").FrameState): (string|Array<string>)} Attribution
 */ /**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */ /**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */ class Source extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Source options.
   */ constructor(options){
        super();
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */ this.projection = (0, _projJs.get)(options.projection);
        /**
     * @private
     * @type {?Attribution}
     */ this.attributions_ = adaptAttributions(options.attributions);
        /**
     * @private
     * @type {boolean}
     */ this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
        /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */ this.loading = false;
        /**
     * @private
     * @type {import("./Source.js").State}
     */ this.state_ = options.state !== undefined ? options.state : "ready";
        /**
     * @private
     * @type {boolean}
     */ this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
        /**
     * @private
     * @type {boolean}
     */ this.interpolate_ = !!options.interpolate;
        /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */ this.viewResolver = null;
        /**
     * @protected
     * @type {function(Error):void}
     */ this.viewRejector = null;
        const self = this;
        /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */ this.viewPromise_ = new Promise(function(resolve, reject) {
            self.viewResolver = resolve;
            self.viewRejector = reject;
        });
    }
    /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */ getAttributions() {
        return this.attributions_;
    }
    /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */ getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
    }
    /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */ getProjection() {
        return this.projection;
    }
    /**
   * @abstract
   * @return {Array<number>|null} Resolutions.
   */ getResolutions() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */ getView() {
        return this.viewPromise_;
    }
    /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */ getState() {
        return this.state_;
    }
    /**
   * @return {boolean|undefined} Wrap X.
   */ getWrapX() {
        return this.wrapX_;
    }
    /**
   * @return {boolean} Use linear interpolation when resampling.
   */ getInterpolate() {
        return this.interpolate_;
    }
    /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */ refresh() {
        this.changed();
    }
    /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */ setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
    }
    /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */ setState(state) {
        this.state_ = state;
        this.changed();
    }
}
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */ function adaptAttributions(attributionLike) {
    if (!attributionLike) return null;
    if (Array.isArray(attributionLike)) return function(frameState) {
        return attributionLike;
    };
    if (typeof attributionLike === "function") return attributionLike;
    return function(frameState) {
        return [
            attributionLike
        ];
    };
}
exports.default = Source;

},{"../Object.js":"1zG8z","../util.js":"pLBjQ","../proj.js":"SznqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ytzs":[function(require,module,exports) {
/**
 * @module ol/layer/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTileJs = require("./BaseTile.js");
var _baseTileJsDefault = parcelHelpers.interopDefault(_baseTileJs);
var _tileLayerJs = require("../renderer/canvas/TileLayer.js");
var _tileLayerJsDefault = parcelHelpers.interopDefault(_tileLayerJs);
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */ class TileLayer extends (0, _baseTileJsDefault.default) {
    /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */ constructor(options){
        super(options);
    }
    createRenderer() {
        return new (0, _tileLayerJsDefault.default)(this);
    }
}
exports.default = TileLayer;

},{"./BaseTile.js":"g7Zx9","../renderer/canvas/TileLayer.js":"6bgv8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g7Zx9":[function(require,module,exports) {
/**
 * @module ol/layer/BaseTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _tilePropertyJs = require("./TileProperty.js");
var _tilePropertyJsDefault = parcelHelpers.interopDefault(_tilePropertyJs);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */ /**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */ class BaseTileLayer extends (0, _layerJsDefault.default) {
    /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */ constructor(options){
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        super(baseOptions);
        /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {BaseTileLayerOnSignature<void>}
     */ this.un;
        this.setPreload(options.preload !== undefined ? options.preload : 0);
        this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
    }
    /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */ getPreload() {
        return /** @type {number} */ this.get((0, _tilePropertyJsDefault.default).PRELOAD);
    }
    /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */ setPreload(preload) {
        this.set((0, _tilePropertyJsDefault.default).PRELOAD, preload);
    }
    /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */ getUseInterimTilesOnError() {
        return /** @type {boolean} */ this.get((0, _tilePropertyJsDefault.default).USE_INTERIM_TILES_ON_ERROR);
    }
    /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */ setUseInterimTilesOnError(useInterimTilesOnError) {
        this.set((0, _tilePropertyJsDefault.default).USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    }
    /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */ getData(pixel) {
        return super.getData(pixel);
    }
}
exports.default = BaseTileLayer;

},{"./Layer.js":"8J9Kf","./TileProperty.js":"cIL12","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIL12":[function(require,module,exports) {
/**
 * @module ol/layer/TileProperty
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    PRELOAD: "preload",
    USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6bgv8":[function(require,module,exports) {
/**
 * @module ol/renderer/canvas/TileLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _imageTileJs = require("../../ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _tileJs = require("../../reproj/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileRangeJs = require("../../TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _tileStateJs = require("../../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _projJs = require("../../proj.js");
var _utilJs = require("../../util.js");
var _arrayJs = require("../../array.js");
var _sizeJs = require("../../size.js");
/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */ class CanvasTileLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {LayerType} tileLayer Tile layer.
   */ constructor(tileLayer){
        super(tileLayer);
        /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */ this.extentChanged = true;
        /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */ this.renderedExtent_ = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedPixelRatio;
        /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */ this.renderedProjection = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedRevision;
        /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */ this.renderedTiles = [];
        /**
     * @private
     * @type {boolean}
     */ this.newTiles_ = false;
        /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */ this.tmpExtent = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {import("../../TileRange.js").default}
     */ this.tmpTileRange_ = new (0, _tileRangeJsDefault.default)(0, 0, 0, 0);
    }
    /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */ isDrawableTile(tile) {
        const tileLayer = this.getLayer();
        const tileState = tile.getState();
        const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
        return tileState == (0, _tileStateJsDefault.default).LOADED || tileState == (0, _tileStateJsDefault.default).EMPTY || tileState == (0, _tileStateJsDefault.default).ERROR && !useInterimTilesOnError;
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */ getTile(z, x, y, frameState) {
        const pixelRatio = frameState.pixelRatio;
        const projection = frameState.viewState.projection;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        let tile = tileSource.getTile(z, x, y, pixelRatio, projection);
        if (tile.getState() == (0, _tileStateJsDefault.default).ERROR) {
            if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) // Preloaded tiles for lower resolutions might have finished loading.
            this.newTiles_ = true;
        }
        if (!this.isDrawableTile(tile)) tile = tile.getInterimTile();
        return tile;
    }
    /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */ getData(pixel) {
        const frameState = this.frameState;
        if (!frameState) return null;
        const layer = this.getLayer();
        const coordinate = (0, _transformJs.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
        const layerExtent = layer.getExtent();
        if (layerExtent) {
            if (!(0, _extentJs.containsCoordinate)(layerExtent, coordinate)) return null;
        }
        const pixelRatio = frameState.pixelRatio;
        const projection = frameState.viewState.projection;
        const viewState = frameState.viewState;
        const source = layer.getRenderSource();
        const tileGrid = source.getTileGridForProjection(viewState.projection);
        const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
        for(let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z){
            const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
            const tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);
            if (!(tile instanceof (0, _imageTileJsDefault.default) || tile instanceof (0, _tileJsDefault.default)) || tile instanceof (0, _tileJsDefault.default) && tile.getState() === (0, _tileStateJsDefault.default).EMPTY) return null;
            if (tile.getState() !== (0, _tileStateJsDefault.default).LOADED) continue;
            const tileOrigin = tileGrid.getOrigin(z);
            const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(z));
            const tileResolution = tileGrid.getResolution(z);
            const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
            const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
            const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));
            return this.getImageData(tile.getImage(), col + gutter, row + gutter);
        }
        return null;
    }
    /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */ loadedTileCallback(tiles, zoom, tile) {
        if (this.isDrawableTile(tile)) return super.loadedTileCallback(tiles, zoom, tile);
        return false;
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        return !!this.getLayer().getSource();
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */ renderFrame(frameState, target) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const viewResolution = viewState.resolution;
        const viewCenter = viewState.center;
        const rotation = viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        const sourceRevision = tileSource.getRevision();
        const tileGrid = tileSource.getTileGridForProjection(projection);
        const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
        const tileResolution = tileGrid.getResolution(z);
        let extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
        // desired dimensions of the canvas in pixels
        const width = Math.round((0, _extentJs.getWidth)(extent) / resolution * pixelRatio);
        const height = Math.round((0, _extentJs.getHeight)(extent) / resolution * pixelRatio);
        const layerExtent = layerState.extent && (0, _projJs.fromUserExtent)(layerState.extent, projection);
        if (layerExtent) extent = (0, _extentJs.getIntersection)(extent, (0, _projJs.fromUserExtent)(layerState.extent, projection));
        const dx = tileResolution * width / 2 / tilePixelRatio;
        const dy = tileResolution * height / 2 / tilePixelRatio;
        const canvasExtent = [
            viewCenter[0] - dx,
            viewCenter[1] - dy,
            viewCenter[0] + dx,
            viewCenter[1] + dy
        ];
        const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
        /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */ const tilesToDrawByZ = {};
        tilesToDrawByZ[z] = {};
        const findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
        const tmpExtent = this.tmpExtent;
        const tmpTileRange = this.tmpTileRange_;
        this.newTiles_ = false;
        const viewport = rotation ? (0, _extentJs.getRotatedViewport)(viewState.center, resolution, rotation, frameState.size) : undefined;
        for(let x = tileRange.minX; x <= tileRange.maxX; ++x)for(let y = tileRange.minY; y <= tileRange.maxY; ++y){
            if (rotation && !tileGrid.tileCoordIntersectsViewport([
                z,
                x,
                y
            ], viewport)) continue;
            const tile = this.getTile(z, x, y, frameState);
            if (this.isDrawableTile(tile)) {
                const uid = (0, _utilJs.getUid)(this);
                if (tile.getState() == (0, _tileStateJsDefault.default).LOADED) {
                    tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                    let inTransition = tile.inTransition(uid);
                    if (inTransition && layerState.opacity !== 1) {
                        // Skipping transition when layer is not fully opaque avoids visual artifacts.
                        tile.endTransition(uid);
                        inTransition = false;
                    }
                    if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) this.newTiles_ = true;
                }
                if (tile.getAlpha(uid, frameState.time) === 1) continue;
            }
            const childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
            let covered = false;
            if (childTileRange) covered = findLoadedTiles(z + 1, childTileRange);
            if (!covered) tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
        }
        const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
        // set forward and inverse pixel transforms
        (0, _transformJs.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
        const canvasTransform = (0, _transformJs.toString)(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        (0, _transformJs.makeInverse)(this.inversePixelTransform, this.pixelTransform);
        // set scale transform for calculating tile positions on the canvas
        (0, _transformJs.compose)(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
        } else if (!this.containerReused) context.clearRect(0, 0, width, height);
        if (layerExtent) this.clipUnrotated(context, frameState, layerExtent);
        if (!tileSource.getInterpolate()) context.imageSmoothingEnabled = false;
        this.preRender(context, frameState);
        this.renderedTiles.length = 0;
        /** @type {Array<number>} */ let zs = Object.keys(tilesToDrawByZ).map(Number);
        zs.sort((0, _arrayJs.numberSafeCompareFunction));
        let clips, clipZs, currentClip;
        if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) zs = zs.reverse();
        else {
            clips = [];
            clipZs = [];
        }
        for(let i = zs.length - 1; i >= 0; --i){
            const currentZ = zs[i];
            const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
            const currentResolution = tileGrid.getResolution(currentZ);
            const currentScale = currentResolution / tileResolution;
            const dx1 = currentTilePixelSize[0] * currentScale * canvasScale;
            const dy1 = currentTilePixelSize[1] * currentScale * canvasScale;
            const originTileCoord = tileGrid.getTileCoordForCoordAndZ((0, _extentJs.getTopLeft)(canvasExtent), currentZ);
            const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
            const origin = (0, _transformJs.apply)(this.tempTransform, [
                tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
                tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
            ]);
            const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
            const tilesToDraw = tilesToDrawByZ[currentZ];
            for(const tileCoordKey in tilesToDraw){
                const tile1 = /** @type {import("../../ImageTile.js").default} */ tilesToDraw[tileCoordKey];
                const tileCoord = tile1.tileCoord;
                // Calculate integer positions and sizes so that tiles align
                const xIndex = originTileCoord[1] - tileCoord[1];
                const nextX = Math.round(origin[0] - (xIndex - 1) * dx1);
                const yIndex = originTileCoord[2] - tileCoord[2];
                const nextY = Math.round(origin[1] - (yIndex - 1) * dy1);
                const x1 = Math.round(origin[0] - xIndex * dx1);
                const y1 = Math.round(origin[1] - yIndex * dy1);
                const w = nextX - x1;
                const h = nextY - y1;
                const transition = z === currentZ;
                const inTransition1 = transition && tile1.getAlpha((0, _utilJs.getUid)(this), frameState.time) !== 1;
                let contextSaved = false;
                if (!inTransition1) {
                    if (clips) {
                        // Clip mask for regions in this tile that already filled by a higher z tile
                        currentClip = [
                            x1,
                            y1,
                            x1 + w,
                            y1,
                            x1 + w,
                            y1 + h,
                            x1,
                            y1 + h
                        ];
                        for(let i1 = 0, ii = clips.length; i1 < ii; ++i1)if (z !== currentZ && currentZ < clipZs[i1]) {
                            const clip = clips[i1];
                            if ((0, _extentJs.intersects)([
                                x1,
                                y1,
                                x1 + w,
                                y1 + h
                            ], [
                                clip[0],
                                clip[3],
                                clip[4],
                                clip[7]
                            ])) {
                                if (!contextSaved) {
                                    context.save();
                                    contextSaved = true;
                                }
                                context.beginPath();
                                // counter-clockwise (outer ring) for current tile
                                context.moveTo(currentClip[0], currentClip[1]);
                                context.lineTo(currentClip[2], currentClip[3]);
                                context.lineTo(currentClip[4], currentClip[5]);
                                context.lineTo(currentClip[6], currentClip[7]);
                                // clockwise (inner ring) for higher z tile
                                context.moveTo(clip[6], clip[7]);
                                context.lineTo(clip[4], clip[5]);
                                context.lineTo(clip[2], clip[3]);
                                context.lineTo(clip[0], clip[1]);
                                context.clip();
                            }
                        }
                        clips.push(currentClip);
                        clipZs.push(currentZ);
                    } else context.clearRect(x1, y1, w, h);
                }
                this.drawTileImage(tile1, frameState, x1, y1, w, h, tileGutter, transition);
                if (clips && !inTransition1) {
                    if (contextSaved) context.restore();
                    this.renderedTiles.unshift(tile1);
                } else this.renderedTiles.push(tile1);
                this.updateUsedTiles(frameState.usedTiles, tileSource, tile1);
            }
        }
        this.renderedRevision = sourceRevision;
        this.renderedResolution = tileResolution;
        this.extentChanged = !this.renderedExtent_ || !(0, _extentJs.equals)(this.renderedExtent_, canvasExtent);
        this.renderedExtent_ = canvasExtent;
        this.renderedPixelRatio = pixelRatio;
        this.renderedProjection = projection;
        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
        this.scheduleExpireCache(frameState, tileSource);
        this.postRender(context, frameState);
        if (layerState.extent) context.restore();
        context.imageSmoothingEnabled = true;
        if (canvasTransform !== canvas.style.transform) canvas.style.transform = canvasTransform;
        return this.container;
    }
    /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */ drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
        const image = this.getTileImage(tile);
        if (!image) return;
        const uid = (0, _utilJs.getUid)(this);
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
        const alphaChanged = alpha !== this.context.globalAlpha;
        if (alphaChanged) {
            this.context.save();
            this.context.globalAlpha = alpha;
        }
        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
        if (alphaChanged) this.context.restore();
        if (alpha !== layerState.opacity) frameState.animate = true;
        else if (transition) tile.endTransition(uid);
    }
    /**
   * @return {HTMLCanvasElement} Image
   */ getImage() {
        const context = this.context;
        return context ? context.canvas : null;
    }
    /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */ getTileImage(tile) {
        return tile.getImage();
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */ scheduleExpireCache(frameState, tileSource) {
        if (tileSource.canExpireCache()) {
            /**
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../Map.js").default} map Map.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */ const postRenderFunction = (function(tileSource, map, frameState) {
                const tileSourceKey = (0, _utilJs.getUid)(tileSource);
                if (tileSourceKey in frameState.usedTiles) tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
            }).bind(null, tileSource);
            frameState.postRenderFunctions.push(/** @type {import("../../Map.js").PostRenderFunction} */ postRenderFunction);
        }
    }
    /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */ updateUsedTiles(usedTiles, tileSource, tile) {
        // FIXME should we use tilesToDrawByZ instead?
        const tileSourceKey = (0, _utilJs.getUid)(tileSource);
        if (!(tileSourceKey in usedTiles)) usedTiles[tileSourceKey] = {};
        usedTiles[tileSourceKey][tile.getKey()] = true;
    }
    /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */ manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
        const tileSourceKey = (0, _utilJs.getUid)(tileSource);
        if (!(tileSourceKey in frameState.wantedTiles)) frameState.wantedTiles[tileSourceKey] = {};
        const wantedTiles = frameState.wantedTiles[tileSourceKey];
        const tileQueue = frameState.tileQueue;
        const minZoom = tileGrid.getMinZoom();
        const rotation = frameState.viewState.rotation;
        const viewport = rotation ? (0, _extentJs.getRotatedViewport)(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;
        let tileCount = 0;
        let tile, tileRange, tileResolution, x, y, z;
        for(z = minZoom; z <= currentZ; ++z){
            tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
            tileResolution = tileGrid.getResolution(z);
            for(x = tileRange.minX; x <= tileRange.maxX; ++x)for(y = tileRange.minY; y <= tileRange.maxY; ++y){
                if (rotation && !tileGrid.tileCoordIntersectsViewport([
                    z,
                    x,
                    y
                ], viewport)) continue;
                if (currentZ - z <= preload) {
                    ++tileCount;
                    tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                    if (tile.getState() == (0, _tileStateJsDefault.default).IDLE) {
                        wantedTiles[tile.getKey()] = true;
                        if (!tileQueue.isKeyQueued(tile.getKey())) tileQueue.enqueue([
                            tile,
                            tileSourceKey,
                            tileGrid.getTileCoordCenter(tile.tileCoord),
                            tileResolution
                        ]);
                    }
                    if (tileCallback !== undefined) tileCallback(tile);
                } else tileSource.useTile(z, x, y, projection);
            }
        }
        tileSource.updateCacheSize(tileCount, projection);
    }
}
exports.default = CanvasTileLayerRenderer;

},{"./Layer.js":"fY3ny","../../ImageTile.js":"bGt2E","../../reproj/Tile.js":"lR1TX","../../TileRange.js":"3pvAn","../../TileState.js":"2fodI","../../transform.js":"1BqUf","../../extent.js":"6YrVc","../../proj.js":"SznqC","../../util.js":"pLBjQ","../../array.js":"1Fbic","../../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGt2E":[function(require,module,exports) {
/**
 * @module ol/ImageTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _domJs = require("./dom.js");
var _imageJs = require("./Image.js");
class ImageTile extends (0, _tileJsDefault.default) {
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */ constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options){
        super(tileCoord, state, options);
        /**
     * @private
     * @type {?string}
     */ this.crossOrigin_ = crossOrigin;
        /**
     * Image URI
     *
     * @private
     * @type {string}
     */ this.src_ = src;
        this.key = src;
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */ this.image_ = new Image();
        if (crossOrigin !== null) this.image_.crossOrigin = crossOrigin;
        /**
     * @private
     * @type {?function():void}
     */ this.unlisten_ = null;
        /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */ this.tileLoadFunction_ = tileLoadFunction;
    }
    /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */ getImage() {
        return this.image_;
    }
    /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */ setImage(element) {
        this.image_ = element;
        this.state = (0, _tileStateJsDefault.default).LOADED;
        this.unlistenImage_();
        this.changed();
    }
    /**
   * Tracks loading or read errors.
   *
   * @private
   */ handleImageError_() {
        this.state = (0, _tileStateJsDefault.default).ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
    }
    /**
   * Tracks successful image load.
   *
   * @private
   */ handleImageLoad_() {
        const image = /** @type {HTMLImageElement} */ this.image_;
        if (image.naturalWidth && image.naturalHeight) this.state = (0, _tileStateJsDefault.default).LOADED;
        else this.state = (0, _tileStateJsDefault.default).EMPTY;
        this.unlistenImage_();
        this.changed();
    }
    /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */ load() {
        if (this.state == (0, _tileStateJsDefault.default).ERROR) {
            this.state = (0, _tileStateJsDefault.default).IDLE;
            this.image_ = new Image();
            if (this.crossOrigin_ !== null) this.image_.crossOrigin = this.crossOrigin_;
        }
        if (this.state == (0, _tileStateJsDefault.default).IDLE) {
            this.state = (0, _tileStateJsDefault.default).LOADING;
            this.changed();
            this.tileLoadFunction_(this, this.src_);
            this.unlisten_ = (0, _imageJs.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    }
    /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */ unlistenImage_() {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    }
}
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */ function getBlankImage() {
    const ctx = (0, _domJs.createCanvasContext2D)(1, 1);
    ctx.fillStyle = "rgba(0,0,0,0)";
    ctx.fillRect(0, 0, 1, 1);
    return ctx.canvas;
}
exports.default = ImageTile;

},{"./Tile.js":"4sqb5","./TileState.js":"2fodI","./dom.js":"84QzQ","./Image.js":"c0Egp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4sqb5":[function(require,module,exports) {
/**
 * @module ol/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _utilJs = require("./util.js");
var _easingJs = require("./easing.js");
/**
 * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */ /**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */ /**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */ /**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */ class Tile extends (0, _targetJsDefault.default) {
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */ constructor(tileCoord, state, options){
        super();
        options = options ? options : {};
        /**
     * @type {import("./tilecoord.js").TileCoord}
     */ this.tileCoord = tileCoord;
        /**
     * @protected
     * @type {import("./TileState.js").default}
     */ this.state = state;
        /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */ this.interimTile = null;
        /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */ this.key = "";
        /**
     * The duration for the opacity transition.
     * @type {number}
     */ this.transition_ = options.transition === undefined ? 250 : options.transition;
        /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */ this.transitionStarts_ = {};
        /**
     * @type {boolean}
     */ this.interpolate = !!options.interpolate;
    }
    /**
   * @protected
   */ changed() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */ release() {
        if (this.state === (0, _tileStateJsDefault.default).ERROR) // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
        this.setState((0, _tileStateJsDefault.default).EMPTY);
    }
    /**
   * @return {string} Key.
   */ getKey() {
        return this.key + "/" + this.tileCoord;
    }
    /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */ getInterimTile() {
        if (!this.interimTile) //empty chain
        return this;
        let tile = this.interimTile;
        // find the first loaded tile and return it. Since the chain is sorted in
        // decreasing order of creation time, there is no need to search the remainder
        // of the list (all those tiles correspond to older requests and will be
        // cleaned up by refreshInterimChain)
        do {
            if (tile.getState() == (0, _tileStateJsDefault.default).LOADED) {
                // Show tile immediately instead of fading it in after loading, because
                // the interim tile is in place already
                this.transition_ = 0;
                return tile;
            }
            tile = tile.interimTile;
        }while (tile);
        // we can not find a better tile
        return this;
    }
    /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */ refreshInterimChain() {
        if (!this.interimTile) return;
        let tile = this.interimTile;
        /**
     * @type {Tile}
     */ let prev = this;
        do {
            if (tile.getState() == (0, _tileStateJsDefault.default).LOADED) {
                //we have a loaded tile, we can discard the rest of the list
                //we would could abort any LOADING tile request
                //older than this tile (i.e. any LOADING tile following this entry in the chain)
                tile.interimTile = null;
                break;
            } else if (tile.getState() == (0, _tileStateJsDefault.default).LOADING) //keep this LOADING tile any loaded tiles later in the chain are
            //older than this tile, so we're still interested in the request
            prev = tile;
            else if (tile.getState() == (0, _tileStateJsDefault.default).IDLE) //the head of the list is the most current tile, we don't need
            //to start any other requests for this chain
            prev.interimTile = tile.interimTile;
            else prev = tile;
            tile = prev.interimTile;
        }while (tile);
    }
    /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */ getTileCoord() {
        return this.tileCoord;
    }
    /**
   * @return {import("./TileState.js").default} State.
   */ getState() {
        return this.state;
    }
    /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */ setState(state) {
        if (this.state !== (0, _tileStateJsDefault.default).ERROR && this.state > state) throw new Error("Tile load sequence violation");
        this.state = state;
        this.changed();
    }
    /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */ load() {
        (0, _utilJs.abstract)();
    }
    /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */ getAlpha(id, time) {
        if (!this.transition_) return 1;
        let start = this.transitionStarts_[id];
        if (!start) {
            start = time;
            this.transitionStarts_[id] = start;
        } else if (start === -1) return 1;
        const delta = time - start + 1000 / 60; // avoid rendering at 0
        if (delta >= this.transition_) return 1;
        return (0, _easingJs.easeIn)(delta / this.transition_);
    }
    /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */ inTransition(id) {
        if (!this.transition_) return false;
        return this.transitionStarts_[id] !== -1;
    }
    /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */ endTransition(id) {
        if (this.transition_) this.transitionStarts_[id] = -1;
    }
}
exports.default = Tile;

},{"./events/Target.js":"7T5Yi","./events/EventType.js":"hrQJ6","./TileState.js":"2fodI","./util.js":"pLBjQ","./easing.js":"fYITA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lR1TX":[function(require,module,exports) {
/**
 * @module ol/reproj/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _commonJs = require("./common.js");
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _tileJs = require("../Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _triangulationJs = require("./Triangulation.js");
var _triangulationJsDefault = parcelHelpers.interopDefault(_triangulationJs);
var _reprojJs = require("../reproj.js");
var _mathJs = require("../math.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */ /**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */ class ReprojTile extends (0, _tileJsDefault.default) {
    /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */ constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, interpolate){
        super(tileCoord, (0, _tileStateJsDefault.default).IDLE, {
            interpolate: !!interpolate
        });
        /**
     * @private
     * @type {boolean}
     */ this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.gutter_ = gutter;
        /**
     * @private
     * @type {HTMLCanvasElement}
     */ this.canvas_ = null;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.sourceTileGrid_ = sourceTileGrid;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.targetTileGrid_ = targetTileGrid;
        /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */ this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
        /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */ this.sourceTiles_ = [];
        /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */ this.sourcesListenerKeys_ = null;
        /**
     * @private
     * @type {number}
     */ this.sourceZ_ = 0;
        const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
        const maxTargetExtent = this.targetTileGrid_.getExtent();
        let maxSourceExtent = this.sourceTileGrid_.getExtent();
        const limitedTargetExtent = maxTargetExtent ? (0, _extentJs.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
        if ((0, _extentJs.getArea)(limitedTargetExtent) === 0) {
            // Tile is completely outside range -> EMPTY
            // TODO: is it actually correct that the source even creates the tile ?
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        const sourceProjExtent = sourceProj.getExtent();
        if (sourceProjExtent) {
            if (!maxSourceExtent) maxSourceExtent = sourceProjExtent;
            else maxSourceExtent = (0, _extentJs.getIntersection)(maxSourceExtent, sourceProjExtent);
        }
        const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);
        const sourceResolution = (0, _reprojJs.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);
        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
            // invalid sourceResolution -> EMPTY
            // probably edges of the projections when no extent is defined
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        const errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : (0, _commonJs.ERROR_THRESHOLD);
        /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */ this.triangulation_ = new (0, _triangulationJsDefault.default)(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
        if (this.triangulation_.getTriangles().length === 0) {
            // no valid triangles -> EMPTY
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
        let sourceExtent = this.triangulation_.calculateSourceExtent();
        if (maxSourceExtent) {
            if (sourceProj.canWrapX()) {
                sourceExtent[1] = (0, _mathJs.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                sourceExtent[3] = (0, _mathJs.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
            } else sourceExtent = (0, _extentJs.getIntersection)(sourceExtent, maxSourceExtent);
        }
        if (!(0, _extentJs.getArea)(sourceExtent)) this.state = (0, _tileStateJsDefault.default).EMPTY;
        else {
            const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);
            for(let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++)for(let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++){
                const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
                if (tile) this.sourceTiles_.push(tile);
            }
            if (this.sourceTiles_.length === 0) this.state = (0, _tileStateJsDefault.default).EMPTY;
        }
    }
    /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */ getImage() {
        return this.canvas_;
    }
    /**
   * @private
   */ reproject_() {
        const sources = [];
        this.sourceTiles_.forEach((function(tile, i, arr) {
            if (tile && tile.getState() == (0, _tileStateJsDefault.default).LOADED) sources.push({
                extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                image: tile.getImage()
            });
        }).bind(this));
        this.sourceTiles_.length = 0;
        if (sources.length === 0) this.state = (0, _tileStateJsDefault.default).ERROR;
        else {
            const z = this.wrappedTileCoord_[0];
            const size = this.targetTileGrid_.getTileSize(z);
            const width = typeof size === "number" ? size : size[0];
            const height = typeof size === "number" ? size : size[1];
            const targetResolution = this.targetTileGrid_.getResolution(z);
            const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
            const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            this.canvas_ = (0, _reprojJs.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
            this.state = (0, _tileStateJsDefault.default).LOADED;
        }
        this.changed();
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _tileStateJsDefault.default).IDLE) {
            this.state = (0, _tileStateJsDefault.default).LOADING;
            this.changed();
            let leftToLoad = 0;
            this.sourcesListenerKeys_ = [];
            this.sourceTiles_.forEach((function(tile, i, arr) {
                const state = tile.getState();
                if (state == (0, _tileStateJsDefault.default).IDLE || state == (0, _tileStateJsDefault.default).LOADING) {
                    leftToLoad++;
                    const sourceListenKey = (0, _eventsJs.listen)(tile, (0, _eventTypeJsDefault.default).CHANGE, function(e) {
                        const state = tile.getState();
                        if (state == (0, _tileStateJsDefault.default).LOADED || state == (0, _tileStateJsDefault.default).ERROR || state == (0, _tileStateJsDefault.default).EMPTY) {
                            (0, _eventsJs.unlistenByKey)(sourceListenKey);
                            leftToLoad--;
                            if (leftToLoad === 0) {
                                this.unlistenSources_();
                                this.reproject_();
                            }
                        }
                    }, this);
                    this.sourcesListenerKeys_.push(sourceListenKey);
                }
            }).bind(this));
            if (leftToLoad === 0) setTimeout(this.reproject_.bind(this), 0);
            else this.sourceTiles_.forEach(function(tile, i, arr) {
                const state = tile.getState();
                if (state == (0, _tileStateJsDefault.default).IDLE) tile.load();
            });
        }
    }
    /**
   * @private
   */ unlistenSources_() {
        this.sourcesListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.sourcesListenerKeys_ = null;
    }
    /**
   * Remove from the cache due to expiry
   */ release() {
        if (this.canvas_) {
            (0, _domJs.releaseCanvas)(this.canvas_.getContext("2d"));
            (0, _reprojJs.canvasPool).push(this.canvas_);
            this.canvas_ = null;
        }
        super.release();
    }
}
exports.default = ReprojTile;

},{"./common.js":"qh92B","../events/EventType.js":"hrQJ6","../Tile.js":"4sqb5","../TileState.js":"2fodI","./Triangulation.js":"3jZUN","../reproj.js":"jbreX","../math.js":"5jEFr","../extent.js":"6YrVc","../events.js":"dcspA","../dom.js":"84QzQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3pvAn":[function(require,module,exports) {
/**
 * @module ol/TileRange
 */ /**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate);
class TileRange {
    /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */ constructor(minX, maxX, minY, maxY){
        /**
     * @type {number}
     */ this.minX = minX;
        /**
     * @type {number}
     */ this.maxX = maxX;
        /**
     * @type {number}
     */ this.minY = minY;
        /**
     * @type {number}
     */ this.maxY = maxY;
    }
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */ contains(tileCoord) {
        return this.containsXY(tileCoord[1], tileCoord[2]);
    }
    /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */ containsTileRange(tileRange) {
        return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    }
    /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */ containsXY(x, y) {
        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    }
    /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */ equals(tileRange) {
        return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    }
    /**
   * @param {TileRange} tileRange Tile range.
   */ extend(tileRange) {
        if (tileRange.minX < this.minX) this.minX = tileRange.minX;
        if (tileRange.maxX > this.maxX) this.maxX = tileRange.maxX;
        if (tileRange.minY < this.minY) this.minY = tileRange.minY;
        if (tileRange.maxY > this.maxY) this.maxY = tileRange.maxY;
    }
    /**
   * @return {number} Height.
   */ getHeight() {
        return this.maxY - this.minY + 1;
    }
    /**
   * @return {import("./size.js").Size} Size.
   */ getSize() {
        return [
            this.getWidth(),
            this.getHeight()
        ];
    }
    /**
   * @return {number} Width.
   */ getWidth() {
        return this.maxX - this.minX + 1;
    }
    /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */ intersects(tileRange) {
        return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
    }
}
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
    if (tileRange !== undefined) {
        tileRange.minX = minX;
        tileRange.maxX = maxX;
        tileRange.minY = minY;
        tileRange.maxY = maxY;
        return tileRange;
    } else return new TileRange(minX, maxX, minY, maxY);
}
exports.default = TileRange;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ySVS":[function(require,module,exports) {
/**
 * @module ol/source/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */ parcelHelpers.export(exports, "TileSourceEvent", ()=>TileSourceEvent);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _tileCacheJs = require("../TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _utilJs = require("../util.js");
var _assertsJs = require("../asserts.js");
var _projJs = require("../proj.js");
var _tilecoordJs = require("../tilecoord.js");
var _tilegridJs = require("../tilegrid.js");
var _sizeJs = require("../size.js");
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */ class TileSource extends (0, _sourceJsDefault.default) {
    /**
   * @param {Options} options SourceTile source options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            attributionsCollapsible: options.attributionsCollapsible,
            projection: options.projection,
            state: options.state,
            wrapX: options.wrapX,
            interpolate: options.interpolate
        });
        /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {TileSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {boolean}
     */ this.opaque_ = options.opaque !== undefined ? options.opaque : false;
        /**
     * @private
     * @type {number}
     */ this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
        /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     */ this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
        const tileSize = [
            256,
            256
        ];
        if (this.tileGrid) (0, _sizeJs.toSize)(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
        /**
     * @protected
     * @type {import("../TileCache.js").default}
     */ this.tileCache = new (0, _tileCacheJsDefault.default)(options.cacheSize || 0);
        /**
     * @protected
     * @type {import("../size.js").Size}
     */ this.tmpSize = [
            0,
            0
        ];
        /**
     * @private
     * @type {string}
     */ this.key_ = options.key || "";
        /**
     * @protected
     * @type {import("../Tile.js").Options}
     */ this.tileOptions = {
            transition: options.transition,
            interpolate: options.interpolate
        };
        /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */ this.zDirection = options.zDirection ? options.zDirection : 0;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        return this.tileCache.canExpireCache();
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */ expireCache(projection, usedTiles) {
        const tileCache = this.getTileCacheForProjection(projection);
        if (tileCache) tileCache.expireCache(usedTiles);
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */ forEachLoadedTile(projection, z, tileRange, callback) {
        const tileCache = this.getTileCacheForProjection(projection);
        if (!tileCache) return false;
        let covered = true;
        let tile, tileCoordKey, loaded;
        for(let x = tileRange.minX; x <= tileRange.maxX; ++x)for(let y = tileRange.minY; y <= tileRange.maxY; ++y){
            tileCoordKey = (0, _tilecoordJs.getKeyZXY)(z, x, y);
            loaded = false;
            if (tileCache.containsKey(tileCoordKey)) {
                tile = /** @type {!import("../Tile.js").default} */ tileCache.get(tileCoordKey);
                loaded = tile.getState() === (0, _tileStateJsDefault.default).LOADED;
                if (loaded) loaded = callback(tile) !== false;
            }
            if (!loaded) covered = false;
        }
        return covered;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */ getGutterForProjection(projection) {
        return 0;
    }
    /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */ getKey() {
        return this.key_;
    }
    /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */ setKey(key) {
        if (this.key_ !== key) {
            this.key_ = key;
            this.changed();
        }
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */ getOpaque(projection) {
        return this.opaque_;
    }
    /**
   * @return {Array<number>|null} Resolutions.
   */ getResolutions() {
        if (!this.tileGrid) return null;
        return this.tileGrid.getResolutions();
    }
    /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */ getTile(z, x, y, pixelRatio, projection) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */ getTileGrid() {
        return this.tileGrid;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */ getTileGridForProjection(projection) {
        if (!this.tileGrid) return (0, _tilegridJs.getForProjection)(projection);
        else return this.tileGrid;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */ getTileCacheForProjection(projection) {
        const sourceProjection = this.getProjection();
        (0, _assertsJs.assert)(sourceProjection === null || (0, _projJs.equivalent)(sourceProjection, projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
        );
        return this.tileCache;
    }
    /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */ getTilePixelRatio(pixelRatio) {
        return this.tilePixelRatio_;
    }
    /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */ getTilePixelSize(z, pixelRatio, projection) {
        const tileGrid = this.getTileGridForProjection(projection);
        const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(z), this.tmpSize);
        if (tilePixelRatio == 1) return tileSize;
        else return (0, _sizeJs.scale)(tileSize, tilePixelRatio, this.tmpSize);
    }
    /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */ getTileCoordForTileUrlFunction(tileCoord, projection) {
        projection = projection !== undefined ? projection : this.getProjection();
        const tileGrid = this.getTileGridForProjection(projection);
        if (this.getWrapX() && projection.isGlobal()) tileCoord = (0, _tilegridJs.wrapX)(tileGrid, tileCoord, projection);
        return (0, _tilecoordJs.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
    }
    /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */ clear() {
        this.tileCache.clear();
    }
    refresh() {
        this.clear();
        super.refresh();
    }
    /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ updateCacheSize(tileCount, projection) {
        const tileCache = this.getTileCacheForProjection(projection);
        if (tileCount > tileCache.highWaterMark) tileCache.highWaterMark = tileCount;
    }
    /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ useTile(z, x, y, projection) {}
}
class TileSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */ constructor(type, tile){
        super(type);
        /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */ this.tile = tile;
    }
}
exports.default = TileSource;

},{"../events/Event.js":"hwXQP","./Source.js":"bgZ4G","../TileCache.js":"3AgyC","../TileState.js":"2fodI","../util.js":"pLBjQ","../asserts.js":"e4TiF","../proj.js":"SznqC","../tilecoord.js":"bZ2LT","../tilegrid.js":"1Yr4i","../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3AgyC":[function(require,module,exports) {
/**
 * @module ol/TileCache
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lrucacheJs = require("./structs/LRUCache.js");
var _lrucacheJsDefault = parcelHelpers.interopDefault(_lrucacheJs);
var _tilecoordJs = require("./tilecoord.js");
class TileCache extends (0, _lrucacheJsDefault.default) {
    clear() {
        while(this.getCount() > 0)this.pop().release();
        super.clear();
    }
    /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */ expireCache(usedTiles) {
        while(this.canExpireCache()){
            const tile = this.peekLast();
            if (tile.getKey() in usedTiles) break;
            else this.pop().release();
        }
    }
    /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */ pruneExceptNewestZ() {
        if (this.getCount() === 0) return;
        const key = this.peekFirstKey();
        const tileCoord = (0, _tilecoordJs.fromKey)(key);
        const z = tileCoord[0];
        this.forEach((function(tile) {
            if (tile.tileCoord[0] !== z) {
                this.remove((0, _tilecoordJs.getKey)(tile.tileCoord));
                tile.release();
            }
        }).bind(this));
    }
}
exports.default = TileCache;

},{"./structs/LRUCache.js":"cmjR9","./tilecoord.js":"bZ2LT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmjR9":[function(require,module,exports) {
/**
 * @module ol/structs/LRUCache
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertsJs = require("../asserts.js");
/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Object} newer Newer.
 * @property {Object} older Older.
 * @property {*} value_ Value.
 */ /**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */ class LRUCache {
    /**
   * @param {number} [highWaterMark] High water mark.
   */ constructor(highWaterMark){
        /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */ this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;
        /**
     * @private
     * @type {number}
     */ this.count_ = 0;
        /**
     * @private
     * @type {!Object<string, Entry>}
     */ this.entries_ = {};
        /**
     * @private
     * @type {?Entry}
     */ this.oldest_ = null;
        /**
     * @private
     * @type {?Entry}
     */ this.newest_ = null;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }
    /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */ expireCache(keep) {
        while(this.canExpireCache())this.pop();
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.count_ = 0;
        this.entries_ = {};
        this.oldest_ = null;
        this.newest_ = null;
    }
    /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */ containsKey(key) {
        return this.entries_.hasOwnProperty(key);
    }
    /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */ forEach(f) {
        let entry = this.oldest_;
        while(entry){
            f(entry.value_, entry.key_, this);
            entry = entry.newer;
        }
    }
    /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */ get(key, options) {
        const entry = this.entries_[key];
        (0, _assertsJs.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) return entry.value_;
        else if (entry === this.oldest_) {
            this.oldest_ = /** @type {Entry} */ this.oldest_.newer;
            this.oldest_.older = null;
        } else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
    }
    /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */ remove(key) {
        const entry = this.entries_[key];
        (0, _assertsJs.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) {
            this.newest_ = /** @type {Entry} */ entry.older;
            if (this.newest_) this.newest_.newer = null;
        } else if (entry === this.oldest_) {
            this.oldest_ = /** @type {Entry} */ entry.newer;
            if (this.oldest_) this.oldest_.older = null;
        } else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        delete this.entries_[key];
        --this.count_;
        return entry.value_;
    }
    /**
   * @return {number} Count.
   */ getCount() {
        return this.count_;
    }
    /**
   * @return {Array<string>} Keys.
   */ getKeys() {
        const keys = new Array(this.count_);
        let i = 0;
        let entry;
        for(entry = this.newest_; entry; entry = entry.older)keys[i++] = entry.key_;
        return keys;
    }
    /**
   * @return {Array<T>} Values.
   */ getValues() {
        const values = new Array(this.count_);
        let i = 0;
        let entry;
        for(entry = this.newest_; entry; entry = entry.older)values[i++] = entry.value_;
        return values;
    }
    /**
   * @return {T} Last value.
   */ peekLast() {
        return this.oldest_.value_;
    }
    /**
   * @return {string} Last key.
   */ peekLastKey() {
        return this.oldest_.key_;
    }
    /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */ peekFirstKey() {
        return this.newest_.key_;
    }
    /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */ peek(key) {
        if (!this.containsKey(key)) return undefined;
        return this.entries_[key].value_;
    }
    /**
   * @return {T} value Value.
   */ pop() {
        const entry = this.oldest_;
        delete this.entries_[entry.key_];
        if (entry.newer) entry.newer.older = null;
        this.oldest_ = /** @type {Entry} */ entry.newer;
        if (!this.oldest_) this.newest_ = null;
        --this.count_;
        return entry.value_;
    }
    /**
   * @param {string} key Key.
   * @param {T} value Value.
   */ replace(key, value) {
        this.get(key); // update `newest_`
        this.entries_[key].value_ = value;
    }
    /**
   * @param {string} key Key.
   * @param {T} value Value.
   */ set(key, value) {
        (0, _assertsJs.assert)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
        const entry = {
            key_: key,
            newer: null,
            older: this.newest_,
            value_: value
        };
        if (!this.newest_) this.oldest_ = entry;
        else this.newest_.newer = entry;
        this.newest_ = entry;
        this.entries_[key] = entry;
        ++this.count_;
    }
    /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */ setSize(size) {
        this.highWaterMark = size;
    }
}
exports.default = LRUCache;

},{"../asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Yr4i":[function(require,module,exports) {
/**
 * @module ol/tilegrid
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */ parcelHelpers.export(exports, "getForProjection", ()=>getForProjection);
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */ parcelHelpers.export(exports, "createForExtent", ()=>createForExtent);
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */ /**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */ parcelHelpers.export(exports, "createXYZ", ()=>createXYZ);
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */ parcelHelpers.export(exports, "createForProjection", ()=>createForProjection);
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */ parcelHelpers.export(exports, "extentFromProjection", ()=>extentFromProjection);
var _tileGridJs = require("./tilegrid/TileGrid.js");
var _tileGridJsDefault = parcelHelpers.interopDefault(_tileGridJs);
var _commonJs = require("./tilegrid/common.js");
var _projJs = require("./proj.js");
var _extentJs = require("./extent.js");
var _sizeJs = require("./size.js");
function getForProjection(projection) {
    let tileGrid = projection.getDefaultTileGrid();
    if (!tileGrid) {
        tileGrid = createForProjection(projection);
        projection.setDefaultTileGrid(tileGrid);
    }
    return tileGrid;
}
function wrapX(tileGrid, tileCoord, projection) {
    const z = tileCoord[0];
    const center = tileGrid.getTileCoordCenter(tileCoord);
    const projectionExtent = extentFromProjection(projection);
    if (!(0, _extentJs.containsCoordinate)(projectionExtent, center)) {
        const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
        const worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
        center[0] += worldWidth * worldsAway;
        return tileGrid.getTileCoordForCoordAndZ(center, z);
    } else return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
    corner = corner !== undefined ? corner : "top-left";
    const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
    return new (0, _tileGridJsDefault.default)({
        extent: extent,
        origin: (0, _extentJs.getCorner)(extent, corner),
        resolutions: resolutions,
        tileSize: tileSize
    });
}
function createXYZ(options) {
    const xyzOptions = options || {};
    const extent = xyzOptions.extent || (0, _projJs.get)("EPSG:3857").getExtent();
    const gridOptions = {
        extent: extent,
        minZoom: xyzOptions.minZoom,
        tileSize: xyzOptions.tileSize,
        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
    };
    return new (0, _tileGridJsDefault.default)(gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */ function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
    maxZoom = maxZoom !== undefined ? maxZoom : (0, _commonJs.DEFAULT_MAX_ZOOM);
    tileSize = (0, _sizeJs.toSize)(tileSize !== undefined ? tileSize : (0, _commonJs.DEFAULT_TILE_SIZE));
    const height = (0, _extentJs.getHeight)(extent);
    const width = (0, _extentJs.getWidth)(extent);
    maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
    const length = maxZoom + 1;
    const resolutions = new Array(length);
    for(let z = 0; z < length; ++z)resolutions[z] = maxResolution / Math.pow(2, z);
    return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
    const extent = extentFromProjection(projection);
    return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
    projection = (0, _projJs.get)(projection);
    let extent = projection.getExtent();
    if (!extent) {
        const half = 180 * (0, _projJs.METERS_PER_UNIT).degrees / projection.getMetersPerUnit();
        extent = (0, _extentJs.createOrUpdate)(-half, -half, half, half);
    }
    return extent;
}

},{"./tilegrid/TileGrid.js":"cZOJJ","./tilegrid/common.js":"bxYGl","./proj.js":"SznqC","./extent.js":"6YrVc","./size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZOJJ":[function(require,module,exports) {
/**
 * @module ol/tilegrid/TileGrid
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileRangeJs = require("../TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _commonJs = require("./common.js");
var _assertsJs = require("../asserts.js");
var _mathJs = require("../math.js");
var _extentJs = require("../extent.js");
var _tilecoordJs = require("../tilecoord.js");
var _intersectsextentJs = require("../geom/flat/intersectsextent.js");
var _arrayJs = require("../array.js");
var _sizeJs = require("../size.js");
/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */ const tmpTileCoord = [
    0,
    0,
    0
];
/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */ const DECIMALS = 5;
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */ /**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */ class TileGrid {
    /**
   * @param {Options} options Tile grid options.
   */ constructor(options){
        /**
     * @protected
     * @type {number}
     */ this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
        /**
     * @private
     * @type {!Array<number>}
     */ this.resolutions_ = options.resolutions;
        (0, _assertsJs.assert)((0, _arrayJs.isSorted)(this.resolutions_, function(a, b) {
            return b - a;
        }, true), 17); // `resolutions` must be sorted in descending order
        // check if we've got a consistent zoom factor and origin
        let zoomFactor;
        if (!options.origins) for(let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i){
            if (!zoomFactor) zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
            else if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                zoomFactor = undefined;
                break;
            }
        }
        /**
     * @private
     * @type {number|undefined}
     */ this.zoomFactor_ = zoomFactor;
        /**
     * @protected
     * @type {number}
     */ this.maxZoom = this.resolutions_.length - 1;
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */ this.origin_ = options.origin !== undefined ? options.origin : null;
        /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */ this.origins_ = null;
        if (options.origins !== undefined) {
            this.origins_ = options.origins;
            (0, _assertsJs.assert)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
        }
        const extent = options.extent;
        if (extent !== undefined && !this.origin_ && !this.origins_) this.origin_ = (0, _extentJs.getTopLeft)(extent);
        (0, _assertsJs.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both
        /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */ this.tileSizes_ = null;
        if (options.tileSizes !== undefined) {
            this.tileSizes_ = options.tileSizes;
            (0, _assertsJs.assert)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
        }
        /**
     * @private
     * @type {number|import("../size.js").Size}
     */ this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? (0, _commonJs.DEFAULT_TILE_SIZE) : null;
        (0, _assertsJs.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = extent !== undefined ? extent : null;
        /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */ this.fullTileRanges_ = null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.tmpSize_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.tmpExtent_ = [
            0,
            0,
            0,
            0
        ];
        if (options.sizes !== undefined) this.fullTileRanges_ = options.sizes.map(function(size, z) {
            const tileRange = new (0, _tileRangeJsDefault.default)(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
            if (extent) {
                const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
                tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
                tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
                tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
                tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
            }
            return tileRange;
        }, this);
        else if (extent) this.calculateTileRanges_(extent);
    }
    /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */ forEachTileCoord(extent, zoom, callback) {
        const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
        for(let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i)for(let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j)callback([
            zoom,
            i,
            j
        ]);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */ forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
        let tileRange, x, y;
        let tileCoordExtent = null;
        let z = tileCoord[0] - 1;
        if (this.zoomFactor_ === 2) {
            x = tileCoord[1];
            y = tileCoord[2];
        } else tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
        while(z >= this.minZoom){
            if (this.zoomFactor_ === 2) {
                x = Math.floor(x / 2);
                y = Math.floor(y / 2);
                tileRange = (0, _tileRangeJs.createOrUpdate)(x, x, y, y, tempTileRange);
            } else tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
            if (callback(z, tileRange)) return true;
            --z;
        }
        return false;
    }
    /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        return this.extent_;
    }
    /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */ getMaxZoom() {
        return this.maxZoom;
    }
    /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */ getMinZoom() {
        return this.minZoom;
    }
    /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */ getOrigin(z) {
        if (this.origin_) return this.origin_;
        else return this.origins_[z];
    }
    /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */ getResolution(z) {
        return this.resolutions_[z];
    }
    /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */ getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
        if (tileCoord[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
                const minX = tileCoord[1] * 2;
                const minY = tileCoord[2] * 2;
                return (0, _tileRangeJs.createOrUpdate)(minX, minX + 1, minY, minY + 1, tempTileRange);
            }
            const tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, tempTileRange);
        }
        return null;
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */ getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
        if (z > this.maxZoom || z < this.minZoom) return null;
        const tileCoordZ = tileCoord[0];
        const tileCoordX = tileCoord[1];
        const tileCoordY = tileCoord[2];
        if (z === tileCoordZ) return (0, _tileRangeJs.createOrUpdate)(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);
        if (this.zoomFactor_) {
            const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
            const minX = Math.floor(tileCoordX * factor);
            const minY = Math.floor(tileCoordY * factor);
            if (z < tileCoordZ) return (0, _tileRangeJs.createOrUpdate)(minX, minX, minY, minY, tempTileRange);
            const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
            const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
            return (0, _tileRangeJs.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
        }
        const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
    }
    /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */ getTileRangeExtent(z, tileRange, tempExtent) {
        const origin = this.getOrigin(z);
        const resolution = this.getResolution(z);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(z), this.tmpSize_);
        const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
        const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
        const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
        const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
        return (0, _extentJs.createOrUpdate)(minX, minY, maxX, maxY, tempExtent);
    }
    /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */ getTileRangeForExtentAndZ(extent, z, tempTileRange) {
        const tileCoord = tmpTileCoord;
        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
        const minX = tileCoord[1];
        const minY = tileCoord[2];
        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
        return (0, _tileRangeJs.createOrUpdate)(minX, tileCoord[1], minY, tileCoord[2], tempTileRange);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */ getTileCoordCenter(tileCoord) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
        return [
            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
        ];
    }
    /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getTileCoordExtent(tileCoord, tempExtent) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
        const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
        const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
        const maxX = minX + tileSize[0] * resolution;
        const maxY = minY + tileSize[1] * resolution;
        return (0, _extentJs.createOrUpdate)(minX, minY, maxX, maxY, tempExtent);
    }
    /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */ getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    }
    /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */ getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
        const z = this.getZForResolution(resolution);
        const scale = resolution / this.getResolution(z);
        const origin = this.getOrigin(z);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(z), this.tmpSize_);
        let tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];
        let tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = (0, _mathJs.ceil)(tileCoordX, DECIMALS) - 1;
            tileCoordY = (0, _mathJs.ceil)(tileCoordY, DECIMALS) - 1;
        } else {
            tileCoordX = (0, _mathJs.floor)(tileCoordX, DECIMALS);
            tileCoordY = (0, _mathJs.floor)(tileCoordY, DECIMALS);
        }
        return (0, _tilecoordJs.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
    }
    /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */ getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
        const origin = this.getOrigin(z);
        const resolution = this.getResolution(z);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(z), this.tmpSize_);
        let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
        let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = (0, _mathJs.ceil)(tileCoordX, DECIMALS) - 1;
            tileCoordY = (0, _mathJs.ceil)(tileCoordY, DECIMALS) - 1;
        } else {
            tileCoordX = (0, _mathJs.floor)(tileCoordX, DECIMALS);
            tileCoordY = (0, _mathJs.floor)(tileCoordY, DECIMALS);
        }
        return (0, _tilecoordJs.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
    }
    /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */ getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */ getTileCoordResolution(tileCoord) {
        return this.resolutions_[tileCoord[0]];
    }
    /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */ getTileSize(z) {
        if (this.tileSize_) return this.tileSize_;
        else return this.tileSizes_[z];
    }
    /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */ getFullTileRange(z) {
        if (!this.fullTileRanges_) return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
        else return this.fullTileRanges_[z];
    }
    /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */ getZForResolution(resolution, opt_direction) {
        const z = (0, _arrayJs.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
        return (0, _mathJs.clamp)(z, this.minZoom, this.maxZoom);
    }
    /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */ tileCoordIntersectsViewport(tileCoord, viewport) {
        return (0, _intersectsextentJs.intersectsLinearRing)(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
    }
    /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */ calculateTileRanges_(extent) {
        const length = this.resolutions_.length;
        const fullTileRanges = new Array(length);
        for(let z = this.minZoom; z < length; ++z)fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
        this.fullTileRanges_ = fullTileRanges;
    }
}
exports.default = TileGrid;

},{"../TileRange.js":"3pvAn","./common.js":"bxYGl","../asserts.js":"e4TiF","../math.js":"5jEFr","../extent.js":"6YrVc","../tilecoord.js":"bZ2LT","../geom/flat/intersectsextent.js":"7x08H","../array.js":"1Fbic","../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g0paj":[function(require,module,exports) {
/**
 * @module ol/source/TileJSON
 */ // FIXME check order of async callbacks
/**
 * See https://mapbox.com/developers/api/.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileImageJs = require("./TileImage.js");
var _tileImageJsDefault = parcelHelpers.interopDefault(_tileImageJs);
var _extentJs = require("../extent.js");
var _assertsJs = require("../asserts.js");
var _tileurlfunctionJs = require("../tileurlfunction.js");
var _tilegridJs = require("../tilegrid.js");
var _projJs = require("../proj.js");
var _netJs = require("../net.js");
/**
 * @typedef {Object} Config
 * @property {string} [name] The name.
 * @property {string} [description] The description.
 * @property {string} [version] The version.
 * @property {string} [attribution] The attribution.
 * @property {string} [template] The template.
 * @property {string} [legend] The legend.
 * @property {string} [scheme] The scheme.
 * @property {Array<string>} tiles The tile URL templates.
 * @property {Array<string>} [grids] Optional grids.
 * @property {number} [minzoom] Minimum zoom level.
 * @property {number} [maxzoom] Maximum zoom level.
 * @property {Array<number>} [bounds] Optional bounds.
 * @property {Array<number>} [center] Optional center.
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.
 * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 * @api
 */ class TileJSON extends (0, _tileImageJsDefault.default) {
    /**
   * @param {Options} options TileJSON options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            crossOrigin: options.crossOrigin,
            interpolate: options.interpolate,
            projection: (0, _projJs.get)("EPSG:3857"),
            reprojectionErrorThreshold: options.reprojectionErrorThreshold,
            state: "loading",
            tileLoadFunction: options.tileLoadFunction,
            wrapX: options.wrapX !== undefined ? options.wrapX : true,
            transition: options.transition,
            zDirection: options.zDirection
        });
        /**
     * @type {Config}
     * @private
     */ this.tileJSON_ = null;
        /**
     * @type {number|import("../size.js").Size}
     * @private
     */ this.tileSize_ = options.tileSize;
        if (options.url) {
            if (options.jsonp) (0, _netJs.jsonp)(options.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
            else {
                const client = new XMLHttpRequest();
                client.addEventListener("load", this.onXHRLoad_.bind(this));
                client.addEventListener("error", this.onXHRError_.bind(this));
                client.open("GET", options.url);
                client.send();
            }
        } else if (options.tileJSON) this.handleTileJSONResponse(options.tileJSON);
        else (0, _assertsJs.assert)(false, 51); // Either `url` or `tileJSON` options must be provided
    }
    /**
   * @private
   * @param {Event} event The load event.
   */ onXHRLoad_(event) {
        const client = /** @type {XMLHttpRequest} */ event.target;
        // status will be 0 for file:// urls
        if (!client.status || client.status >= 200 && client.status < 300) {
            let response;
            try {
                response = /** @type {Config} */ JSON.parse(client.responseText);
            } catch (err) {
                this.handleTileJSONError();
                return;
            }
            this.handleTileJSONResponse(response);
        } else this.handleTileJSONError();
    }
    /**
   * @private
   * @param {Event} event The error event.
   */ onXHRError_(event) {
        this.handleTileJSONError();
    }
    /**
   * @return {Config} The tilejson object.
   * @api
   */ getTileJSON() {
        return this.tileJSON_;
    }
    /**
   * @protected
   * @param {Config} tileJSON Tile JSON.
   */ handleTileJSONResponse(tileJSON) {
        const epsg4326Projection = (0, _projJs.get)("EPSG:4326");
        const sourceProjection = this.getProjection();
        let extent;
        if (tileJSON["bounds"] !== undefined) {
            const transform = (0, _projJs.getTransformFromProjections)(epsg4326Projection, sourceProjection);
            extent = (0, _extentJs.applyTransform)(tileJSON["bounds"], transform);
        }
        const gridExtent = (0, _tilegridJs.extentFromProjection)(sourceProjection);
        const minZoom = tileJSON["minzoom"] || 0;
        const maxZoom = tileJSON["maxzoom"] || 22;
        const tileGrid = (0, _tilegridJs.createXYZ)({
            extent: gridExtent,
            maxZoom: maxZoom,
            minZoom: minZoom,
            tileSize: this.tileSize_
        });
        this.tileGrid = tileGrid;
        this.tileUrlFunction = (0, _tileurlfunctionJs.createFromTemplates)(tileJSON["tiles"], tileGrid);
        if (tileJSON["attribution"] && !this.getAttributions()) {
            const attributionExtent = extent !== undefined ? extent : gridExtent;
            this.setAttributions(function(frameState) {
                if ((0, _extentJs.intersects)(attributionExtent, frameState.extent)) return [
                    tileJSON["attribution"]
                ];
                return null;
            });
        }
        this.tileJSON_ = tileJSON;
        this.setState("ready");
    }
    /**
   * @protected
   */ handleTileJSONError() {
        this.setState("error");
    }
}
exports.default = TileJSON;

},{"./TileImage.js":"2cBKP","../extent.js":"6YrVc","../asserts.js":"e4TiF","../tileurlfunction.js":"gOwFC","../tilegrid.js":"1Yr4i","../proj.js":"SznqC","../net.js":"jxUka","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2cBKP":[function(require,module,exports) {
/**
 * @module ol/source/TileImage
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageTileJs = require("../ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _tileJs = require("../reproj/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileCacheJs = require("../TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _urlTileJs = require("./UrlTile.js");
var _urlTileJsDefault = parcelHelpers.interopDefault(_urlTileJs);
var _projJs = require("../proj.js");
var _tilecoordJs = require("../tilecoord.js");
var _tilegridJs = require("../tilegrid.js");
var _utilJs = require("../util.js");
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */ class TileImage extends (0, _urlTileJsDefault.default) {
    /**
   * @param {!Options} options Image tile options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            opaque: options.opaque,
            projection: options.projection,
            state: options.state,
            tileGrid: options.tileGrid,
            tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
            tilePixelRatio: options.tilePixelRatio,
            tileUrlFunction: options.tileUrlFunction,
            url: options.url,
            urls: options.urls,
            wrapX: options.wrapX,
            transition: options.transition,
            interpolate: options.interpolate !== undefined ? options.interpolate : true,
            key: options.key,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection
        });
        /**
     * @protected
     * @type {?string}
     */ this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
        /**
     * @protected
     * @type {typeof ImageTile}
     */ this.tileClass = options.tileClass !== undefined ? options.tileClass : (0, _imageTileJsDefault.default);
        /**
     * @protected
     * @type {!Object<string, TileCache>}
     */ this.tileCacheForProjection = {};
        /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */ this.tileGridForProjection = {};
        /**
     * @private
     * @type {number|undefined}
     */ this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
        /**
     * @private
     * @type {boolean}
     */ this.renderReprojectionEdges_ = false;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        if (this.tileCache.canExpireCache()) return true;
        else for(const key in this.tileCacheForProjection){
            if (this.tileCacheForProjection[key].canExpireCache()) return true;
        }
        return false;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */ expireCache(projection, usedTiles) {
        const usedTileCache = this.getTileCacheForProjection(projection);
        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
        for(const id in this.tileCacheForProjection){
            const tileCache = this.tileCacheForProjection[id];
            tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
        }
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */ getGutterForProjection(projection) {
        if (this.getProjection() && projection && !(0, _projJs.equivalent)(this.getProjection(), projection)) return 0;
        else return this.getGutter();
    }
    /**
   * @return {number} Gutter.
   */ getGutter() {
        return 0;
    }
    /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */ getKey() {
        let key = super.getKey();
        if (!this.getInterpolate()) key += ":disable-interpolation";
        return key;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */ getOpaque(projection) {
        if (this.getProjection() && projection && !(0, _projJs.equivalent)(this.getProjection(), projection)) return false;
        else return super.getOpaque(projection);
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */ getTileGridForProjection(projection) {
        const thisProj = this.getProjection();
        if (this.tileGrid && (!thisProj || (0, _projJs.equivalent)(thisProj, projection))) return this.tileGrid;
        else {
            const projKey = (0, _utilJs.getUid)(projection);
            if (!(projKey in this.tileGridForProjection)) this.tileGridForProjection[projKey] = (0, _tilegridJs.getForProjection)(projection);
            return this.tileGridForProjection[projKey];
        }
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */ getTileCacheForProjection(projection) {
        const thisProj = this.getProjection();
        if (!thisProj || (0, _projJs.equivalent)(thisProj, projection)) return this.tileCache;
        else {
            const projKey = (0, _utilJs.getUid)(projection);
            if (!(projKey in this.tileCacheForProjection)) this.tileCacheForProjection[projKey] = new (0, _tileCacheJsDefault.default)(this.tileCache.highWaterMark);
            return this.tileCacheForProjection[projKey];
        }
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */ createTile_(z, x, y, pixelRatio, projection, key) {
        const tileCoord = [
            z,
            x,
            y
        ];
        const urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
        const tile = new this.tileClass(tileCoord, tileUrl !== undefined ? (0, _tileStateJsDefault.default).IDLE : (0, _tileStateJsDefault.default).EMPTY, tileUrl !== undefined ? tileUrl : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
        tile.key = key;
        tile.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.handleTileChange.bind(this));
        return tile;
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */ getTile(z, x, y, pixelRatio, projection) {
        const sourceProjection = this.getProjection();
        if (!sourceProjection || !projection || (0, _projJs.equivalent)(sourceProjection, projection)) return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
        else {
            const cache = this.getTileCacheForProjection(projection);
            const tileCoord = [
                z,
                x,
                y
            ];
            let tile;
            const tileCoordKey = (0, _tilecoordJs.getKey)(tileCoord);
            if (cache.containsKey(tileCoordKey)) tile = cache.get(tileCoordKey);
            const key = this.getKey();
            if (tile && tile.key == key) return tile;
            else {
                const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
                const targetTileGrid = this.getTileGridForProjection(projection);
                const wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                const newTile = new (0, _tileJsDefault.default)(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), (function(z, x, y, pixelRatio) {
                    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
                }).bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
                newTile.key = key;
                if (tile) {
                    newTile.interimTile = tile;
                    newTile.refreshInterimChain();
                    cache.replace(tileCoordKey, newTile);
                } else cache.set(tileCoordKey, newTile);
                return newTile;
            }
        }
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @protected
   */ getTileInternal(z, x, y, pixelRatio, projection) {
        let tile = null;
        const tileCoordKey = (0, _tilecoordJs.getKeyZXY)(z, x, y);
        const key = this.getKey();
        if (!this.tileCache.containsKey(tileCoordKey)) {
            tile = this.createTile_(z, x, y, pixelRatio, projection, key);
            this.tileCache.set(tileCoordKey, tile);
        } else {
            tile = this.tileCache.get(tileCoordKey);
            if (tile.key != key) {
                // The source's params changed. If the tile has an interim tile and if we
                // can use it then we use it. Otherwise we create a new tile.  In both
                // cases we attempt to assign an interim tile to the new tile.
                const interimTile = tile;
                tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                //make the new tile the head of the list,
                if (interimTile.getState() == (0, _tileStateJsDefault.default).IDLE) //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
                tile.interimTile = interimTile.interimTile;
                else tile.interimTile = interimTile;
                tile.refreshInterimChain();
                this.tileCache.replace(tileCoordKey, tile);
            }
        }
        return tile;
    }
    /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */ setRenderReprojectionEdges(render) {
        if (this.renderReprojectionEdges_ == render) return;
        this.renderReprojectionEdges_ = render;
        for(const id in this.tileCacheForProjection)this.tileCacheForProjection[id].clear();
        this.changed();
    }
    /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */ setTileGridForProjection(projection, tilegrid) {
        const proj = (0, _projJs.get)(projection);
        if (proj) {
            const projKey = (0, _utilJs.getUid)(proj);
            if (!(projKey in this.tileGridForProjection)) this.tileGridForProjection[projKey] = tilegrid;
        }
    }
    clear() {
        super.clear();
        for(const id in this.tileCacheForProjection)this.tileCacheForProjection[id].clear();
    }
}
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */ function defaultTileLoadFunction(imageTile, src) {
    /** @type {HTMLImageElement|HTMLVideoElement} */ imageTile.getImage().src = src;
}
exports.default = TileImage;

},{"../events/EventType.js":"hrQJ6","../ImageTile.js":"bGt2E","../reproj/Tile.js":"lR1TX","../TileCache.js":"3AgyC","../TileState.js":"2fodI","./UrlTile.js":"2X3sL","../proj.js":"SznqC","../tilecoord.js":"bZ2LT","../tilegrid.js":"1Yr4i","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2X3sL":[function(require,module,exports) {
/**
 * @module ol/source/UrlTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileEventTypeJs = require("./TileEventType.js");
var _tileEventTypeJsDefault = parcelHelpers.interopDefault(_tileEventTypeJs);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _tileurlfunctionJs = require("../tileurlfunction.js");
var _tilecoordJs = require("../tilecoord.js");
var _utilJs = require("../util.js");
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */ class UrlTile extends (0, _tileJsDefault.default) {
    /**
   * @param {Options} options Image tile options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            opaque: options.opaque,
            projection: options.projection,
            state: options.state,
            tileGrid: options.tileGrid,
            tilePixelRatio: options.tilePixelRatio,
            wrapX: options.wrapX,
            transition: options.transition,
            interpolate: options.interpolate,
            key: options.key,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection
        });
        /**
     * @private
     * @type {boolean}
     */ this.generateTileUrlFunction_ = this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
        /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */ this.tileLoadFunction = options.tileLoadFunction;
        if (options.tileUrlFunction) this.tileUrlFunction = options.tileUrlFunction;
        /**
     * @protected
     * @type {!Array<string>|null}
     */ this.urls = null;
        if (options.urls) this.setUrls(options.urls);
        else if (options.url) this.setUrl(options.url);
        /**
     * @private
     * @type {!Object<string, boolean>}
     */ this.tileLoadingKeys_ = {};
    }
    /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */ getTileLoadFunction() {
        return this.tileLoadFunction;
    }
    /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */ getTileUrlFunction() {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    }
    /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */ getUrls() {
        return this.urls;
    }
    /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */ handleTileChange(event) {
        const tile = /** @type {import("../Tile.js").default} */ event.target;
        const uid = (0, _utilJs.getUid)(tile);
        const tileState = tile.getState();
        let type;
        if (tileState == (0, _tileStateJsDefault.default).LOADING) {
            this.tileLoadingKeys_[uid] = true;
            type = (0, _tileEventTypeJsDefault.default).TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
            delete this.tileLoadingKeys_[uid];
            type = tileState == (0, _tileStateJsDefault.default).ERROR ? (0, _tileEventTypeJsDefault.default).TILELOADERROR : tileState == (0, _tileStateJsDefault.default).LOADED ? (0, _tileEventTypeJsDefault.default).TILELOADEND : undefined;
        }
        if (type != undefined) this.dispatchEvent(new (0, _tileJs.TileSourceEvent)(type, tile));
    }
    /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */ setTileLoadFunction(tileLoadFunction) {
        this.tileCache.clear();
        this.tileLoadFunction = tileLoadFunction;
        this.changed();
    }
    /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */ setTileUrlFunction(tileUrlFunction, key) {
        this.tileUrlFunction = tileUrlFunction;
        this.tileCache.pruneExceptNewestZ();
        if (typeof key !== "undefined") this.setKey(key);
        else this.changed();
    }
    /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */ setUrl(url) {
        const urls = (0, _tileurlfunctionJs.expandUrl)(url);
        this.urls = urls;
        this.setUrls(urls);
    }
    /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */ setUrls(urls) {
        this.urls = urls;
        const key = urls.join("\n");
        if (this.generateTileUrlFunction_) this.setTileUrlFunction((0, _tileurlfunctionJs.createFromTemplates)(urls, this.tileGrid), key);
        else this.setKey(key);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */ tileUrlFunction(tileCoord, pixelRatio, projection) {
        return undefined;
    }
    /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */ useTile(z, x, y) {
        const tileCoordKey = (0, _tilecoordJs.getKeyZXY)(z, x, y);
        if (this.tileCache.containsKey(tileCoordKey)) this.tileCache.get(tileCoordKey);
    }
}
exports.default = UrlTile;

},{"./TileEventType.js":"9ZOYi","./Tile.js":"3ySVS","../TileState.js":"2fodI","../tileurlfunction.js":"gOwFC","../tilecoord.js":"bZ2LT","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ZOYi":[function(require,module,exports) {
/**
 * @module ol/source/TileEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */ TILELOADSTART: "tileloadstart",
    /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */ TILELOADEND: "tileloadend",
    /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */ TILELOADERROR: "tileloaderror"
}; /**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jxUka":[function(require,module,exports) {
/**
 * @module ol/net
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {Function} [errback] Callback on error.
 * @param {string} [callbackParam] Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */ parcelHelpers.export(exports, "jsonp", ()=>jsonp);
parcelHelpers.export(exports, "ResponseError", ()=>ResponseError);
parcelHelpers.export(exports, "ClientError", ()=>ClientError);
/**
 * @param {string} url The URL.
 * @return {Promise<Object>} A promise that resolves to the JSON response.
 */ parcelHelpers.export(exports, "getJSON", ()=>getJSON);
/**
 * @param {string} base The base URL.
 * @param {string} url The potentially relative URL.
 * @return {string} The full URL.
 */ parcelHelpers.export(exports, "resolveUrl", ()=>resolveUrl);
parcelHelpers.export(exports, "overrideXHR", ()=>overrideXHR);
parcelHelpers.export(exports, "restoreXHR", ()=>restoreXHR);
var _utilJs = require("./util.js");
var global = arguments[3];
function jsonp(url, callback, errback, callbackParam) {
    const script = document.createElement("script");
    const key = "olc_" + (0, _utilJs.getUid)(callback);
    function cleanup() {
        delete window[key];
        script.parentNode.removeChild(script);
    }
    script.async = true;
    script.src = url + (url.includes("?") ? "&" : "?") + (callbackParam || "callback") + "=" + key;
    const timer = setTimeout(function() {
        cleanup();
        if (errback) errback();
    }, 10000);
    window[key] = function(data) {
        clearTimeout(timer);
        cleanup();
        callback(data);
    };
    document.head.appendChild(script);
}
class ResponseError extends Error {
    /**
   * @param {XMLHttpRequest} response The XHR object.
   */ constructor(response){
        const message = "Unexpected response status: " + response.status;
        super(message);
        /**
     * @type {string}
     */ this.name = "ResponseError";
        /**
     * @type {XMLHttpRequest}
     */ this.response = response;
    }
}
class ClientError extends Error {
    /**
   * @param {XMLHttpRequest} client The XHR object.
   */ constructor(client){
        super("Failed to issue request");
        /**
     * @type {string}
     */ this.name = "ClientError";
        /**
     * @type {XMLHttpRequest}
     */ this.client = client;
    }
}
function getJSON(url) {
    return new Promise(function(resolve, reject) {
        /**
     * @param {ProgressEvent<XMLHttpRequest>} event The load event.
     */ function onLoad(event) {
            const client = event.target;
            // status will be 0 for file:// urls
            if (!client.status || client.status >= 200 && client.status < 300) {
                let data;
                try {
                    data = JSON.parse(client.responseText);
                } catch (err) {
                    const message = "Error parsing response text as JSON: " + err.message;
                    reject(new Error(message));
                    return;
                }
                resolve(data);
                return;
            }
            reject(new ResponseError(client));
        }
        /**
     * @param {ProgressEvent<XMLHttpRequest>} event The error event.
     */ function onError(event) {
            reject(new ClientError(event.target));
        }
        const client = new XMLHttpRequest();
        client.addEventListener("load", onLoad);
        client.addEventListener("error", onError);
        client.open("GET", url);
        client.setRequestHeader("Accept", "application/json");
        client.send();
    });
}
function resolveUrl(base, url) {
    if (url.includes("://")) return url;
    return new URL(url, base).href;
}
let originalXHR;
function overrideXHR(xhr) {
    if (typeof XMLHttpRequest !== "undefined") originalXHR = XMLHttpRequest;
    global.XMLHttpRequest = xhr;
}
function restoreXHR() {
    global.XMLHttpRequest = originalXHR;
}

},{"./util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iTrAy":[function(require,module,exports) {
/**
 * @module ol/layer/Vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseVectorJs = require("./BaseVector.js");
var _baseVectorJsDefault = parcelHelpers.interopDefault(_baseVectorJs);
var _vectorLayerJs = require("../renderer/canvas/VectorLayer.js");
var _vectorLayerJsDefault = parcelHelpers.interopDefault(_vectorLayerJs);
/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */ class VectorLayer extends (0, _baseVectorJsDefault.default) {
    /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */ constructor(options){
        super(options);
    }
    createRenderer() {
        return new (0, _vectorLayerJsDefault.default)(this);
    }
}
exports.default = VectorLayer;

},{"./BaseVector.js":"2tWeN","../renderer/canvas/VectorLayer.js":"kTTmt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tWeN":[function(require,module,exports) {
/**
 * @module ol/layer/BaseVector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _styleJs = require("../style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _flatJs = require("../style/flat.js");
/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ const Property = {
    RENDER_ORDER: "renderOrder"
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */ class BaseVectorLayer extends (0, _layerJsDefault.default) {
    /**
   * @param {Options<VectorSourceType>} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        /**
     * @private
     * @type {boolean}
     */ this.declutter_ = options.declutter !== undefined ? options.declutter : false;
        /**
     * @type {number}
     * @private
     */ this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
        /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */ this.style_ = null;
        /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */ this.styleFunction_ = undefined;
        this.setStyle(options.style);
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    }
    /**
   * @return {boolean} Declutter.
   */ getDeclutter() {
        return this.declutter_;
    }
    /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */ getFeatures(pixel) {
        return super.getFeatures(pixel);
    }
    /**
   * @return {number|undefined} Render buffer.
   */ getRenderBuffer() {
        return this.renderBuffer_;
    }
    /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */ getRenderOrder() {
        return /** @type {import("../render.js").OrderFunction|null|undefined} */ this.get(Property.RENDER_ORDER);
    }
    /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */ getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */ getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
    }
    /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        if (!frameState.declutterTree) frameState.declutterTree = new (0, _rbushDefault.default)(9);
        /** @type {*} */ this.getRenderer().renderDeclutter(frameState);
    }
    /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */ setRenderOrder(renderOrder) {
        this.set(Property.RENDER_ORDER, renderOrder);
    }
    /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use "flat" style object literals instead of
   * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation
   * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */ setStyle(style) {
        /**
     * @type {import("../style/Style.js").StyleLike|null}
     */ let styleLike;
        if (style === undefined) styleLike = (0, _styleJs.createDefaultStyle);
        else if (style === null) styleLike = null;
        else if (typeof style === "function") styleLike = style;
        else if (style instanceof (0, _styleJsDefault.default)) styleLike = style;
        else if (Array.isArray(style)) {
            const len = style.length;
            /**
       * @type {Array<Style>}
       */ const styles = new Array(len);
            for(let i = 0; i < len; ++i){
                const s = style[i];
                if (s instanceof (0, _styleJsDefault.default)) styles[i] = s;
                else styles[i] = (0, _flatJs.toStyle)(s);
            }
            styleLike = styles;
        } else styleLike = (0, _flatJs.toStyle)(style);
        this.style_ = styleLike;
        this.styleFunction_ = style === null ? undefined : (0, _styleJs.toFunction)(this.style_);
        this.changed();
    }
}
exports.default = BaseVectorLayer;

},{"./Layer.js":"8J9Kf","rbush":"k2VZu","../style/Style.js":"fW7vC","../style/flat.js":"jGCUl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k2VZu":[function(require,module,exports) {
!function(t, i) {
    module.exports = i();
}(this, function() {
    "use strict";
    function t(t, r, e, a, h) {
        !function t(n, r, e, a, h) {
            for(; a > e;){
                if (a - e > 600) {
                    var o = a - e + 1, s = r - e + 1, l = Math.log(o), f = .5 * Math.exp(2 * l / 3), u = .5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1), m = Math.max(e, Math.floor(r - s * f / o + u)), c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
                    t(n, r, m, c, h);
                }
                var p = n[r], d = e, x = a;
                for(i(n, e, r), h(n[a], p) > 0 && i(n, e, a); d < x;){
                    for(i(n, d, x), d++, x--; h(n[d], p) < 0;)d++;
                    for(; h(n[x], p) > 0;)x--;
                }
                0 === h(n[e], p) ? i(n, e, x) : i(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
            }
        }(t, r, e || 0, a || t.length - 1, h || n);
    }
    function i(t, i, n) {
        var r = t[i];
        t[i] = t[n], t[n] = r;
    }
    function n(t, i) {
        return t < i ? -1 : t > i ? 1 : 0;
    }
    var r = function(t) {
        void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
    };
    function e(t, i, n) {
        if (!n) return i.indexOf(t);
        for(var r = 0; r < i.length; r++)if (n(t, i[r])) return r;
        return -1;
    }
    function a(t, i) {
        h(t, 0, t.children.length, i, t);
    }
    function h(t, i, n, r, e) {
        e || (e = p(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;
        for(var a = i; a < n; a++){
            var h = t.children[a];
            o(e, t.leaf ? r(h) : h);
        }
        return e;
    }
    function o(t, i) {
        return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
    }
    function s(t, i) {
        return t.minX - i.minX;
    }
    function l(t, i) {
        return t.minY - i.minY;
    }
    function f(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function u(t) {
        return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function m(t, i) {
        return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
    }
    function c(t, i) {
        return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
    }
    function p(t) {
        return {
            children: t,
            height: 1,
            leaf: !0,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
        };
    }
    function d(i, n, r, e, a) {
        for(var h = [
            n,
            r
        ]; h.length;)if (!((r = h.pop()) - (n = h.pop()) <= e)) {
            var o = n + Math.ceil((r - n) / e / 2) * e;
            t(i, o, n, r, a), h.push(n, o, o, r);
        }
    }
    return r.prototype.all = function() {
        return this._all(this.data, []);
    }, r.prototype.search = function(t) {
        var i = this.data, n = [];
        if (!c(t, i)) return n;
        for(var r = this.toBBox, e = []; i;){
            for(var a = 0; a < i.children.length; a++){
                var h = i.children[a], o = i.leaf ? r(h) : h;
                c(t, o) && (i.leaf ? n.push(h) : m(t, o) ? this._all(h, n) : e.push(h));
            }
            i = e.pop();
        }
        return n;
    }, r.prototype.collides = function(t) {
        var i = this.data;
        if (!c(t, i)) return !1;
        for(var n = []; i;){
            for(var r = 0; r < i.children.length; r++){
                var e = i.children[r], a = i.leaf ? this.toBBox(e) : e;
                if (c(t, a)) {
                    if (i.leaf || m(t, a)) return !0;
                    n.push(e);
                }
            }
            i = n.pop();
        }
        return !1;
    }, r.prototype.load = function(t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
            for(var i = 0; i < t.length; i++)this.insert(t[i]);
            return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length) {
            if (this.data.height === n.height) this._splitRoot(this.data, n);
            else {
                if (this.data.height < n.height) {
                    var r = this.data;
                    this.data = n, n = r;
                }
                this._insert(n, this.data.height - n.height - 1, !0);
            }
        } else this.data = n;
        return this;
    }, r.prototype.insert = function(t) {
        return t && this._insert(t, this.data.height - 1), this;
    }, r.prototype.clear = function() {
        return this.data = p([]), this;
    }, r.prototype.remove = function(t, i) {
        if (!t) return this;
        for(var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;){
            if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
                var f = e(t, h.children, i);
                if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
            }
            a || h.leaf || !m(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
        }
        return this;
    }, r.prototype.toBBox = function(t) {
        return t;
    }, r.prototype.compareMinX = function(t, i) {
        return t.minX - i.minX;
    }, r.prototype.compareMinY = function(t, i) {
        return t.minY - i.minY;
    }, r.prototype.toJSON = function() {
        return this.data;
    }, r.prototype.fromJSON = function(t) {
        return this.data = t, this;
    }, r.prototype._all = function(t, i) {
        for(var n = []; t;)t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
        return i;
    }, r.prototype._build = function(t, i, n, r) {
        var e, h = n - i + 1, o = this._maxEntries;
        if (h <= o) return a(e = p(t.slice(i, n + 1)), this.toBBox), e;
        r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p([])).leaf = !1, e.height = r;
        var s = Math.ceil(h / o), l = s * Math.ceil(Math.sqrt(o));
        d(t, i, n, l, this.compareMinX);
        for(var f = i; f <= n; f += l){
            var u = Math.min(f + l - 1, n);
            d(t, f, u, s, this.compareMinY);
            for(var m = f; m <= u; m += s){
                var c = Math.min(m + s - 1, u);
                e.children.push(this._build(t, m, c, r - 1));
            }
        }
        return a(e, this.toBBox), e;
    }, r.prototype._chooseSubtree = function(t, i, n, r) {
        for(; r.push(i), !i.leaf && r.length - 1 !== n;){
            for(var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++){
                var s = i.children[o], l = f(s), u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
                u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
            }
            i = h || i.children[0];
        }
        var m, c;
        return i;
    }, r.prototype._insert = function(t, i, n) {
        var r = n ? t : this.toBBox(t), e = [], a = this._chooseSubtree(r, this.data, i, e);
        for(a.children.push(t), o(a, r); i >= 0 && e[i].children.length > this._maxEntries;)this._split(e, i), i--;
        this._adjustParentBBoxes(r, e, i);
    }, r.prototype._split = function(t, i) {
        var n = t[i], r = n.children.length, e = this._minEntries;
        this._chooseSplitAxis(n, e, r);
        var h = this._chooseSplitIndex(n, e, r), o = p(n.children.splice(h, n.children.length - h));
        o.height = n.height, o.leaf = n.leaf, a(n, this.toBBox), a(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
    }, r.prototype._splitRoot = function(t, i) {
        this.data = p([
            t,
            i
        ]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
    }, r.prototype._chooseSplitIndex = function(t, i, n) {
        for(var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++){
            var d = h(t, 0, p, this.toBBox), x = h(t, p, n, this.toBBox), v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)), M = f(d) + f(x);
            v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
        }
        return r || n - i;
    }, r.prototype._chooseSplitAxis = function(t, i, n) {
        var r = t.leaf ? this.compareMinX : s, e = t.leaf ? this.compareMinY : l;
        this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
    }, r.prototype._allDistMargin = function(t, i, n, r) {
        t.children.sort(r);
        for(var e = this.toBBox, a = h(t, 0, i, e), s = h(t, n - i, n, e), l = u(a) + u(s), f = i; f < n - i; f++){
            var m = t.children[f];
            o(a, t.leaf ? e(m) : m), l += u(a);
        }
        for(var c = n - i - 1; c >= i; c--){
            var p = t.children[c];
            o(s, t.leaf ? e(p) : p), l += u(s);
        }
        return l;
    }, r.prototype._adjustParentBBoxes = function(t, i, n) {
        for(var r = n; r >= 0; r--)o(i[r], t);
    }, r.prototype._condense = function(t) {
        for(var i = t.length - 1, n = void 0; i >= 0; i--)0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a(t[i], this.toBBox);
    }, r;
});

},{}],"jGCUl":[function(require,module,exports) {
/**
 * @module ol/style/flat
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * For static styling, the [layer.setStyle()]{@link module:ol/layer/Vector~VectorLayer#setStyle} method
 * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.
 * @api
 *
 * @typedef {FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle} FlatStyle
 */ /**
 * A flat style literal or an array of the same.
 *
 * @typedef {FlatStyle|Array<FlatStyle>} FlatStyleLike
 */ /**
 * Fill style properties applied to polygon features.
 *
 * @typedef {Object} FlatFill
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [fill-color] The fill color.
 */ /**
 * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of
 * `stroke-color` or `stroke-width` must be provided.
 *
 * @typedef {Object} FlatStroke
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [stroke-color] The stroke color.
 * @property {number} [stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [stroke-line-dash] Line dash pattern.
 * @property {number} [stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [stroke-miter-limit=10] Miter limit.
 */ /**
 * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.
 *
 * @typedef {Object} FlatText
 * @property {string|Array<string>} [text-value] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {string} [text-font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [text-max-angle=Math.PI/4] When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [text-offset-x=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [text-offset-y=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [text-overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./Text.js").TextPlacement} [text-placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [text-scale] Scale.
 * @property {boolean} [text-rotate-with-view=false] Whether to rotate the text with the view.
 * @property {number} [text-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {CanvasTextAlign} [text-align] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `text-placement: 'point'`. For `text-placement: 'line'`, the default is to let the renderer choose a
 * placement where `text-max-angle` is not exceeded.
 * @property {import('./Text.js').TextJustify} [text-justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `text-justify` is ignored for immediate rendering and also for `text-placement: 'line'`.
 * @property {CanvasTextBaseline} [text-baseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {Array<number>} [text-padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-background-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-stroke-color] The stroke color.
 * @property {CanvasLineCap} [text-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [text-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [text-stroke-line-dash] Line dash pattern.
 * @property {number} [text-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [text-stroke-miter-limit=10] Miter limit.
 * @property {number} [text-stroke-width] Stroke pixel width.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [text-background-stroke-color] The stroke color.
 * @property {CanvasLineCap} [text-background-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [text-background-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [text-background-stroke-line-dash] Line dash pattern.
 * @property {number} [text-background-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [text-background-stroke-miter-limit=10] Miter limit.
 * @property {number} [text-background-stroke-width] Stroke pixel width.
 */ /**
 * Icon style properties applied to point features.  One of `icon-src` or `icon-img` must be provided to render
 * points with an icon.
 *
 * @typedef {Object} FlatIcon
 * @property {string} [icon-src] Image source URI.
 * @property {HTMLImageElement|HTMLCanvasElement} [icon-img] Image object for the icon. If the `icon-src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `icon-img-size` option.
 * @property {import("../size.js").Size} [icon-img-size] Image size in pixels. Only required if `icon-img` is set and `icon-src` is not.
 * The provided size needs to match the actual size of the image.
 * @property {Array<number>} [icon-anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./Icon.js").IconOrigin} [icon-anchor-origin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-x-units='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-y-units='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [icon-color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [icon-cross-origin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Array<number>} [icon-offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [icon-displacement=[0,0]] Displacement of the icon.
 * @property {import("./Icon.js").IconOrigin} [icon-offset-origin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [icon-opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [icon-scale=1] Scale.
 * @property {number} [icon-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [icon-rotate-with-view=false] Whether to rotate the icon with the view.
 * @property {import("../size.js").Size} [icon-size] Icon size in pixel. Can be used together with `icon-offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {"declutter"|"obstacle"|"none"|undefined} [icon-declutter-mode] Declutter mode
 */ /**
 * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.
 *
 * @typedef {Object} FlatShape
 * @property {number} [shape-points] Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [shape-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [shape-stroke-color] The stroke color.
 * @property {number} [shape-stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [shape-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [shape-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [shape-stroke-line-dash] Line dash pattern.
 * @property {number} [shape-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [shape-stroke-miter-limit=10] Miter limit.
 * @property {number} [shape-radius] Radius of a regular polygon.
 * @property {number} [shape-radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [shape-radius2] Second radius of a star.
 * @property {number} [shape-angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [shape-displacement=[0,0]] Displacement of the shape
 * @property {number} [shape-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [shape-rotate-with-view=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [shape-scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `shape-radius`, `shape-radius1` and `shape-radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [shape-declutter-mode] Declutter mode.
 */ /**
 * Circle style properties for rendering point features.  At least `circle-radius` must be provided.
 *
 * @typedef {Object} FlatCircle
 * @property {number} [circle-radius] Circle radius.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [circle-fill-color] The fill color.
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [circle-stroke-color] The stroke color.
 * @property {number} [circle-stroke-width] Stroke pixel width.
 * @property {CanvasLineCap} [circle-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [circle-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [circle-stroke-line-dash] Line dash pattern.
 * @property {number} [circle-stroke-line-dash-offset=0] Line dash offset.
 * @property {number} [circle-stroke-miter-limit=10] Miter limit.
 * @property {Array<number>} [circle-displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [circle-scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
 * @property {number} [circle-rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [circle-rotate-with-view=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [circle-declutter-mode] Declutter mode
 */ /**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @return {import("./Style.js").default} A style instance.
 */ parcelHelpers.export(exports, "toStyle", ()=>toStyle);
var _circleJs = require("../style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("./Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _regularShapeJs = require("./RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
var _strokeJs = require("./Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("./Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("./Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
function toStyle(flatStyle) {
    const style = new (0, _styleJsDefault.default)({
        fill: getFill(flatStyle, ""),
        stroke: getStroke(flatStyle, ""),
        text: getText(flatStyle),
        image: getImage(flatStyle)
    });
    return style;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @return {Fill|undefined} The fill (if any).
 */ function getFill(flatStyle, prefix) {
    const color = flatStyle[prefix + "fill-color"];
    if (!color) return;
    return new (0, _fillJsDefault.default)({
        color: color
    });
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @return {Stroke|undefined} The stroke (if any).
 */ function getStroke(flatStyle, prefix) {
    const width = flatStyle[prefix + "stroke-width"];
    const color = flatStyle[prefix + "stroke-color"];
    if (!width && !color) return;
    return new (0, _strokeJsDefault.default)({
        width: width,
        color: color,
        lineCap: flatStyle[prefix + "stroke-line-cap"],
        lineJoin: flatStyle[prefix + "stroke-line-join"],
        lineDash: flatStyle[prefix + "stroke-line-dash"],
        lineDashOffset: flatStyle[prefix + "stroke-line-dash-offset"],
        miterLimit: flatStyle[prefix + "stroke-miter-limit"]
    });
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @return {Text|undefined} The text (if any).
 */ function getText(flatStyle) {
    const value = flatStyle["text-value"];
    if (!value) return;
    const text = new (0, _textJsDefault.default)({
        text: value,
        font: flatStyle["text-font"],
        maxAngle: flatStyle["text-max-angle"],
        offsetX: flatStyle["text-offset-x"],
        offsetY: flatStyle["text-offset-y"],
        overflow: flatStyle["text-overflow"],
        placement: flatStyle["text-placement"],
        scale: flatStyle["text-scale"],
        rotateWithView: flatStyle["text-rotate-with-view"],
        rotation: flatStyle["text-rotation"],
        textAlign: flatStyle["text-align"],
        justify: flatStyle["text-justify"],
        textBaseline: flatStyle["text-baseline"],
        padding: flatStyle["text-padding"],
        fill: getFill(flatStyle, "text-"),
        backgroundFill: getFill(flatStyle, "text-background-"),
        stroke: getStroke(flatStyle, "text-"),
        backgroundStroke: getStroke(flatStyle, "text-background-")
    });
    return text;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @return {import("./Image.js").default|undefined} The image (if any).
 */ function getImage(flatStyle) {
    const iconSrc = flatStyle["icon-src"];
    const iconImg = flatStyle["icon-img"];
    if (iconSrc || iconImg) {
        const icon = new (0, _iconJsDefault.default)({
            src: iconSrc,
            img: iconImg,
            imgSize: flatStyle["icon-img-size"],
            anchor: flatStyle["icon-anchor"],
            anchorOrigin: flatStyle["icon-anchor-origin"],
            anchorXUnits: flatStyle["icon-anchor-x-units"],
            anchorYUnits: flatStyle["icon-anchor-y-units"],
            color: flatStyle["icon-color"],
            crossOrigin: flatStyle["icon-cross-origin"],
            offset: flatStyle["icon-offset"],
            displacement: flatStyle["icon-displacement"],
            opacity: flatStyle["icon-opacity"],
            scale: flatStyle["icon-scale"],
            rotation: flatStyle["icon-rotation"],
            rotateWithView: flatStyle["icon-rotate-with-view"],
            size: flatStyle["icon-size"],
            declutterMode: flatStyle["icon-declutter-mode"]
        });
        return icon;
    }
    const shapePoints = flatStyle["shape-points"];
    if (shapePoints) {
        const prefix = "shape-";
        const shape = new (0, _regularShapeJsDefault.default)({
            points: shapePoints,
            fill: getFill(flatStyle, prefix),
            stroke: getStroke(flatStyle, prefix),
            radius: flatStyle["shape-radius"],
            radius1: flatStyle["shape-radius1"],
            radius2: flatStyle["shape-radius2"],
            angle: flatStyle["shape-angle"],
            displacement: flatStyle["shape-displacement"],
            rotation: flatStyle["shape-rotation"],
            rotateWithView: flatStyle["shape-rotate-with-view"],
            scale: flatStyle["shape-scale"],
            declutterMode: flatStyle["shape-declutter-mode"]
        });
        return shape;
    }
    const circleRadius = flatStyle["circle-radius"];
    if (circleRadius) {
        const prefix1 = "circle-";
        const circle = new (0, _circleJsDefault.default)({
            radius: circleRadius,
            fill: getFill(flatStyle, prefix1),
            stroke: getStroke(flatStyle, prefix1),
            displacement: flatStyle["circle-displacement"],
            scale: flatStyle["circle-scale"],
            rotation: flatStyle["circle-rotation"],
            rotateWithView: flatStyle["circle-rotate-with-view"],
            declutterMode: flatStyle["circle-declutter-mode"]
        });
        return circle;
    }
    return;
}

},{"../style/Circle.js":"cSS3Y","./Fill.js":"4fB56","./Icon.js":"dJiIs","./RegularShape.js":"44xDg","./Stroke.js":"5Cq04","./Style.js":"fW7vC","./Text.js":"dwGM6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kTTmt":[function(require,module,exports) {
/**
 * @module ol/renderer/canvas/VectorLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderGroupJs = require("../../render/canvas/BuilderGroup.js");
var _builderGroupJsDefault = parcelHelpers.interopDefault(_builderGroupJs);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _executorGroupJs = require("../../render/canvas/ExecutorGroup.js");
var _executorGroupJsDefault = parcelHelpers.interopDefault(_executorGroupJs);
var _viewHintJs = require("../../ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hitdetectJs = require("../../render/canvas/hitdetect.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _domJs = require("../../dom.js");
var _vectorJs = require("../vector.js");
var _arrayJs = require("../../array.js");
var _projJs = require("../../proj.js");
var _utilJs = require("../../util.js");
var _coordinateJs = require("../../coordinate.js");
/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */ class CanvasVectorLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */ constructor(vectorLayer){
        super(vectorLayer);
        /** @private */ this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        /**
     * @type {boolean}
     */ this.animatingOrInteracting_;
        /**
     * @type {ImageData}
     */ this.hitDetectionImageData_ = null;
        /**
     * @type {Array<import("../../Feature.js").default>}
     */ this.renderedFeatures_ = null;
        /**
     * @private
     * @type {number}
     */ this.renderedRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.renderedResolution_ = NaN;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.renderedExtent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.wrappedRenderedExtent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {number}
     */ this.renderedRotation_;
        /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */ this.renderedCenter_ = null;
        /**
     * @private
     * @type {import("../../proj/Projection").default}
     */ this.renderedProjection_ = null;
        /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */ this.renderedRenderOrder_ = null;
        /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */ this.replayGroup_ = null;
        /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */ this.replayGroupChanged = true;
        /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */ this.declutterExecutorGroup = null;
        /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */ this.clipping = true;
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.compositionContext_ = null;
        /**
     * @private
     * @type {number}
     */ this.opacity_ = 1;
    }
    /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ renderWorlds(executorGroup, frameState, declutterTree) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[(0, _viewHintJsDefault.default).ANIMATING] || viewHints[(0, _viewHintJsDefault.default).INTERACTING]);
        const context = this.compositionContext_;
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? (0, _extentJs.getWidth)(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
            const transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
            executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, declutterTree);
        }while (++world < endWorld);
    }
    setupCompositionContext_() {
        if (this.opacity_ !== 1) {
            const compositionContext = (0, _domJs.createCanvasContext2D)(this.context.canvas.width, this.context.canvas.height, (0, _layerJs.canvasPool));
            this.compositionContext_ = compositionContext;
        } else this.compositionContext_ = this.context;
    }
    releaseCompositionContext_() {
        if (this.opacity_ !== 1) {
            const alpha = this.context.globalAlpha;
            this.context.globalAlpha = this.opacity_;
            this.context.drawImage(this.compositionContext_.canvas, 0, 0);
            this.context.globalAlpha = alpha;
            (0, _domJs.releaseCanvas)(this.compositionContext_);
            (0, _layerJs.canvasPool).push(this.compositionContext_.canvas);
            this.compositionContext_ = null;
        }
    }
    /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        if (this.declutterExecutorGroup) {
            this.setupCompositionContext_();
            this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
            this.releaseCompositionContext_();
        }
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */ renderFrame(frameState, target) {
        const pixelRatio = frameState.pixelRatio;
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        // set forward and inverse pixel transforms
        (0, _transformJs.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
        (0, _transformJs.makeInverse)(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = (0, _transformJs.toString)(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        const replayGroup = this.replayGroup_;
        const declutterExecutorGroup = this.declutterExecutorGroup;
        if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) return null;
        // resize and clear
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
            if (canvas.style.transform !== canvasTransform) canvas.style.transform = canvasTransform;
        } else if (!this.containerReused) context.clearRect(0, 0, width, height);
        this.preRender(context, frameState);
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        this.opacity_ = layerState.opacity;
        this.setupCompositionContext_();
        // clipped rendering if layer extent is set
        let clipped = false;
        let render = true;
        if (layerState.extent && this.clipping) {
            const layerExtent = (0, _projJs.fromUserExtent)(layerState.extent, projection);
            render = (0, _extentJs.intersects)(layerExtent, frameState.extent);
            clipped = render && !(0, _extentJs.containsExtent)(layerExtent, frameState.extent);
            if (clipped) this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
        }
        if (render) this.renderWorlds(replayGroup, frameState);
        if (clipped) this.compositionContext_.restore();
        this.releaseCompositionContext_();
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
            this.renderedRotation_ = viewState.rotation;
            this.hitDetectionImageData_ = null;
        }
        return this.container;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */ getFeatures(pixel) {
        return new Promise(/**
       * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
       * @this {CanvasVectorLayerRenderer}
       */ (function(resolve) {
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                const size = [
                    this.context.canvas.width,
                    this.context.canvas.height
                ];
                (0, _transformJs.apply)(this.pixelTransform, size);
                const center = this.renderedCenter_;
                const resolution = this.renderedResolution_;
                const rotation = this.renderedRotation_;
                const projection = this.renderedProjection_;
                const extent = this.wrappedRenderedExtent_;
                const layer = this.getLayer();
                const transforms = [];
                const width = size[0] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION);
                const height = size[1] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION);
                transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, 0).slice());
                const source = layer.getSource();
                const projectionExtent = projection.getExtent();
                if (source.getWrapX() && projection.canWrapX() && !(0, _extentJs.containsExtent)(projectionExtent, extent)) {
                    let startX = extent[0];
                    const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
                    let world = 0;
                    let offsetX;
                    while(startX < projectionExtent[0]){
                        --world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, offsetX).slice());
                        startX += worldWidth;
                    }
                    world = 0;
                    startX = extent[2];
                    while(startX > projectionExtent[2]){
                        ++world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, offsetX).slice());
                        startX -= worldWidth;
                    }
                }
                this.hitDetectionImageData_ = (0, _hitdetectJs.createHitDetectionImageData)(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
            }
            resolve((0, _hitdetectJs.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
        }).bind(this));
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) return undefined;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */ const features = {};
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */ const featureCallback = function(feature, geometry, distanceSq) {
            const key = (0, _utilJs.getUid)(feature);
            const match = features[key];
            if (!match) {
                if (distanceSq === 0) {
                    features[key] = true;
                    return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                    feature: feature,
                    layer: layer,
                    geometry: geometry,
                    distanceSq: distanceSq,
                    callback: callback
                });
            } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                    features[key] = true;
                    matches.splice(matches.lastIndexOf(match), 1);
                    return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
            }
            return undefined;
        };
        let result;
        const executorGroups = [
            this.replayGroup_
        ];
        if (this.declutterExecutorGroup) executorGroups.push(this.declutterExecutorGroup);
        executorGroups.some((executorGroup)=>{
            return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item)=>item.value) : null);
        });
        return result;
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */ handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) layer.changed();
    }
    /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */ handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) return false;
        const animating = frameState.viewHints[(0, _viewHintJsDefault.default).ANIMATING];
        const interacting = frameState.viewHints[(0, _viewHintJsDefault.default).INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
            this.animatingOrInteracting_ = true;
            return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === undefined) vectorLayerRenderOrder = (0, _vectorJs.defaultOrder);
        const center = viewState.center.slice();
        const extent = (0, _extentJs.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
        const renderedExtent = extent.slice();
        const loadExtents = [
            extent.slice()
        ];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !(0, _extentJs.containsExtent)(projectionExtent, frameState.extent)) {
            // For the replay group, we need an extent that intersects the real world
            // (-180° to +180°). To support geometries in a coordinate range from -540°
            // to +540°, we add at least 1 world width on each side of the projection
            // extent. If the viewport is wider than the world, we need to add half of
            // the viewport width to make sure we cover the whole viewport.
            const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
            const gutter = Math.max((0, _extentJs.getWidth)(extent) / 2, worldWidth);
            extent[0] = projectionExtent[0] - gutter;
            extent[2] = projectionExtent[2] + gutter;
            (0, _coordinateJs.wrapX)(center, projection);
            const loadExtent = (0, _extentJs.wrapX)(loadExtents[0], projection);
            // If the extent crosses the date line, we load data for both edges of the worlds
            if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) loadExtents.push([
                loadExtent[0] + worldWidth,
                loadExtent[1],
                loadExtent[2] + worldWidth,
                loadExtent[3]
            ]);
            else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) loadExtents.push([
                loadExtent[0] - worldWidth,
                loadExtent[1],
                loadExtent[2] - worldWidth,
                loadExtent[3]
            ]);
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && (0, _extentJs.containsExtent)(this.wrappedRenderedExtent_, extent)) {
            if (!(0, _arrayJs.equals)(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
            }
            this.renderedCenter_ = center;
            this.replayGroupChanged = false;
            return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new (0, _builderGroupJsDefault.default)((0, _vectorJs.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
        let declutterBuilderGroup;
        if (this.getLayer().getDeclutter()) declutterBuilderGroup = new (0, _builderGroupJsDefault.default)((0, _vectorJs.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
        const userProjection = (0, _projJs.getUserProjection)();
        let userTransform;
        if (userProjection) {
            for(let i = 0, ii = loadExtents.length; i < ii; ++i){
                const extent1 = loadExtents[i];
                const userExtent = (0, _projJs.toUserExtent)(extent1, projection);
                vectorSource.loadFeatures(userExtent, (0, _projJs.toUserResolution)(resolution, projection), userProjection);
            }
            userTransform = (0, _projJs.getTransformFromProjections)(userProjection, projection);
        } else for(let i1 = 0, ii1 = loadExtents.length; i1 < ii1; ++i1)vectorSource.loadFeatures(loadExtents[i1], resolution, projection);
        const squaredTolerance = (0, _vectorJs.getSquaredTolerance)(resolution, pixelRatio);
        let ready = true;
        const render = /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @this {CanvasVectorLayerRenderer}
       */ (function(feature) {
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) styles = styleFunction(feature, resolution);
            if (styles) {
                const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                ready = ready && !dirty;
            }
        }).bind(this);
        const userExtent1 = (0, _projJs.toUserExtent)(extent, projection);
        /** @type {Array<import("../../Feature.js").default>} */ const features = vectorSource.getFeaturesInExtent(userExtent1);
        if (vectorLayerRenderOrder) features.sort(vectorLayerRenderOrder);
        for(let i2 = 0, ii2 = features.length; i2 < ii2; ++i2)render(features[i2]);
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new (0, _executorGroupJsDefault.default)(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
        if (declutterBuilderGroup) this.declutterExecutorGroup = new (0, _executorGroupJsDefault.default)(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
    }
    /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */ renderFeature(feature, squaredTolerance, styles, builderGroup, transform, declutterBuilderGroup) {
        if (!styles) return false;
        let loading = false;
        if (Array.isArray(styles)) for(let i = 0, ii = styles.length; i < ii; ++i)loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup) || loading;
        else loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup);
        return loading;
    }
}
exports.default = CanvasVectorLayerRenderer;

},{"../../render/canvas/BuilderGroup.js":"kQbDd","./Layer.js":"fY3ny","../../render/canvas/ExecutorGroup.js":"eUidV","../../ViewHint.js":"6THmF","../../render/canvas/hitdetect.js":"hriIE","../../transform.js":"1BqUf","../../extent.js":"6YrVc","../../dom.js":"84QzQ","../vector.js":"liv8a","../../array.js":"1Fbic","../../proj.js":"SznqC","../../util.js":"pLBjQ","../../coordinate.js":"85Vu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kQbDd":[function(require,module,exports) {
/**
 * @module ol/render/canvas/BuilderGroup
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _imageBuilderJs = require("./ImageBuilder.js");
var _imageBuilderJsDefault = parcelHelpers.interopDefault(_imageBuilderJs);
var _lineStringBuilderJs = require("./LineStringBuilder.js");
var _lineStringBuilderJsDefault = parcelHelpers.interopDefault(_lineStringBuilderJs);
var _polygonBuilderJs = require("./PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _textBuilderJs = require("./TextBuilder.js");
var _textBuilderJsDefault = parcelHelpers.interopDefault(_textBuilderJs);
/**
 * @type {Object<import("../canvas.js").BuilderType, typeof Builder>}
 */ const BATCH_CONSTRUCTORS = {
    "Circle": (0, _polygonBuilderJsDefault.default),
    "Default": (0, _builderJsDefault.default),
    "Image": (0, _imageBuilderJsDefault.default),
    "LineString": (0, _lineStringBuilderJsDefault.default),
    "Polygon": (0, _polygonBuilderJsDefault.default),
    "Text": (0, _textBuilderJsDefault.default)
};
class BuilderGroup {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        /**
     * @private
     * @type {number}
     */ this.tolerance_ = tolerance;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent_ = maxExtent;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.resolution_ = resolution;
        /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */ this.buildersByZIndex_ = {};
    }
    /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */ finish() {
        const builderInstructions = {};
        for(const zKey in this.buildersByZIndex_){
            builderInstructions[zKey] = builderInstructions[zKey] || {};
            const builders = this.buildersByZIndex_[zKey];
            for(const builderKey in builders){
                const builderInstruction = builders[builderKey].finish();
                builderInstructions[zKey][builderKey] = builderInstruction;
            }
        }
        return builderInstructions;
    }
    /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */ getBuilder(zIndex, builderType) {
        const zIndexKey = zIndex !== undefined ? zIndex.toString() : "0";
        let replays = this.buildersByZIndex_[zIndexKey];
        if (replays === undefined) {
            replays = {};
            this.buildersByZIndex_[zIndexKey] = replays;
        }
        let replay = replays[builderType];
        if (replay === undefined) {
            const Constructor = BATCH_CONSTRUCTORS[builderType];
            replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
            replays[builderType] = replay;
        }
        return replay;
    }
}
exports.default = BuilderGroup;

},{"./Builder.js":"aCopB","./ImageBuilder.js":"jkri9","./LineStringBuilder.js":"cuNSN","./PolygonBuilder.js":"992jH","./TextBuilder.js":"6mvke","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aCopB":[function(require,module,exports) {
/**
 * @module ol/render/canvas/Builder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _relationshipJs = require("../../extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _inflateJs = require("../../geom/flat/inflate.js");
class CanvasBuilder extends (0, _vectorContextJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super();
        /**
     * @protected
     * @type {number}
     */ this.tolerance = tolerance;
        /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent = maxExtent;
        /**
     * @protected
     * @type {number}
     */ this.pixelRatio = pixelRatio;
        /**
     * @protected
     * @type {number}
     */ this.maxLineWidth = 0;
        /**
     * @protected
     * @const
     * @type {number}
     */ this.resolution = resolution;
        /**
     * @private
     * @type {Array<*>}
     */ this.beginGeometryInstruction1_ = null;
        /**
     * @private
     * @type {Array<*>}
     */ this.beginGeometryInstruction2_ = null;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.bufferedMaxExtent_ = null;
        /**
     * @protected
     * @type {Array<*>}
     */ this.instructions = [];
        /**
     * @protected
     * @type {Array<number>}
     */ this.coordinates = [];
        /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */ this.tmpCoordinate_ = [];
        /**
     * @protected
     * @type {Array<*>}
     */ this.hitDetectionInstructions = [];
        /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */ this.state = /** @type {import("../canvas.js").FillStrokeState} */ {};
    }
    /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */ applyPixelRatio(dashArray) {
        const pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
            return dash * pixelRatio;
        });
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */ appendFlatPointCoordinates(flatCoordinates, stride) {
        const extent = this.getBufferedMaxExtent();
        const tmpCoord = this.tmpCoordinate_;
        const coordinates = this.coordinates;
        let myEnd = coordinates.length;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            tmpCoord[0] = flatCoordinates[i];
            tmpCoord[1] = flatCoordinates[i + 1];
            if ((0, _extentJs.containsCoordinate)(extent, tmpCoord)) {
                coordinates[myEnd++] = tmpCoord[0];
                coordinates[myEnd++] = tmpCoord[1];
            }
        }
        return myEnd;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */ appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
        const coordinates = this.coordinates;
        let myEnd = coordinates.length;
        const extent = this.getBufferedMaxExtent();
        if (skipFirst) offset += stride;
        let lastXCoord = flatCoordinates[offset];
        let lastYCoord = flatCoordinates[offset + 1];
        const nextCoord = this.tmpCoordinate_;
        let skipped = true;
        let i, lastRel, nextRel;
        for(i = offset + stride; i < end; i += stride){
            nextCoord[0] = flatCoordinates[i];
            nextCoord[1] = flatCoordinates[i + 1];
            nextRel = (0, _extentJs.coordinateRelationship)(extent, nextCoord);
            if (nextRel !== lastRel) {
                if (skipped) {
                    coordinates[myEnd++] = lastXCoord;
                    coordinates[myEnd++] = lastYCoord;
                    skipped = false;
                }
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
            } else if (nextRel === (0, _relationshipJsDefault.default).INTERSECTING) {
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
                skipped = false;
            } else skipped = true;
            lastXCoord = nextCoord[0];
            lastYCoord = nextCoord[1];
            lastRel = nextRel;
        }
        // Last coordinate equals first or only one point to append:
        if (closed && skipped || i === offset + stride) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
        }
        return myEnd;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */ drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            builderEnds.push(builderEnd);
            offset = end;
        }
        return offset;
    }
    /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */ drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
        this.beginGeometry(geometry, feature);
        const type = geometry.getType();
        const stride = geometry.getStride();
        const builderBegin = this.coordinates.length;
        let flatCoordinates, builderEnd, builderEnds, builderEndss;
        let offset;
        switch(type){
            case "MultiPolygon":
                flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getOrientedFlatCoordinates();
                builderEndss = [];
                const endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
                offset = 0;
                for(let i = 0, ii = endss.length; i < ii; ++i){
                    const myEnds = [];
                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                    builderEndss.push(myEnds);
                }
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateMultiCoordinatesArray)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateMultiCoordinatesArray)
                ]);
                break;
            case "Polygon":
            case "MultiLineString":
                builderEnds = [];
                flatCoordinates = type == "Polygon" ? /** @type {import("../../geom/Polygon.js").default} */ geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
                offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ geometry.getEnds(), stride, builderEnds);
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateCoordinatesArray)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateCoordinatesArray)
                ]);
                break;
            case "LineString":
            case "Circle":
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateCoordinates)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateCoordinates)
                ]);
                break;
            case "MultiPoint":
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (builderEnd > builderBegin) {
                    this.instructions.push([
                        (0, _instructionJsDefault.default).CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        renderer,
                        (0, _inflateJs.inflateCoordinates)
                    ]);
                    this.hitDetectionInstructions.push([
                        (0, _instructionJsDefault.default).CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        hitDetectionRenderer || renderer,
                        (0, _inflateJs.inflateCoordinates)
                    ]);
                }
                break;
            case "Point":
                flatCoordinates = geometry.getFlatCoordinates();
                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                builderEnd = this.coordinates.length;
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer
                ]);
                break;
            default:
        }
        this.endGeometry(feature);
    }
    /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ beginGeometry(geometry, feature) {
        this.beginGeometryInstruction1_ = [
            (0, _instructionJsDefault.default).BEGIN_GEOMETRY,
            feature,
            0,
            geometry
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
            (0, _instructionJsDefault.default).BEGIN_GEOMETRY,
            feature,
            0,
            geometry
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        return {
            instructions: this.instructions,
            hitDetectionInstructions: this.hitDetectionInstructions,
            coordinates: this.coordinates
        };
    }
    /**
   * Reverse the hit detection instructions.
   */ reverseHitDetectionInstructions() {
        const hitDetectionInstructions = this.hitDetectionInstructions;
        // step 1 - reverse array
        hitDetectionInstructions.reverse();
        // step 2 - reverse instructions within geometry blocks
        let i;
        const n = hitDetectionInstructions.length;
        let instruction;
        let type;
        let begin = -1;
        for(i = 0; i < n; ++i){
            instruction = hitDetectionInstructions[i];
            type = /** @type {import("./Instruction.js").default} */ instruction[0];
            if (type == (0, _instructionJsDefault.default).END_GEOMETRY) begin = i;
            else if (type == (0, _instructionJsDefault.default).BEGIN_GEOMETRY) {
                instruction[2] = i;
                (0, _arrayJs.reverseSubArray)(this.hitDetectionInstructions, begin, i);
                begin = -1;
            }
        }
    }
    /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {
        const state = this.state;
        if (fillStyle) {
            const fillStyleColor = fillStyle.getColor();
            state.fillStyle = (0, _colorlikeJs.asColorLike)(fillStyleColor ? fillStyleColor : (0, _canvasJs.defaultFillStyle));
        } else state.fillStyle = undefined;
        if (strokeStyle) {
            const strokeStyleColor = strokeStyle.getColor();
            state.strokeStyle = (0, _colorlikeJs.asColorLike)(strokeStyleColor ? strokeStyleColor : (0, _canvasJs.defaultStrokeStyle));
            const strokeStyleLineCap = strokeStyle.getLineCap();
            state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : (0, _canvasJs.defaultLineCap);
            const strokeStyleLineDash = strokeStyle.getLineDash();
            state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : (0, _canvasJs.defaultLineDash);
            const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset);
            const strokeStyleLineJoin = strokeStyle.getLineJoin();
            state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : (0, _canvasJs.defaultLineJoin);
            const strokeStyleWidth = strokeStyle.getWidth();
            state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : (0, _canvasJs.defaultLineWidth);
            const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit);
            if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                // invalidate the buffered max extent cache
                this.bufferedMaxExtent_ = null;
            }
        } else {
            state.strokeStyle = undefined;
            state.lineCap = undefined;
            state.lineDash = null;
            state.lineDashOffset = undefined;
            state.lineJoin = undefined;
            state.lineWidth = undefined;
            state.miterLimit = undefined;
        }
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */ createFill(state) {
        const fillStyle = state.fillStyle;
        /** @type {Array<*>} */ const fillInstruction = [
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            fillStyle
        ];
        if (typeof fillStyle !== "string") // Fill is a pattern or gradient - align it!
        fillInstruction.push(true);
        return fillInstruction;
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */ applyStroke(state) {
        this.instructions.push(this.createStroke(state));
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */ createStroke(state) {
        return [
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth * this.pixelRatio,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            this.applyPixelRatio(state.lineDash),
            state.lineDashOffset * this.pixelRatio
        ];
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */ updateFillStyle(state, createFill) {
        const fillStyle = state.fillStyle;
        if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
            if (fillStyle !== undefined) this.instructions.push(createFill.call(this, state));
            state.currentFillStyle = fillStyle;
        }
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */ updateStrokeStyle(state, applyStroke) {
        const strokeStyle = state.strokeStyle;
        const lineCap = state.lineCap;
        const lineDash = state.lineDash;
        const lineDashOffset = state.lineDashOffset;
        const lineJoin = state.lineJoin;
        const lineWidth = state.lineWidth;
        const miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0, _arrayJs.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
            if (strokeStyle !== undefined) applyStroke.call(this, state);
            state.currentStrokeStyle = strokeStyle;
            state.currentLineCap = lineCap;
            state.currentLineDash = lineDash;
            state.currentLineDashOffset = lineDashOffset;
            state.currentLineJoin = lineJoin;
            state.currentLineWidth = lineWidth;
            state.currentMiterLimit = miterLimit;
        }
    }
    /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ endGeometry(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        const endGeometryInstruction = [
            (0, _instructionJsDefault.default).END_GEOMETRY,
            feature
        ];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
    }
    /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */ getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_) {
            this.bufferedMaxExtent_ = (0, _extentJs.clone)(this.maxExtent);
            if (this.maxLineWidth > 0) {
                const width = this.resolution * (this.maxLineWidth + 1) / 2;
                (0, _extentJs.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
            }
        }
        return this.bufferedMaxExtent_;
    }
}
exports.default = CanvasBuilder;

},{"./Instruction.js":"9nhw8","../../extent/Relationship.js":"9q0e7","../VectorContext.js":"ezpza","../../colorlike.js":"ftcFo","../../extent.js":"6YrVc","../canvas.js":"e85iQ","../../array.js":"1Fbic","../../geom/flat/inflate.js":"4Rpju","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9nhw8":[function(require,module,exports) {
/**
 * @module ol/render/canvas/Instruction
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fillInstruction", ()=>fillInstruction);
parcelHelpers.export(exports, "strokeInstruction", ()=>strokeInstruction);
parcelHelpers.export(exports, "beginPathInstruction", ()=>beginPathInstruction);
parcelHelpers.export(exports, "closePathInstruction", ()=>closePathInstruction);
const Instruction = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
};
const fillInstruction = [
    Instruction.FILL
];
const strokeInstruction = [
    Instruction.STROKE
];
const beginPathInstruction = [
    Instruction.BEGIN_PATH
];
const closePathInstruction = [
    Instruction.CLOSE_PATH
];
exports.default = Instruction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ezpza":[function(require,module,exports) {
/**
 * @module ol/render/VectorContext
 */ /**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class VectorContext {
    /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */ drawCustom(geometry, feature, renderer, hitDetectionRenderer) {}
    /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */ drawGeometry(geometry) {}
    /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */ setStyle(style) {}
    /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */ drawCircle(circleGeometry, feature) {}
    /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */ drawFeature(feature, style) {}
    /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */ drawGeometryCollection(geometryCollectionGeometry, feature) {}
    /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawLineString(lineStringGeometry, feature) {}
    /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiLineString(multiLineStringGeometry, feature) {}
    /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPoint(multiPointGeometry, feature) {}
    /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPolygon(multiPolygonGeometry, feature) {}
    /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawPoint(pointGeometry, feature) {}
    /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawPolygon(polygonGeometry, feature) {}
    /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawText(geometry, feature) {}
    /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {}
    /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */ setImageStyle(imageStyle, declutterImageWithText) {}
    /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */ setTextStyle(textStyle, declutterImageWithText) {}
}
exports.default = VectorContext;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jkri9":[function(require,module,exports) {
/**
 * @module ol/render/canvas/ImageBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
class CanvasImageBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
        /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */ this.hitDetectionImage_ = null;
        /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */ this.image_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.imagePixelRatio_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.anchorX_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.anchorY_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.height_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.opacity_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.originX_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.originY_ = undefined;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.rotateWithView_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = undefined;
        /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */ this.scale_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.width_ = undefined;
        /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */ this.declutterMode_ = undefined;
        /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */ this.declutterImageWithText_ = undefined;
    }
    /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawPoint(pointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(pointGeometry, feature);
        const flatCoordinates = pointGeometry.getFlatCoordinates();
        const stride = pointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_ * this.imagePixelRatio_,
            this.originY_ * this.imagePixelRatio_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPoint(multiPointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(multiPointGeometry, feature);
        const flatCoordinates = multiPointGeometry.getFlatCoordinates();
        const stride = multiPointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_ * this.imagePixelRatio_,
            this.originY_ * this.imagePixelRatio_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        this.reverseHitDetectionInstructions();
        // FIXME this doesn't really protect us against further calls to draw*Geometry
        this.anchorX_ = undefined;
        this.anchorY_ = undefined;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = undefined;
        this.height_ = undefined;
        this.scale_ = undefined;
        this.opacity_ = undefined;
        this.originX_ = undefined;
        this.originY_ = undefined;
        this.rotateWithView_ = undefined;
        this.rotation_ = undefined;
        this.width_ = undefined;
        return super.finish();
    }
    /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */ setImageStyle(imageStyle, sharedData) {
        const anchor = imageStyle.getAnchor();
        const size = imageStyle.getSize();
        const origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
        this.image_ = imageStyle.getImage(this.pixelRatio);
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterMode_ = imageStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
    }
}
exports.default = CanvasImageBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cuNSN":[function(require,module,exports) {
/**
 * @module ol/render/canvas/LineStringBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
class CanvasLineStringBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */ drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        const moveToLineToInstruction = [
            (0, _instructionJsDefault.default).MOVE_TO_LINE_TO,
            myBegin,
            myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
    }
    /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawLineString(lineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ], (0, _instructionJs.beginPathInstruction));
        const flatCoordinates = lineStringGeometry.getFlatCoordinates();
        const stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
        this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiLineString(multiLineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset
        ], (0, _instructionJs.beginPathInstruction));
        const ends = multiLineStringGeometry.getEnds();
        const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        const stride = multiLineStringGeometry.getStride();
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.drawFlatCoordinates_(flatCoordinates, offset, /** @type {number} */ ends[i], stride);
        this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        const state = this.state;
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) this.instructions.push((0, _instructionJs.strokeInstruction));
        this.reverseHitDetectionInstructions();
        this.state = null;
        return super.finish();
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */ applyStroke(state) {
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        super.applyStroke(state);
        this.instructions.push((0, _instructionJs.beginPathInstruction));
    }
}
exports.default = CanvasLineStringBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","../canvas.js":"e85iQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"992jH":[function(require,module,exports) {
/**
 * @module ol/render/canvas/PolygonBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
var _simplifyJs = require("../../geom/flat/simplify.js");
class CanvasPolygonBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */ drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
        const state = this.state;
        const fill = state.fillStyle !== undefined;
        const stroke = state.strokeStyle !== undefined;
        const numEnds = ends.length;
        this.instructions.push((0, _instructionJs.beginPathInstruction));
        this.hitDetectionInstructions.push((0, _instructionJs.beginPathInstruction));
        for(let i = 0; i < numEnds; ++i){
            const end = ends[i];
            const myBegin = this.coordinates.length;
            const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
            const moveToLineToInstruction = [
                (0, _instructionJsDefault.default).MOVE_TO_LINE_TO,
                myBegin,
                myEnd
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            if (stroke) {
                // Performance optimization: only call closePath() when we have a stroke.
                // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
                this.instructions.push((0, _instructionJs.closePathInstruction));
                this.hitDetectionInstructions.push((0, _instructionJs.closePathInstruction));
            }
            offset = end;
        }
        if (fill) {
            this.instructions.push((0, _instructionJs.fillInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.fillInstruction));
        }
        if (stroke) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        }
        return offset;
    }
    /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */ drawCircle(circleGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset
        ]);
        const flatCoordinates = circleGeometry.getFlatCoordinates();
        const stride = circleGeometry.getStride();
        const myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        const circleInstruction = [
            (0, _instructionJsDefault.default).CIRCLE,
            myBegin
        ];
        this.instructions.push((0, _instructionJs.beginPathInstruction), circleInstruction);
        this.hitDetectionInstructions.push((0, _instructionJs.beginPathInstruction), circleInstruction);
        if (state.fillStyle !== undefined) {
            this.instructions.push((0, _instructionJs.fillInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.fillInstruction));
        }
        if (state.strokeStyle !== undefined) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        }
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawPolygon(polygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset
        ]);
        const ends = polygonGeometry.getEnds();
        const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        const stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ ends, stride);
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPolygon(multiPolygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset
        ]);
        const endss = multiPolygonGeometry.getEndss();
        const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        const stride = multiPolygonGeometry.getStride();
        let offset = 0;
        for(let i = 0, ii = endss.length; i < ii; ++i)offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        // We want to preserve topology when drawing polygons.  Polygons are
        // simplified using quantization and point elimination. However, we might
        // have received a mix of quantized and non-quantized geometries, so ensure
        // that all are quantized by quantizing all coordinates in the batch.
        const tolerance = this.tolerance;
        if (tolerance !== 0) {
            const coordinates = this.coordinates;
            for(let i = 0, ii = coordinates.length; i < ii; ++i)coordinates[i] = (0, _simplifyJs.snap)(coordinates[i], tolerance);
        }
        return super.finish();
    }
    /**
   * @private
   */ setFillStrokeStyles_() {
        const state = this.state;
        const fillStyle = state.fillStyle;
        if (fillStyle !== undefined) this.updateFillStyle(state, this.createFill);
        if (state.strokeStyle !== undefined) this.updateStrokeStyle(state, this.applyStroke);
    }
}
exports.default = CanvasPolygonBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","../canvas.js":"e85iQ","../../geom/flat/simplify.js":"jsqc5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mvke":[function(require,module,exports) {
/**
 * @module ol/render/canvas/TextBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TEXT_ALIGN", ()=>TEXT_ALIGN);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _colorlikeJs = require("../../colorlike.js");
var _canvasJs = require("../canvas.js");
var _utilJs = require("../../util.js");
var _extentJs = require("../../extent.js");
var _straightchunkJs = require("../../geom/flat/straightchunk.js");
const TEXT_ALIGN = {
    "left": 0,
    "end": 0,
    "center": 0.5,
    "right": 1,
    "start": 1,
    "top": 0,
    "middle": 0.5,
    "hanging": 0.2,
    "alphabetic": 0.8,
    "ideographic": 0.8,
    "bottom": 1
};
class CanvasTextBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
        /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */ this.labels_ = null;
        /**
     * @private
     * @type {string|Array<string>}
     */ this.text_ = "";
        /**
     * @private
     * @type {number}
     */ this.textOffsetX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.textOffsetY_ = 0;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.textRotateWithView_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.textRotation_ = 0;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.textFillState_ = null;
        /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */ this.fillStates = {};
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.textStrokeState_ = null;
        /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */ this.strokeStates = {};
        /**
     * @private
     * @type {import("../canvas.js").TextState}
     */ this.textState_ = /** @type {import("../canvas.js").TextState} */ {};
        /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */ this.textStates = {};
        /**
     * @private
     * @type {string}
     */ this.textKey_ = "";
        /**
     * @private
     * @type {string}
     */ this.fillKey_ = "";
        /**
     * @private
     * @type {string}
     */ this.strokeKey_ = "";
        /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */ this.declutterImageWithText_ = undefined;
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        const instructions = super.finish();
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
    }
    /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawText(geometry, feature) {
        const fillState = this.textFillState_;
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        if (this.text_ === "" || !textState || !fillState && !strokeState) return;
        const coordinates = this.coordinates;
        let begin = coordinates.length;
        const geometryType = geometry.getType();
        let flatCoordinates = null;
        let stride = geometry.getStride();
        if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
            if (!(0, _extentJs.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) return;
            let ends;
            flatCoordinates = geometry.getFlatCoordinates();
            if (geometryType == "LineString") ends = [
                flatCoordinates.length
            ];
            else if (geometryType == "MultiLineString") ends = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getEnds();
            else if (geometryType == "Polygon") ends = /** @type {import("../../geom/Polygon.js").default} */ geometry.getEnds().slice(0, 1);
            else if (geometryType == "MultiPolygon") {
                const endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
                ends = [];
                for(let i = 0, ii = endss.length; i < ii; ++i)ends.push(endss[i][0]);
            }
            this.beginGeometry(geometry, feature);
            const textAlign = textState.textAlign;
            // No `justify` support for line placement.
            let flatOffset = 0;
            let flatEnd;
            for(let o = 0, oo = ends.length; o < oo; ++o){
                if (textAlign == undefined) {
                    const range = (0, _straightchunkJs.matchingChunk)(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                    flatOffset = range[0];
                    flatEnd = range[1];
                } else flatEnd = ends[o];
                for(let i1 = flatOffset; i1 < flatEnd; i1 += stride)coordinates.push(flatCoordinates[i1], flatCoordinates[i1 + 1]);
                const end = coordinates.length;
                flatOffset = ends[o];
                this.drawChars_(begin, end);
                begin = end;
            }
            this.endGeometry(feature);
        } else {
            let geometryWidths = textState.overflow ? null : [];
            switch(geometryType){
                case "Point":
                case "MultiPoint":
                    flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ geometry.getFlatCoordinates();
                    break;
                case "LineString":
                    flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ geometry.getFlatMidpoint();
                    break;
                case "Circle":
                    flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ geometry.getCenter();
                    break;
                case "MultiLineString":
                    flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getFlatMidpoints();
                    stride = 2;
                    break;
                case "Polygon":
                    flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ geometry.getFlatInteriorPoint();
                    if (!textState.overflow) geometryWidths.push(flatCoordinates[2] / this.resolution);
                    stride = 3;
                    break;
                case "MultiPolygon":
                    const interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getFlatInteriorPoints();
                    flatCoordinates = [];
                    for(let i2 = 0, ii1 = interiorPoints.length; i2 < ii1; i2 += 3){
                        if (!textState.overflow) geometryWidths.push(interiorPoints[i2 + 2] / this.resolution);
                        flatCoordinates.push(interiorPoints[i2], interiorPoints[i2 + 1]);
                    }
                    if (flatCoordinates.length === 0) return;
                    stride = 2;
                    break;
                default:
            }
            const end1 = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (end1 === begin) return;
            if (geometryWidths && (end1 - begin) / 2 !== flatCoordinates.length / stride) {
                let beg = begin / 2;
                geometryWidths = geometryWidths.filter((w, i)=>{
                    const keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
                    if (!keep) --beg;
                    return keep;
                });
            }
            this.saveTextStates_();
            if (textState.backgroundFill || textState.backgroundStroke) {
                this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                if (textState.backgroundFill) {
                    this.updateFillStyle(this.state, this.createFill);
                    this.hitDetectionInstructions.push(this.createFill(this.state));
                }
                if (textState.backgroundStroke) {
                    this.updateStrokeStyle(this.state, this.applyStroke);
                    this.hitDetectionInstructions.push(this.createStroke(this.state));
                }
            }
            this.beginGeometry(geometry, feature);
            // adjust padding for negative scale
            let padding = textState.padding;
            if (padding != (0, _canvasJs.defaultPadding) && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                let p0 = textState.padding[0];
                let p1 = textState.padding[1];
                let p2 = textState.padding[2];
                let p3 = textState.padding[3];
                if (textState.scale[0] < 0) {
                    p1 = -p1;
                    p3 = -p3;
                }
                if (textState.scale[1] < 0) {
                    p0 = -p0;
                    p2 = -p2;
                }
                padding = [
                    p0,
                    p1,
                    p2,
                    p3
                ];
            }
            // The image is unknown at this stage so we pass null; it will be computed at render time.
            // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
            // render time.
            const pixelRatio = this.pixelRatio;
            this.instructions.push([
                (0, _instructionJsDefault.default).DRAW_IMAGE,
                begin,
                end1,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    1,
                    1
                ],
                NaN,
                undefined,
                this.declutterImageWithText_,
                padding == (0, _canvasJs.defaultPadding) ? (0, _canvasJs.defaultPadding) : padding.map(function(p) {
                    return p * pixelRatio;
                }),
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
            ]);
            const scale = 1 / pixelRatio;
            this.hitDetectionInstructions.push([
                (0, _instructionJsDefault.default).DRAW_IMAGE,
                begin,
                end1,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    scale,
                    scale
                ],
                NaN,
                undefined,
                this.declutterImageWithText_,
                padding,
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
            ]);
            this.endGeometry(feature);
        }
    }
    /**
   * @private
   */ saveTextStates_() {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const fillState = this.textFillState_;
        const strokeKey = this.strokeKey_;
        if (strokeState) {
            if (!(strokeKey in this.strokeStates)) this.strokeStates[strokeKey] = {
                strokeStyle: strokeState.strokeStyle,
                lineCap: strokeState.lineCap,
                lineDashOffset: strokeState.lineDashOffset,
                lineWidth: strokeState.lineWidth,
                lineJoin: strokeState.lineJoin,
                miterLimit: strokeState.miterLimit,
                lineDash: strokeState.lineDash
            };
        }
        const textKey = this.textKey_;
        if (!(textKey in this.textStates)) this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || (0, _canvasJs.defaultTextAlign),
            justify: textState.justify,
            textBaseline: textState.textBaseline || (0, _canvasJs.defaultTextBaseline),
            scale: textState.scale
        };
        const fillKey = this.fillKey_;
        if (fillState) {
            if (!(fillKey in this.fillStates)) this.fillStates[fillKey] = {
                fillStyle: fillState.fillStyle
            };
        }
    }
    /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */ drawChars_(begin, end) {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const strokeKey = this.strokeKey_;
        const textKey = this.textKey_;
        const fillKey = this.fillKey_;
        this.saveTextStates_();
        const pixelRatio = this.pixelRatio;
        const baseline = TEXT_ALIGN[textState.textBaseline];
        const offsetY = this.textOffsetY_ * pixelRatio;
        const text = this.text_;
        const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            pixelRatio,
            offsetY,
            strokeKey,
            strokeWidth * pixelRatio,
            text,
            textKey,
            1
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            1,
            offsetY,
            strokeKey,
            strokeWidth,
            text,
            textKey,
            1 / pixelRatio
        ]);
    }
    /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */ setTextStyle(textStyle, sharedData) {
        let textState, fillState, strokeState;
        if (!textStyle) this.text_ = "";
        else {
            const textFillStyle = textStyle.getFill();
            if (!textFillStyle) {
                fillState = null;
                this.textFillState_ = fillState;
            } else {
                fillState = this.textFillState_;
                if (!fillState) {
                    fillState = /** @type {import("../canvas.js").FillState} */ {};
                    this.textFillState_ = fillState;
                }
                fillState.fillStyle = (0, _colorlikeJs.asColorLike)(textFillStyle.getColor() || (0, _canvasJs.defaultFillStyle));
            }
            const textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) {
                strokeState = null;
                this.textStrokeState_ = strokeState;
            } else {
                strokeState = this.textStrokeState_;
                if (!strokeState) {
                    strokeState = /** @type {import("../canvas.js").StrokeState} */ {};
                    this.textStrokeState_ = strokeState;
                }
                const lineDash = textStrokeStyle.getLineDash();
                const lineDashOffset = textStrokeStyle.getLineDashOffset();
                const lineWidth = textStrokeStyle.getWidth();
                const miterLimit = textStrokeStyle.getMiterLimit();
                strokeState.lineCap = textStrokeStyle.getLineCap() || (0, _canvasJs.defaultLineCap);
                strokeState.lineDash = lineDash ? lineDash.slice() : (0, _canvasJs.defaultLineDash);
                strokeState.lineDashOffset = lineDashOffset === undefined ? (0, _canvasJs.defaultLineDashOffset) : lineDashOffset;
                strokeState.lineJoin = textStrokeStyle.getLineJoin() || (0, _canvasJs.defaultLineJoin);
                strokeState.lineWidth = lineWidth === undefined ? (0, _canvasJs.defaultLineWidth) : lineWidth;
                strokeState.miterLimit = miterLimit === undefined ? (0, _canvasJs.defaultMiterLimit) : miterLimit;
                strokeState.strokeStyle = (0, _colorlikeJs.asColorLike)(textStrokeStyle.getColor() || (0, _canvasJs.defaultStrokeStyle));
            }
            textState = this.textState_;
            const font = textStyle.getFont() || (0, _canvasJs.defaultFont);
            (0, _canvasJs.registerFont)(font);
            const textScale = textStyle.getScaleArray();
            textState.overflow = textStyle.getOverflow();
            textState.font = font;
            textState.maxAngle = textStyle.getMaxAngle();
            textState.placement = textStyle.getPlacement();
            textState.textAlign = textStyle.getTextAlign();
            textState.justify = textStyle.getJustify();
            textState.textBaseline = textStyle.getTextBaseline() || (0, _canvasJs.defaultTextBaseline);
            textState.backgroundFill = textStyle.getBackgroundFill();
            textState.backgroundStroke = textStyle.getBackgroundStroke();
            textState.padding = textStyle.getPadding() || (0, _canvasJs.defaultPadding);
            textState.scale = textScale === undefined ? [
                1,
                1
            ] : textScale;
            const textOffsetX = textStyle.getOffsetX();
            const textOffsetY = textStyle.getOffsetY();
            const textRotateWithView = textStyle.getRotateWithView();
            const textRotation = textStyle.getRotation();
            this.text_ = textStyle.getText() || "";
            this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
            this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
            this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
            this.textRotation_ = textRotation === undefined ? 0 : textRotation;
            this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : (0, _utilJs.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
            this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
            this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + (0, _utilJs.getUid)(fillState.fillStyle) : "";
        }
        this.declutterImageWithText_ = sharedData;
    }
}
exports.default = CanvasTextBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","../../colorlike.js":"ftcFo","../canvas.js":"e85iQ","../../util.js":"pLBjQ","../../extent.js":"6YrVc","../../geom/flat/straightchunk.js":"eUhrS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eUhrS":[function(require,module,exports) {
/**
 * @module ol/geom/flat/straightchunk
 */ /**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "matchingChunk", ()=>matchingChunk);
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
    let chunkStart = offset;
    let chunkEnd = offset;
    let chunkM = 0;
    let m = 0;
    let start = offset;
    let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
    for(i = offset; i < end; i += stride){
        const x2 = flatCoordinates[i];
        const y2 = flatCoordinates[i + 1];
        if (x1 !== undefined) {
            x23 = x2 - x1;
            y23 = y2 - y1;
            m23 = Math.sqrt(x23 * x23 + y23 * y23);
            if (x12 !== undefined) {
                m += m12;
                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                if (acos > maxAngle) {
                    if (m > chunkM) {
                        chunkM = m;
                        chunkStart = start;
                        chunkEnd = i;
                    }
                    m = 0;
                    start = i - stride;
                }
            }
            m12 = m23;
            x12 = x23;
            y12 = y23;
        }
        x1 = x2;
        y1 = y2;
    }
    m += m23;
    return m > chunkM ? [
        start,
        i
    ] : [
        chunkStart,
        chunkEnd
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eUidV":[function(require,module,exports) {
/**
 * @module ol/render/canvas/ExecutorGroup
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */ parcelHelpers.export(exports, "getPixelIndexArray", ()=>getPixelIndexArray);
var _executorJs = require("./Executor.js");
var _executorJsDefault = parcelHelpers.interopDefault(_executorJs);
var _extentJs = require("../../extent.js");
var _transformJs = require("../../transform.js");
var _domJs = require("../../dom.js");
var _objJs = require("../../obj.js");
var _arrayJs = require("../../array.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @const
 * @type {Array<import("../canvas.js").BuilderType>}
 */ const ORDER = [
    "Polygon",
    "Circle",
    "LineString",
    "Image",
    "Text",
    "Default"
];
class ExecutorGroup {
    /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */ constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer){
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent_ = maxExtent;
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = overlaps;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.resolution_ = resolution;
        /**
     * @private
     * @type {number|undefined}
     */ this.renderBuffer_ = renderBuffer;
        /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Executor").default>>}
     */ this.executorsByZIndex_ = {};
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.hitDetectionContext_ = null;
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.hitDetectionTransform_ = (0, _transformJs.create)();
        this.createExecutors_(allInstructions);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */ clip(context, transform) {
        const flatClipCoords = this.getClipCoords(transform);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
    }
    /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */ createExecutors_(allInstructions) {
        for(const zIndex in allInstructions){
            let executors = this.executorsByZIndex_[zIndex];
            if (executors === undefined) {
                executors = {};
                this.executorsByZIndex_[zIndex] = executors;
            }
            const instructionByZindex = allInstructions[zIndex];
            for(const builderType in instructionByZindex){
                const instructions = instructionByZindex[builderType];
                executors[builderType] = new (0, _executorJsDefault.default)(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
            }
        }
    }
    /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */ hasExecutors(executors) {
        for(const zIndex in this.executorsByZIndex_){
            const candidates = this.executorsByZIndex_[zIndex];
            for(let i = 0, ii = executors.length; i < ii; ++i){
                if (executors[i] in candidates) return true;
            }
        }
        return false;
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        const contextSize = hitTolerance * 2 + 1;
        const transform = (0, _transformJs.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
        const newContext = !this.hitDetectionContext_;
        if (newContext) this.hitDetectionContext_ = (0, _domJs.createCanvasContext2D)(contextSize, contextSize);
        const context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
            context.canvas.width = contextSize;
            context.canvas.height = contextSize;
        } else if (!newContext) context.clearRect(0, 0, contextSize, contextSize);
        /**
     * @type {import("../../extent.js").Extent}
     */ let hitExtent;
        if (this.renderBuffer_ !== undefined) {
            hitExtent = (0, _extentJs.createEmpty)();
            (0, _extentJs.extendCoordinate)(hitExtent, coordinate);
            (0, _extentJs.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
        }
        const indexes = getPixelIndexArray(hitTolerance);
        let builderType;
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */ function featureCallback(feature, geometry) {
            const imageData = context.getImageData(0, 0, contextSize, contextSize).data;
            for(let i = 0, ii = indexes.length; i < ii; i++)if (imageData[indexes[i]] > 0) {
                if (!declutteredFeatures || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
                    const idx = (indexes[i] - 3) / 4;
                    const x = hitTolerance - idx % contextSize;
                    const y = hitTolerance - (idx / contextSize | 0);
                    const result = callback(feature, geometry, x * x + y * y);
                    if (result) return result;
                }
                context.clearRect(0, 0, contextSize, contextSize);
                break;
            }
            return undefined;
        }
        /** @type {Array<number>} */ const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort((0, _arrayJs.numberSafeCompareFunction));
        let i, j, executors, executor, result;
        for(i = zs.length - 1; i >= 0; --i){
            const zIndexKey = zs[i].toString();
            executors = this.executorsByZIndex_[zIndexKey];
            for(j = ORDER.length - 1; j >= 0; --j){
                builderType = ORDER[j];
                executor = executors[builderType];
                if (executor !== undefined) {
                    result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                    if (result) return result;
                }
            }
        }
        return undefined;
    }
    /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */ getClipCoords(transform) {
        const maxExtent = this.maxExtent_;
        if (!maxExtent) return null;
        const minX = maxExtent[0];
        const minY = maxExtent[1];
        const maxX = maxExtent[2];
        const maxY = maxExtent[3];
        const flatClipCoords = [
            minX,
            minY,
            minX,
            maxY,
            maxX,
            maxY,
            maxX,
            minY
        ];
        (0, _transformJs1.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
        return flatClipCoords;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return (0, _objJs.isEmpty)(this.executorsByZIndex_);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ execute(context, contextScale, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {
        /** @type {Array<number>} */ const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort((0, _arrayJs.numberSafeCompareFunction));
        // setup clipping so that the parts of over-simplified geometries are not
        // visible outside the current extent when panning
        if (this.maxExtent_) {
            context.save();
            this.clip(context, transform);
        }
        builderTypes = builderTypes ? builderTypes : ORDER;
        let i, ii, j, jj, replays, replay;
        if (declutterTree) zs.reverse();
        for(i = 0, ii = zs.length; i < ii; ++i){
            const zIndexKey = zs[i].toString();
            replays = this.executorsByZIndex_[zIndexKey];
            for(j = 0, jj = builderTypes.length; j < jj; ++j){
                const builderType = builderTypes[j];
                replay = replays[builderType];
                if (replay !== undefined) replay.execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree);
            }
        }
        if (this.maxExtent_) context.restore();
    }
}
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */ const circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
    if (circlePixelIndexArrayCache[radius] !== undefined) return circlePixelIndexArrayCache[radius];
    const size = radius * 2 + 1;
    const maxDistanceSq = radius * radius;
    const distances = new Array(maxDistanceSq + 1);
    for(let i = 0; i <= radius; ++i)for(let j = 0; j <= radius; ++j){
        const distanceSq = i * i + j * j;
        if (distanceSq > maxDistanceSq) break;
        let distance = distances[distanceSq];
        if (!distance) {
            distance = [];
            distances[distanceSq] = distance;
        }
        distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
        if (i > 0) distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
        if (j > 0) {
            distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
            if (i > 0) distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
    }
    const pixelIndex = [];
    for(let i1 = 0, ii = distances.length; i1 < ii; ++i1)if (distances[i1]) pixelIndex.push(...distances[i1]);
    circlePixelIndexArrayCache[radius] = pixelIndex;
    return pixelIndex;
}
exports.default = ExecutorGroup;

},{"./Executor.js":"5JJby","../../extent.js":"6YrVc","../../transform.js":"1BqUf","../../dom.js":"84QzQ","../../obj.js":"3ssAG","../../array.js":"1Fbic","../../geom/flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JJby":[function(require,module,exports) {
/**
 * @module ol/render/canvas/Executor
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _textBuilderJs = require("./TextBuilder.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _textpathJs = require("../../geom/flat/textpath.js");
var _arrayJs = require("../../array.js");
var _lengthJs = require("../../geom/flat/length.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */ /**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */ /**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */ /**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * @type {import("../../extent.js").Extent}
 */ const tmpExtent = (0, _extentJs.createEmpty)();
/** @type {import("../../coordinate.js").Coordinate} */ const p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */ function getDeclutterBox(replayImageOrLabelArgs) {
    return replayImageOrLabelArgs[3].declutterBox;
}
const rtlRegEx = new RegExp(/* eslint-disable prettier/prettier */ "[" + String.fromCharCode(0x00591) + "-" + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + "-" + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + "-" + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + "-" + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + "-" + String.fromCharCode(0x1efff) + "]");
/**
 * @param {string} text Text.
 * @param {CanvasTextAlign} align Alignment.
 * @return {number} Text alignment.
 */ function horizontalTextAlign(text, align) {
    if ((align === "start" || align === "end") && !rtlRegEx.test(text)) align = align === "start" ? "left" : "right";
    return (0, _textBuilderJs.TEXT_ALIGN)[align];
}
/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */ function createTextChunks(acc, line, i) {
    if (i > 0) acc.push("\n", "");
    acc.push(line, "");
    return acc;
}
class Executor {
    /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */ constructor(resolution, pixelRatio, overlaps, instructions){
        /**
     * @protected
     * @type {boolean}
     */ this.overlaps = overlaps;
        /**
     * @protected
     * @type {number}
     */ this.pixelRatio = pixelRatio;
        /**
     * @protected
     * @const
     * @type {number}
     */ this.resolution = resolution;
        /**
     * @private
     * @type {boolean}
     */ this.alignFill_;
        /**
     * @protected
     * @type {Array<*>}
     */ this.instructions = instructions.instructions;
        /**
     * @protected
     * @type {Array<number>}
     */ this.coordinates = instructions.coordinates;
        /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */ this.coordinateCache_ = {};
        /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */ this.renderedTransform_ = (0, _transformJs.create)();
        /**
     * @protected
     * @type {Array<*>}
     */ this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        /**
     * @private
     * @type {Array<number>}
     */ this.pixelCoordinates_ = null;
        /**
     * @private
     * @type {number}
     */ this.viewRotation_ = 0;
        /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */ this.fillStates = instructions.fillStates || {};
        /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */ this.strokeStates = instructions.strokeStates || {};
        /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */ this.textStates = instructions.textStates || {};
        /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */ this.widths_ = {};
        /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */ this.labels_ = {};
    }
    /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */ createLabel(text, textKey, fillKey, strokeKey) {
        const key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) return this.labels_[key];
        const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        const fillState = fillKey ? this.fillStates[fillKey] : null;
        const textState = this.textStates[textKey];
        const pixelRatio = this.pixelRatio;
        const scale = [
            textState.scale[0] * pixelRatio,
            textState.scale[1] * pixelRatio
        ];
        const textIsArray = Array.isArray(text);
        const align = textState.justify ? (0, _textBuilderJs.TEXT_ALIGN)[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || (0, _canvasJs.defaultTextAlign));
        const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
        const { width , height , widths , heights , lineWidths  } = (0, _canvasJs.getTextDimensions)(textState, chunks);
        const renderWidth = width + strokeWidth;
        const contextInstructions = [];
        // make canvas 2 pixels wider to account for italic text width measurement errors
        const w = (renderWidth + 2) * scale[0];
        const h = (height + strokeWidth) * scale[1];
        /** @type {import("../canvas.js").Label} */ const label = {
            width: w < 0 ? Math.floor(w) : Math.ceil(w),
            height: h < 0 ? Math.floor(h) : Math.ceil(h),
            contextInstructions: contextInstructions
        };
        if (scale[0] != 1 || scale[1] != 1) contextInstructions.push("scale", scale);
        if (strokeKey) {
            contextInstructions.push("strokeStyle", strokeState.strokeStyle);
            contextInstructions.push("lineWidth", strokeWidth);
            contextInstructions.push("lineCap", strokeState.lineCap);
            contextInstructions.push("lineJoin", strokeState.lineJoin);
            contextInstructions.push("miterLimit", strokeState.miterLimit);
            contextInstructions.push("setLineDash", [
                strokeState.lineDash
            ]);
            contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
        }
        if (fillKey) contextInstructions.push("fillStyle", fillState.fillStyle);
        contextInstructions.push("textBaseline", "middle");
        contextInstructions.push("textAlign", "center");
        const leftRight = 0.5 - align;
        let x = align * renderWidth + leftRight * strokeWidth;
        const strokeInstructions = [];
        const fillInstructions = [];
        let lineHeight = 0;
        let lineOffset = 0;
        let widthHeightIndex = 0;
        let lineWidthIndex = 0;
        let previousFont;
        for(let i = 0, ii = chunks.length; i < ii; i += 2){
            const text1 = chunks[i];
            if (text1 === "\n") {
                lineOffset += lineHeight;
                lineHeight = 0;
                x = align * renderWidth + leftRight * strokeWidth;
                ++lineWidthIndex;
                continue;
            }
            const font = chunks[i + 1] || textState.font;
            if (font !== previousFont) {
                if (strokeKey) strokeInstructions.push("font", font);
                if (fillKey) fillInstructions.push("font", font);
                previousFont = font;
            }
            lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
            const fillStrokeArgs = [
                text1,
                x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
                0.5 * (strokeWidth + lineHeight) + lineOffset
            ];
            x += widths[widthHeightIndex];
            if (strokeKey) strokeInstructions.push("strokeText", fillStrokeArgs);
            if (fillKey) fillInstructions.push("fillText", fillStrokeArgs);
            ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */ replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
        context.beginPath();
        context.moveTo.apply(context, p1);
        context.lineTo.apply(context, p2);
        context.lineTo.apply(context, p3);
        context.lineTo.apply(context, p4);
        context.lineTo.apply(context, p1);
        if (fillInstruction) {
            this.alignFill_ = /** @type {boolean} */ fillInstruction[2];
            this.fill_(context);
        }
        if (strokeInstruction) {
            this.setStrokeStyle_(context, /** @type {Array<*>} */ strokeInstruction);
            context.stroke();
        }
    }
    /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */ calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale[0];
        anchorY *= scale[1];
        let x = centerX - anchorX;
        let y = centerY - anchorY;
        const w = width + originX > sheetWidth ? sheetWidth - originX : width;
        const h = height + originY > sheetHeight ? sheetHeight - originY : height;
        const boxW = padding[3] + w * scale[0] + padding[1];
        const boxH = padding[0] + h * scale[1] + padding[2];
        const boxX = x - padding[3];
        const boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
            p1[0] = boxX;
            p4[0] = boxX;
            p1[1] = boxY;
            p2[1] = boxY;
            p2[0] = boxX + boxW;
            p3[0] = p2[0];
            p3[1] = boxY + boxH;
            p4[1] = p3[1];
        }
        let transform;
        if (rotation !== 0) {
            transform = (0, _transformJs.compose)((0, _transformJs.create)(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
            (0, _transformJs.apply)(transform, p1);
            (0, _transformJs.apply)(transform, p2);
            (0, _transformJs.apply)(transform, p3);
            (0, _transformJs.apply)(transform, p4);
            (0, _extentJs.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
        } else (0, _extentJs.createOrUpdate)(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
        if (snapToPixel) {
            x = Math.round(x);
            y = Math.round(y);
        }
        return {
            drawImageX: x,
            drawImageY: y,
            drawImageW: w,
            drawImageH: h,
            originX: originX,
            originY: originY,
            declutterBox: {
                minX: tmpExtent[0],
                minY: tmpExtent[1],
                maxX: tmpExtent[2],
                maxY: tmpExtent[3],
                value: feature
            },
            canvasTransform: transform,
            scale: scale
        };
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */ replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
        const fillStroke = !!(fillInstruction || strokeInstruction);
        const box = dimensions.declutterBox;
        const canvas = context.canvas;
        const strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
        const intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
        if (intersects) {
            if (fillStroke) this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */ fillInstruction, /** @type {Array<*>} */ strokeInstruction);
            (0, _canvasJs.drawImageOrLabel)(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
        }
        return true;
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */ fill_(context) {
        if (this.alignFill_) {
            const origin = (0, _transformJs.apply)(this.renderedTransform_, [
                0,
                0
            ]);
            const repeatSize = 512 * this.pixelRatio;
            context.save();
            context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
            context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) context.restore();
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */ setStrokeStyle_(context, instruction) {
        context["strokeStyle"] = /** @type {import("../../colorlike.js").ColorLike} */ instruction[1];
        context.lineWidth = /** @type {number} */ instruction[2];
        context.lineCap = /** @type {CanvasLineCap} */ instruction[3];
        context.lineJoin = /** @type {CanvasLineJoin} */ instruction[4];
        context.miterLimit = /** @type {number} */ instruction[5];
        context.lineDashOffset = /** @type {number} */ instruction[7];
        context.setLineDash(/** @type {Array<number>} */ instruction[6]);
    }
    /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */ drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
        const textState = this.textStates[textKey];
        const label = this.createLabel(text, textKey, fillKey, strokeKey);
        const strokeState = this.strokeStates[strokeKey];
        const pixelRatio = this.pixelRatio;
        const align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || (0, _canvasJs.defaultTextAlign));
        const baseline = (0, _textBuilderJs.TEXT_ALIGN)[textState.textBaseline || (0, _canvasJs.defaultTextBaseline)];
        const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        // Remove the 2 pixels we added in createLabel() for the anchor
        const width = label.width / pixelRatio - 2 * textState.scale[0];
        const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
            label: label,
            anchorX: anchorX,
            anchorY: anchorY
        };
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */ execute_(context, contextScale, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
        /** @type {Array<number>} */ let pixelCoordinates;
        if (this.pixelCoordinates_ && (0, _arrayJs.equals)(transform, this.renderedTransform_)) pixelCoordinates = this.pixelCoordinates_;
        else {
            if (!this.pixelCoordinates_) this.pixelCoordinates_ = [];
            pixelCoordinates = (0, _transformJs1.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
            (0, _transformJs.setFromArray)(this.renderedTransform_, transform);
        }
        let i = 0; // instruction index
        const ii = instructions.length; // end of instructions
        let d = 0; // data index
        let dd; // end of per-instruction data
        let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        let pendingFill = 0;
        let pendingStroke = 0;
        let lastFillInstruction = null;
        let lastStrokeInstruction = null;
        const coordinateCache = this.coordinateCache_;
        const viewRotation = this.viewRotation_;
        const viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
        const state = /** @type {import("../../render.js").State} */ {
            context: context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
        };
        // When the batch size gets too big, performance decreases. 200 is a good
        // balance between batch size and number of fill/stroke instructions.
        const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        let /** @type {import("../../Feature.js").FeatureLike} */ feature;
        let x, y, currentGeometry;
        while(i < ii){
            const instruction = instructions[i];
            const type = /** @type {import("./Instruction.js").default} */ instruction[0];
            switch(type){
                case (0, _instructionJsDefault.default).BEGIN_GEOMETRY:
                    feature = /** @type {import("../../Feature.js").FeatureLike} */ instruction[1];
                    currentGeometry = instruction[3];
                    if (!feature.getGeometry()) i = /** @type {number} */ instruction[2];
                    else if (hitExtent !== undefined && !(0, _extentJs.intersects)(hitExtent, currentGeometry.getExtent())) i = /** @type {number} */ instruction[2] + 1;
                    else ++i;
                    break;
                case (0, _instructionJsDefault.default).BEGIN_PATH:
                    if (pendingFill > batchSize) {
                        this.fill_(context);
                        pendingFill = 0;
                    }
                    if (pendingStroke > batchSize) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    if (!pendingFill && !pendingStroke) {
                        context.beginPath();
                        prevX = NaN;
                        prevY = NaN;
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CIRCLE:
                    d = /** @type {number} */ instruction[1];
                    const x1 = pixelCoordinates[d];
                    const y1 = pixelCoordinates[d + 1];
                    const x2 = pixelCoordinates[d + 2];
                    const y2 = pixelCoordinates[d + 3];
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    context.moveTo(x1 + r, y1);
                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CLOSE_PATH:
                    context.closePath();
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CUSTOM:
                    d = /** @type {number} */ instruction[1];
                    dd = instruction[2];
                    const geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ instruction[3];
                    const renderer = instruction[4];
                    const fn = instruction.length == 6 ? instruction[5] : undefined;
                    state.geometry = geometry;
                    state.feature = feature;
                    if (!(i in coordinateCache)) coordinateCache[i] = [];
                    const coords = coordinateCache[i];
                    if (fn) fn(pixelCoordinates, d, dd, 2, coords);
                    else {
                        coords[0] = pixelCoordinates[d];
                        coords[1] = pixelCoordinates[d + 1];
                        coords.length = 2;
                    }
                    renderer(coords, state);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).DRAW_IMAGE:
                    d = /** @type {number} */ instruction[1];
                    dd = /** @type {number} */ instruction[2];
                    image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ instruction[3];
                    // Remaining arguments in DRAW_IMAGE are in alphabetical order
                    anchorX = /** @type {number} */ instruction[4];
                    anchorY = /** @type {number} */ instruction[5];
                    let height = /** @type {number} */ instruction[6];
                    const opacity = /** @type {number} */ instruction[7];
                    const originX = /** @type {number} */ instruction[8];
                    const originY = /** @type {number} */ instruction[9];
                    const rotateWithView = /** @type {boolean} */ instruction[10];
                    let rotation = /** @type {number} */ instruction[11];
                    const scale = /** @type {import("../../size.js").Size} */ instruction[12];
                    let width = /** @type {number} */ instruction[13];
                    const declutterMode = /** @type {"declutter"|"obstacle"|"none"|undefined} */ instruction[14];
                    const declutterImageWithText = /** @type {import("../canvas.js").DeclutterImageWithText} */ instruction[15];
                    if (!image && instruction.length >= 20) {
                        // create label images
                        text = /** @type {string} */ instruction[19];
                        textKey = /** @type {string} */ instruction[20];
                        strokeKey = /** @type {string} */ instruction[21];
                        fillKey = /** @type {string} */ instruction[22];
                        const labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                        image = labelWithAnchor.label;
                        instruction[3] = image;
                        const textOffsetX = /** @type {number} */ instruction[23];
                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                        instruction[4] = anchorX;
                        const textOffsetY = /** @type {number} */ instruction[24];
                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                        instruction[5] = anchorY;
                        height = image.height;
                        instruction[6] = height;
                        width = image.width;
                        instruction[13] = width;
                    }
                    let geometryWidths;
                    if (instruction.length > 25) geometryWidths = /** @type {number} */ instruction[25];
                    let padding, backgroundFill, backgroundStroke;
                    if (instruction.length > 17) {
                        padding = /** @type {Array<number>} */ instruction[16];
                        backgroundFill = /** @type {boolean} */ instruction[17];
                        backgroundStroke = /** @type {boolean} */ instruction[18];
                    } else {
                        padding = (0, _canvasJs.defaultPadding);
                        backgroundFill = false;
                        backgroundStroke = false;
                    }
                    if (rotateWithView && viewRotationFromTransform) // Canvas is expected to be rotated to reverse view rotation.
                    rotation += viewRotation;
                    else if (!rotateWithView && !viewRotationFromTransform) // Canvas is not rotated, images need to be rotated back to be north-up.
                    rotation -= viewRotation;
                    let widthIndex = 0;
                    for(; d < dd; d += 2){
                        if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) continue;
                        const dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                        /** @type {ReplayImageOrLabelArgs} */ const args = [
                            context,
                            contextScale,
                            image,
                            dimensions,
                            opacity,
                            backgroundFill ? /** @type {Array<*>} */ lastFillInstruction : null,
                            backgroundStroke ? /** @type {Array<*>} */ lastStrokeInstruction : null
                        ];
                        if (declutterTree) {
                            if (declutterMode === "none") continue;
                            else if (declutterMode === "obstacle") {
                                // will always be drawn, thus no collision detection, but insert as obstacle
                                declutterTree.insert(dimensions.declutterBox);
                                continue;
                            } else {
                                let imageArgs;
                                let imageDeclutterBox;
                                if (declutterImageWithText) {
                                    const index = dd - d;
                                    if (!declutterImageWithText[index]) {
                                        // We now have the image for an image+text combination.
                                        declutterImageWithText[index] = args;
                                        continue;
                                    }
                                    imageArgs = declutterImageWithText[index];
                                    delete declutterImageWithText[index];
                                    imageDeclutterBox = getDeclutterBox(imageArgs);
                                    if (declutterTree.collides(imageDeclutterBox)) continue;
                                }
                                if (declutterTree.collides(dimensions.declutterBox)) continue;
                                if (imageArgs) {
                                    // We now have image and text for an image+text combination.
                                    declutterTree.insert(imageDeclutterBox);
                                    // Render the image before we render the text.
                                    this.replayImageOrLabel_.apply(this, imageArgs);
                                }
                                declutterTree.insert(dimensions.declutterBox);
                            }
                        }
                        this.replayImageOrLabel_.apply(this, args);
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).DRAW_CHARS:
                    const begin = /** @type {number} */ instruction[1];
                    const end = /** @type {number} */ instruction[2];
                    const baseline = /** @type {number} */ instruction[3];
                    const overflow = /** @type {number} */ instruction[4];
                    fillKey = /** @type {string} */ instruction[5];
                    const maxAngle = /** @type {number} */ instruction[6];
                    const measurePixelRatio = /** @type {number} */ instruction[7];
                    const offsetY = /** @type {number} */ instruction[8];
                    strokeKey = /** @type {string} */ instruction[9];
                    const strokeWidth = /** @type {number} */ instruction[10];
                    text = /** @type {string} */ instruction[11];
                    textKey = /** @type {string} */ instruction[12];
                    const pixelRatioScale = [
                        /** @type {number} */ instruction[13],
                        /** @type {number} */ instruction[13]
                    ];
                    const textState = this.textStates[textKey];
                    const font = textState.font;
                    const textScale = [
                        textState.scale[0] * measurePixelRatio,
                        textState.scale[1] * measurePixelRatio
                    ];
                    let cachedWidths;
                    if (font in this.widths_) cachedWidths = this.widths_[font];
                    else {
                        cachedWidths = {};
                        this.widths_[font] = cachedWidths;
                    }
                    const pathLength = (0, _lengthJs.lineStringLength)(pixelCoordinates, begin, end, 2);
                    const textLength = Math.abs(textScale[0]) * (0, _canvasJs.measureAndCacheTextWidth)(font, text, cachedWidths);
                    if (overflow || textLength <= pathLength) {
                        const textAlign = this.textStates[textKey].textAlign;
                        const startM = (pathLength - textLength) * (0, _textBuilderJs.TEXT_ALIGN)[textAlign];
                        const parts = (0, _textpathJs.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), (0, _canvasJs.measureAndCacheTextWidth), font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                        drawChars: if (parts) {
                            /** @type {Array<ReplayImageOrLabelArgs>} */ const replayImageOrLabelArgs = [];
                            let c, cc, chars, label, part;
                            if (strokeKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = /** @type {string} */ part[4];
                                label = this.createLabel(chars, textKey, "", strokeKey);
                                anchorX = /** @type {number} */ part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                                const dimensions1 = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, (0, _canvasJs.defaultPadding), false, feature);
                                if (declutterTree && declutterTree.collides(dimensions1.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions1,
                                    1,
                                    null,
                                    null
                                ]);
                            }
                            if (fillKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = /** @type {string} */ part[4];
                                label = this.createLabel(chars, textKey, fillKey, "");
                                anchorX = /** @type {number} */ part[2];
                                anchorY = baseline * label.height - offsetY;
                                const dimensions2 = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, (0, _canvasJs.defaultPadding), false, feature);
                                if (declutterTree && declutterTree.collides(dimensions2.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions2,
                                    1,
                                    null,
                                    null
                                ]);
                            }
                            if (declutterTree) declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                            for(let i1 = 0, ii1 = replayImageOrLabelArgs.length; i1 < ii1; ++i1)this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i1]);
                        }
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).END_GEOMETRY:
                    if (featureCallback !== undefined) {
                        feature = /** @type {import("../../Feature.js").FeatureLike} */ instruction[1];
                        const result = featureCallback(feature, currentGeometry);
                        if (result) return result;
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).FILL:
                    if (batchSize) pendingFill++;
                    else this.fill_(context);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).MOVE_TO_LINE_TO:
                    d = /** @type {number} */ instruction[1];
                    dd = /** @type {number} */ instruction[2];
                    x = pixelCoordinates[d];
                    y = pixelCoordinates[d + 1];
                    roundX = x + 0.5 | 0;
                    roundY = y + 0.5 | 0;
                    if (roundX !== prevX || roundY !== prevY) {
                        context.moveTo(x, y);
                        prevX = roundX;
                        prevY = roundY;
                    }
                    for(d += 2; d < dd; d += 2){
                        x = pixelCoordinates[d];
                        y = pixelCoordinates[d + 1];
                        roundX = x + 0.5 | 0;
                        roundY = y + 0.5 | 0;
                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                            context.lineTo(x, y);
                            prevX = roundX;
                            prevY = roundY;
                        }
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).SET_FILL_STYLE:
                    lastFillInstruction = instruction;
                    this.alignFill_ = instruction[2];
                    if (pendingFill) {
                        this.fill_(context);
                        pendingFill = 0;
                        if (pendingStroke) {
                            context.stroke();
                            pendingStroke = 0;
                        }
                    }
                    context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ instruction[1];
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).SET_STROKE_STYLE:
                    lastStrokeInstruction = instruction;
                    if (pendingStroke) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    this.setStrokeStyle_(context, /** @type {Array<*>} */ instruction);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).STROKE:
                    if (batchSize) pendingStroke++;
                    else context.stroke();
                    ++i;
                    break;
                default:
                    ++i;
                    break;
            }
        }
        if (pendingFill) this.fill_(context);
        if (pendingStroke) context.stroke();
        return undefined;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */ executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);
    }
}
exports.default = Executor;

},{"./Instruction.js":"9nhw8","./TextBuilder.js":"6mvke","../../transform.js":"1BqUf","../../extent.js":"6YrVc","../canvas.js":"e85iQ","../../geom/flat/textpath.js":"hYFQq","../../array.js":"1Fbic","../../geom/flat/length.js":"X5sUU","../../geom/flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hYFQq":[function(require,module,exports) {
/**
 * @module ol/geom/flat/textpath
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */ parcelHelpers.export(exports, "drawTextOnPath", ()=>drawTextOnPath);
var _mathJs = require("../../math.js");
var _transformJs = require("./transform.js");
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
    let x2 = flatCoordinates[offset];
    let y2 = flatCoordinates[offset + 1];
    let x1 = 0;
    let y1 = 0;
    let segmentLength = 0;
    let segmentM = 0;
    function advance() {
        x1 = x2;
        y1 = y2;
        offset += stride;
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        segmentM += segmentLength;
        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    do advance();
    while (offset < end - stride && segmentM + segmentLength < startM);
    let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
    const beginX = (0, _mathJs.lerp)(x1, x2, interpolate);
    const beginY = (0, _mathJs.lerp)(y1, y2, interpolate);
    const startOffset = offset - stride;
    const startLength = segmentM;
    const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
    while(offset < end - stride && segmentM + segmentLength < endM)advance();
    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
    const endX = (0, _mathJs.lerp)(x1, x2, interpolate);
    const endY = (0, _mathJs.lerp)(y1, y2, interpolate);
    // Keep text upright
    let reverse;
    if (rotation) {
        const flat = [
            beginX,
            beginY,
            endX,
            endY
        ];
        (0, _transformJs.rotate)(flat, 0, 4, 2, rotation, flat, flat);
        reverse = flat[0] > flat[2];
    } else reverse = beginX > endX;
    const PI = Math.PI;
    const result = [];
    const singleSegment = startOffset + stride === offset;
    offset = startOffset;
    segmentLength = 0;
    segmentM = startLength;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    let previousAngle;
    // All on the same segment
    if (singleSegment) {
        advance();
        previousAngle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) previousAngle += previousAngle > 0 ? -PI : PI;
        const x = (endX + beginX) / 2;
        const y = (endY + beginY) / 2;
        result[0] = [
            x,
            y,
            (endM - startM) / 2,
            previousAngle,
            text
        ];
        return result;
    }
    // rendering across line segments
    text = text.replace(/\n/g, " "); // ensure rendering in single-line as all calculations below don't handle multi-lines
    for(let i = 0, ii = text.length; i < ii;){
        advance();
        let angle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) angle += angle > 0 ? -PI : PI;
        if (previousAngle !== undefined) {
            let delta = angle - previousAngle;
            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
            if (Math.abs(delta) > maxAngle) return null;
        }
        previousAngle = angle;
        const iStart = i;
        let charLength = 0;
        for(; i < ii; ++i){
            const index = reverse ? ii - i - 1 : i;
            const len = scale * measureAndCacheTextWidth(font, text[index], cache);
            if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) break;
            charLength += len;
        }
        if (i === iStart) continue;
        const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
        interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
        const x3 = (0, _mathJs.lerp)(x1, x2, interpolate);
        const y3 = (0, _mathJs.lerp)(y1, y2, interpolate);
        result.push([
            x3,
            y3,
            charLength / 2,
            angle,
            chars
        ]);
        startM += charLength;
    }
    return result;
}

},{"../../math.js":"5jEFr","./transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hriIE":[function(require,module,exports) {
/**
 * @module ol/render/canvas/hitdetect
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HIT_DETECT_RESOLUTION", ()=>HIT_DETECT_RESOLUTION);
/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */ parcelHelpers.export(exports, "createHitDetectionImageData", ()=>createHitDetectionImageData);
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<import("../../Feature").FeatureLike>} features Features.
 */ parcelHelpers.export(exports, "hitDetect", ()=>hitDetect);
var _immediateJs = require("./Immediate.js");
var _immediateJsDefault = parcelHelpers.interopDefault(_immediateJs);
var _styleJs = require("../../style.js");
var _mathJs = require("../../math.js");
var _domJs = require("../../dom.js");
var _extentJs = require("../../extent.js");
var _arrayJs = require("../../array.js");
const HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
    const width = size[0] * HIT_DETECT_RESOLUTION;
    const height = size[1] * HIT_DETECT_RESOLUTION;
    const context = (0, _domJs.createCanvasContext2D)(width, height);
    context.imageSmoothingEnabled = false;
    const canvas = context.canvas;
    const renderer = new (0, _immediateJsDefault.default)(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
    const featureCount = features.length;
    // Stretch hit detection index to use the whole available color range
    const indexFactor = Math.floor(16777215 / featureCount);
    const featuresByZIndex = {};
    for(let i = 1; i <= featureCount; ++i){
        const feature = features[i - 1];
        const featureStyleFunction = feature.getStyleFunction() || styleFunction;
        if (!styleFunction) continue;
        let styles = featureStyleFunction(feature, resolution);
        if (!styles) continue;
        if (!Array.isArray(styles)) styles = [
            styles
        ];
        const index = i * indexFactor;
        const color = "#" + ("000000" + index.toString(16)).slice(-6);
        for(let j = 0, jj = styles.length; j < jj; ++j){
            const originalStyle = styles[j];
            const geometry = originalStyle.getGeometryFunction()(feature);
            if (!geometry || !(0, _extentJs.intersects)(extent, geometry.getExtent())) continue;
            const style = originalStyle.clone();
            const fill = style.getFill();
            if (fill) fill.setColor(color);
            const stroke = style.getStroke();
            if (stroke) {
                stroke.setColor(color);
                stroke.setLineDash(null);
            }
            style.setText(undefined);
            const image = originalStyle.getImage();
            if (image && image.getOpacity() !== 0) {
                const imgSize = image.getImageSize();
                if (!imgSize) continue;
                const imgContext = (0, _domJs.createCanvasContext2D)(imgSize[0], imgSize[1], undefined, {
                    alpha: false
                });
                const img = imgContext.canvas;
                imgContext.fillStyle = color;
                imgContext.fillRect(0, 0, img.width, img.height);
                style.setImage(new (0, _styleJs.Icon)({
                    img: img,
                    imgSize: imgSize,
                    anchor: image.getAnchor(),
                    anchorXUnits: "pixels",
                    anchorYUnits: "pixels",
                    offset: image.getOrigin(),
                    opacity: 1,
                    size: image.getSize(),
                    scale: image.getScale(),
                    rotation: image.getRotation(),
                    rotateWithView: image.getRotateWithView()
                }));
            }
            const zIndex = style.getZIndex() || 0;
            let byGeometryType = featuresByZIndex[zIndex];
            if (!byGeometryType) {
                byGeometryType = {};
                featuresByZIndex[zIndex] = byGeometryType;
                byGeometryType["Polygon"] = [];
                byGeometryType["Circle"] = [];
                byGeometryType["LineString"] = [];
                byGeometryType["Point"] = [];
            }
            byGeometryType[geometry.getType().replace("Multi", "")].push(geometry, style);
        }
    }
    const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort((0, _arrayJs.numberSafeCompareFunction));
    for(let i1 = 0, ii = zIndexKeys.length; i1 < ii; ++i1){
        const byGeometryType1 = featuresByZIndex[zIndexKeys[i1]];
        for(const type in byGeometryType1){
            const geomAndStyle = byGeometryType1[type];
            for(let j1 = 0, jj1 = geomAndStyle.length; j1 < jj1; j1 += 2){
                renderer.setStyle(geomAndStyle[j1 + 1]);
                for(let k = 0, kk = transforms.length; k < kk; ++k){
                    renderer.setTransform(transforms[k]);
                    renderer.drawGeometry(geomAndStyle[j1]);
                }
            }
        }
    }
    return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
    const resultFeatures = [];
    if (imageData) {
        const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
        const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
        // The pixel coordinate is clamped down to the hit-detect canvas' size to account
        // for browsers returning coordinates slightly larger than the actual canvas size
        // due to a non-integer pixel ratio.
        const index = ((0, _mathJs.clamp)(x, 0, imageData.width - 1) + (0, _mathJs.clamp)(y, 0, imageData.height - 1) * imageData.width) * 4;
        const r = imageData.data[index];
        const g = imageData.data[index + 1];
        const b = imageData.data[index + 2];
        const i = b + 256 * (g + 256 * r);
        const indexFactor = Math.floor(16777215 / features.length);
        if (i && i % indexFactor === 0) resultFeatures.push(features[i / indexFactor - 1]);
    }
    return resultFeatures;
}

},{"./Immediate.js":"j3fUk","../../style.js":"hEQxF","../../math.js":"5jEFr","../../dom.js":"84QzQ","../../extent.js":"6YrVc","../../array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j3fUk":[function(require,module,exports) {
/**
 * @module ol/render/canvas/Immediate
 */ // FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _transformJs = require("../../transform.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
var _transformJs1 = require("../../geom/flat/transform.js");
var _simpleGeometryJs = require("../../geom/SimpleGeometry.js");
/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */ class CanvasImmediateRenderer extends (0, _vectorContextJsDefault.default) {
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */ constructor(context, pixelRatio, extent, transform, viewRotation, squaredTolerance, userTransform){
        super();
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.context_ = context;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.extent_ = extent;
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.transform_ = transform;
        /**
     * @private
     * @type {number}
     */ this.viewRotation_ = viewRotation;
        /**
     * @private
     * @type {number}
     */ this.squaredTolerance_ = squaredTolerance;
        /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */ this.userTransform_ = userTransform;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.contextFillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.contextStrokeState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */ this.contextTextState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.fillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.strokeState_ = null;
        /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */ this.image_ = null;
        /**
     * @private
     * @type {number}
     */ this.imageAnchorX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageAnchorY_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageHeight_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOpacity_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOriginX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOriginY_ = 0;
        /**
     * @private
     * @type {boolean}
     */ this.imageRotateWithView_ = false;
        /**
     * @private
     * @type {number}
     */ this.imageRotation_ = 0;
        /**
     * @private
     * @type {import("../../size.js").Size}
     */ this.imageScale_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {number}
     */ this.imageWidth_ = 0;
        /**
     * @private
     * @type {string}
     */ this.text_ = "";
        /**
     * @private
     * @type {number}
     */ this.textOffsetX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.textOffsetY_ = 0;
        /**
     * @private
     * @type {boolean}
     */ this.textRotateWithView_ = false;
        /**
     * @private
     * @type {number}
     */ this.textRotation_ = 0;
        /**
     * @private
     * @type {import("../../size.js").Size}
     */ this.textScale_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.textFillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.textStrokeState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */ this.textState_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.pixelCoordinates_ = [];
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.tmpLocalTransform_ = (0, _transformJs.create)();
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */ drawImages_(flatCoordinates, offset, end, stride) {
        if (!this.image_) return;
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        const context = this.context_;
        const localTransform = this.tmpLocalTransform_;
        const alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha * this.imageOpacity_;
        let rotation = this.imageRotation_;
        if (this.imageRotateWithView_) rotation += this.viewRotation_;
        for(let i = 0, ii = pixelCoordinates.length; i < ii; i += 2){
            const x = pixelCoordinates[i] - this.imageAnchorX_;
            const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
            if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                const centerX = x + this.imageAnchorX_;
                const centerY = y + this.imageAnchorY_;
                (0, _transformJs.compose)(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                context.setTransform.apply(context, localTransform);
                context.translate(centerX, centerY);
                context.scale(this.imageScale_[0], this.imageScale_[1]);
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                context.setTransform(1, 0, 0, 1, 0, 0);
            } else context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
        }
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */ drawText_(flatCoordinates, offset, end, stride) {
        if (!this.textState_ || this.text_ === "") return;
        if (this.textFillState_) this.setContextFillState_(this.textFillState_);
        if (this.textStrokeState_) this.setContextStrokeState_(this.textStrokeState_);
        this.setContextTextState_(this.textState_);
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        const context = this.context_;
        let rotation = this.textRotation_;
        if (this.textRotateWithView_) rotation += this.viewRotation_;
        for(; offset < end; offset += stride){
            const x = pixelCoordinates[offset] + this.textOffsetX_;
            const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
            if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
                context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
                context.rotate(rotation);
                context.translate(this.textOffsetX_, this.textOffsetY_);
                context.scale(this.textScale_[0], this.textScale_[1]);
                if (this.textStrokeState_) context.strokeText(this.text_, 0, 0);
                if (this.textFillState_) context.fillText(this.text_, 0, 0);
                context.setTransform(1, 0, 0, 1, 0, 0);
            } else {
                if (this.textStrokeState_) context.strokeText(this.text_, x, y);
                if (this.textFillState_) context.fillText(this.text_, x, y);
            }
        }
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */ moveToLineTo_(flatCoordinates, offset, end, stride, close) {
        const context = this.context_;
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        let length = pixelCoordinates.length;
        if (close) length -= 2;
        for(let i = 2; i < length; i += 2)context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        if (close) context.closePath();
        return end;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */ drawRings_(flatCoordinates, offset, ends, stride) {
        for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
        return offset;
    }
    /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */ drawCircle(geometry) {
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.fillState_ || this.strokeState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const pixelCoordinates = (0, _simpleGeometryJs.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
            const dx = pixelCoordinates[2] - pixelCoordinates[0];
            const dy = pixelCoordinates[3] - pixelCoordinates[1];
            const radius = Math.sqrt(dx * dx + dy * dy);
            const context = this.context_;
            context.beginPath();
            context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== "") this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
    /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */ setStyle(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
    }
    /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */ setTransform(transform) {
        this.transform_ = transform;
    }
    /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */ drawGeometry(geometry) {
        const type = geometry.getType();
        switch(type){
            case "Point":
                this.drawPoint(/** @type {import("../../geom/Point.js").default} */ geometry);
                break;
            case "LineString":
                this.drawLineString(/** @type {import("../../geom/LineString.js").default} */ geometry);
                break;
            case "Polygon":
                this.drawPolygon(/** @type {import("../../geom/Polygon.js").default} */ geometry);
                break;
            case "MultiPoint":
                this.drawMultiPoint(/** @type {import("../../geom/MultiPoint.js").default} */ geometry);
                break;
            case "MultiLineString":
                this.drawMultiLineString(/** @type {import("../../geom/MultiLineString.js").default} */ geometry);
                break;
            case "MultiPolygon":
                this.drawMultiPolygon(/** @type {import("../../geom/MultiPolygon.js").default} */ geometry);
                break;
            case "GeometryCollection":
                this.drawGeometryCollection(/** @type {import("../../geom/GeometryCollection.js").default} */ geometry);
                break;
            case "Circle":
                this.drawCircle(/** @type {import("../../geom/Circle.js").default} */ geometry);
                break;
            default:
        }
    }
    /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */ drawFeature(feature, style) {
        const geometry = style.getGeometryFunction()(feature);
        if (!geometry || !(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        this.setStyle(style);
        this.drawGeometry(geometry);
    }
    /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */ drawGeometryCollection(geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0, ii = geometries.length; i < ii; ++i)this.drawGeometry(geometries[i]);
    }
    /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */ drawPoint(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Point.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== "") this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */ drawMultiPoint(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiPoint.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== "") this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */ drawLineString(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/LineString.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getFlatCoordinates();
            context.beginPath();
            this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
            context.stroke();
        }
        if (this.text_ !== "") {
            const flatMidpoint = geometry.getFlatMidpoint();
            this.drawText_(flatMidpoint, 0, 2, 2);
        }
    }
    /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */ drawMultiLineString(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const geometryExtent = geometry.getExtent();
        if (!(0, _extentJs.intersects)(this.extent_, geometryExtent)) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getFlatCoordinates();
            let offset = 0;
            const ends = /** @type {Array<number>} */ geometry.getEnds();
            const stride = geometry.getStride();
            context.beginPath();
            for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
            context.stroke();
        }
        if (this.text_ !== "") {
            const flatMidpoints = geometry.getFlatMidpoints();
            this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
    }
    /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */ drawPolygon(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Polygon.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            context.beginPath();
            this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, /** @type {Array<number>} */ geometry.getEnds(), geometry.getStride());
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== "") {
            const flatInteriorPoint = geometry.getFlatInteriorPoint();
            this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
    }
    /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */ drawMultiPolygon(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getOrientedFlatCoordinates();
            let offset = 0;
            const endss = geometry.getEndss();
            const stride = geometry.getStride();
            context.beginPath();
            for(let i = 0, ii = endss.length; i < ii; ++i){
                const ends = endss[i];
                offset = this.drawRings_(flatCoordinates, offset, ends, stride);
            }
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== "") {
            const flatInteriorPoints = geometry.getFlatInteriorPoints();
            this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
    }
    /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */ setContextFillState_(fillState) {
        const context = this.context_;
        const contextFillState = this.contextFillState_;
        if (!contextFillState) {
            context.fillStyle = fillState.fillStyle;
            this.contextFillState_ = {
                fillStyle: fillState.fillStyle
            };
        } else if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
        }
    }
    /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */ setContextStrokeState_(strokeState) {
        const context = this.context_;
        const contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
            context.lineCap = strokeState.lineCap;
            context.setLineDash(strokeState.lineDash);
            context.lineDashOffset = strokeState.lineDashOffset;
            context.lineJoin = strokeState.lineJoin;
            context.lineWidth = strokeState.lineWidth;
            context.miterLimit = strokeState.miterLimit;
            context.strokeStyle = strokeState.strokeStyle;
            this.contextStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineDashOffset: strokeState.lineDashOffset,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle
            };
        } else {
            if (contextStrokeState.lineCap != strokeState.lineCap) {
                contextStrokeState.lineCap = strokeState.lineCap;
                context.lineCap = strokeState.lineCap;
            }
            if (!(0, _arrayJs.equals)(contextStrokeState.lineDash, strokeState.lineDash)) context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
            if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                context.lineDashOffset = strokeState.lineDashOffset;
            }
            if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                contextStrokeState.lineJoin = strokeState.lineJoin;
                context.lineJoin = strokeState.lineJoin;
            }
            if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                contextStrokeState.lineWidth = strokeState.lineWidth;
                context.lineWidth = strokeState.lineWidth;
            }
            if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                contextStrokeState.miterLimit = strokeState.miterLimit;
                context.miterLimit = strokeState.miterLimit;
            }
            if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                contextStrokeState.strokeStyle = strokeState.strokeStyle;
                context.strokeStyle = strokeState.strokeStyle;
            }
        }
    }
    /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */ setContextTextState_(textState) {
        const context = this.context_;
        const contextTextState = this.contextTextState_;
        const textAlign = textState.textAlign ? textState.textAlign : (0, _canvasJs.defaultTextAlign);
        if (!contextTextState) {
            context.font = textState.font;
            context.textAlign = textAlign;
            context.textBaseline = textState.textBaseline;
            this.contextTextState_ = {
                font: textState.font,
                textAlign: textAlign,
                textBaseline: textState.textBaseline
            };
        } else {
            if (contextTextState.font != textState.font) {
                contextTextState.font = textState.font;
                context.font = textState.font;
            }
            if (contextTextState.textAlign != textAlign) {
                contextTextState.textAlign = textAlign;
                context.textAlign = textAlign;
            }
            if (contextTextState.textBaseline != textState.textBaseline) {
                contextTextState.textBaseline = textState.textBaseline;
                context.textBaseline = textState.textBaseline;
            }
        }
    }
    /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {
        if (!fillStyle) this.fillState_ = null;
        else {
            const fillStyleColor = fillStyle.getColor();
            this.fillState_ = {
                fillStyle: (0, _colorlikeJs.asColorLike)(fillStyleColor ? fillStyleColor : (0, _canvasJs.defaultFillStyle))
            };
        }
        if (!strokeStyle) this.strokeState_ = null;
        else {
            const strokeStyleColor = strokeStyle.getColor();
            const strokeStyleLineCap = strokeStyle.getLineCap();
            const strokeStyleLineDash = strokeStyle.getLineDash();
            const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            const strokeStyleLineJoin = strokeStyle.getLineJoin();
            const strokeStyleWidth = strokeStyle.getWidth();
            const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            const lineDash = strokeStyleLineDash ? strokeStyleLineDash : (0, _canvasJs.defaultLineDash);
            this.strokeState_ = {
                lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : (0, _canvasJs.defaultLineCap),
                lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n)=>n * this.pixelRatio_),
                lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset)) * this.pixelRatio_,
                lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : (0, _canvasJs.defaultLineJoin),
                lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : (0, _canvasJs.defaultLineWidth)) * this.pixelRatio_,
                miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit),
                strokeStyle: (0, _colorlikeJs.asColorLike)(strokeStyleColor ? strokeStyleColor : (0, _canvasJs.defaultStrokeStyle))
            };
        }
    }
    /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */ setImageStyle(imageStyle) {
        let imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
            this.image_ = null;
            return;
        }
        const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
        const imageAnchor = imageStyle.getAnchor();
        const imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        const imageScale = imageStyle.getScaleArray();
        this.imageScale_ = [
            imageScale[0] * this.pixelRatio_ / imagePixelRatio,
            imageScale[1] * this.pixelRatio_ / imagePixelRatio
        ];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
    }
    /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */ setTextStyle(textStyle) {
        if (!textStyle) this.text_ = "";
        else {
            const textFillStyle = textStyle.getFill();
            if (!textFillStyle) this.textFillState_ = null;
            else {
                const textFillStyleColor = textFillStyle.getColor();
                this.textFillState_ = {
                    fillStyle: (0, _colorlikeJs.asColorLike)(textFillStyleColor ? textFillStyleColor : (0, _canvasJs.defaultFillStyle))
                };
            }
            const textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) this.textStrokeState_ = null;
            else {
                const textStrokeStyleColor = textStrokeStyle.getColor();
                const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                const textStrokeStyleWidth = textStrokeStyle.getWidth();
                const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                this.textStrokeState_ = {
                    lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : (0, _canvasJs.defaultLineCap),
                    lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : (0, _canvasJs.defaultLineDash),
                    lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset),
                    lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : (0, _canvasJs.defaultLineJoin),
                    lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : (0, _canvasJs.defaultLineWidth),
                    miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit),
                    strokeStyle: (0, _colorlikeJs.asColorLike)(textStrokeStyleColor ? textStrokeStyleColor : (0, _canvasJs.defaultStrokeStyle))
                };
            }
            const textFont = textStyle.getFont();
            const textOffsetX = textStyle.getOffsetX();
            const textOffsetY = textStyle.getOffsetY();
            const textRotateWithView = textStyle.getRotateWithView();
            const textRotation = textStyle.getRotation();
            const textScale = textStyle.getScaleArray();
            const textText = textStyle.getText();
            const textTextAlign = textStyle.getTextAlign();
            const textTextBaseline = textStyle.getTextBaseline();
            this.textState_ = {
                font: textFont !== undefined ? textFont : (0, _canvasJs.defaultFont),
                textAlign: textTextAlign !== undefined ? textTextAlign : (0, _canvasJs.defaultTextAlign),
                textBaseline: textTextBaseline !== undefined ? textTextBaseline : (0, _canvasJs.defaultTextBaseline)
            };
            this.text_ = textText !== undefined ? Array.isArray(textText) ? textText.reduce((acc, t, i)=>acc += i % 2 ? " " : t, "") : textText : "";
            this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
            this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
            this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
            this.textRotation_ = textRotation !== undefined ? textRotation : 0;
            this.textScale_ = [
                this.pixelRatio_ * textScale[0],
                this.pixelRatio_ * textScale[1]
            ];
        }
    }
}
exports.default = CanvasImmediateRenderer;

},{"../VectorContext.js":"ezpza","../../colorlike.js":"ftcFo","../../transform.js":"1BqUf","../canvas.js":"e85iQ","../../array.js":"1Fbic","../../extent.js":"6YrVc","../../geom/flat/transform.js":"cDA2L","../../geom/SimpleGeometry.js":"hLwk3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hEQxF":[function(require,module,exports) {
/**
 * @module ol/style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Circle", ()=>(0, _circleJsDefault.default));
parcelHelpers.export(exports, "Fill", ()=>(0, _fillJsDefault.default));
parcelHelpers.export(exports, "Icon", ()=>(0, _iconJsDefault.default));
parcelHelpers.export(exports, "IconImage", ()=>(0, _iconImageJsDefault.default));
parcelHelpers.export(exports, "Image", ()=>(0, _imageJsDefault.default));
parcelHelpers.export(exports, "RegularShape", ()=>(0, _regularShapeJsDefault.default));
parcelHelpers.export(exports, "Stroke", ()=>(0, _strokeJsDefault.default));
parcelHelpers.export(exports, "Style", ()=>(0, _styleJsDefault.default));
parcelHelpers.export(exports, "Text", ()=>(0, _textJsDefault.default));
var _circleJs = require("./style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("./style/Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _iconImageJs = require("./style/IconImage.js");
var _iconImageJsDefault = parcelHelpers.interopDefault(_iconImageJs);
var _imageJs = require("./style/Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _regularShapeJs = require("./style/RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
var _strokeJs = require("./style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("./style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("./style/Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);

},{"./style/Circle.js":"cSS3Y","./style/Fill.js":"4fB56","./style/Icon.js":"dJiIs","./style/IconImage.js":"8WrYM","./style/Image.js":"eyoR9","./style/RegularShape.js":"44xDg","./style/Stroke.js":"5Cq04","./style/Style.js":"fW7vC","./style/Text.js":"dwGM6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"liv8a":[function(require,module,exports) {
/**
 * @module ol/renderer/vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */ parcelHelpers.export(exports, "defaultOrder", ()=>defaultOrder);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */ parcelHelpers.export(exports, "getSquaredTolerance", ()=>getSquaredTolerance);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */ parcelHelpers.export(exports, "getTolerance", ()=>getTolerance);
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */ parcelHelpers.export(exports, "renderFeature", ()=>renderFeature);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _utilJs = require("../util.js");
/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */ const SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */ const GEOMETRY_RENDERERS = {
    "Point": renderPointGeometry,
    "LineString": renderLineStringGeometry,
    "Polygon": renderPolygonGeometry,
    "MultiPoint": renderMultiPointGeometry,
    "MultiLineString": renderMultiLineStringGeometry,
    "MultiPolygon": renderMultiPolygonGeometry,
    "GeometryCollection": renderGeometryCollectionGeometry,
    "Circle": renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
    return parseInt((0, _utilJs.getUid)(feature1), 10) - parseInt((0, _utilJs.getUid)(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
    const tolerance = getTolerance(resolution, pixelRatio);
    return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
    return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        circleReplay.drawCircle(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), "Text");
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform, declutterBuilderGroup) {
    let loading = false;
    const imageStyle = style.getImage();
    if (imageStyle) {
        const imageState = imageStyle.getImageState();
        if (imageState == (0, _imageStateJsDefault.default).LOADED || imageState == (0, _imageStateJsDefault.default).ERROR) imageStyle.unlistenImageChange(listener);
        else {
            if (imageState == (0, _imageStateJsDefault.default).IDLE) imageStyle.load();
            imageStyle.listenImageChange(listener);
            loading = true;
        }
    }
    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup);
    return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) return;
    const simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, transform);
    const renderer = style.getRenderer();
    if (renderer) renderGeometry(replayGroup, simplifiedGeometry, style, feature);
    else {
        const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */ function renderGeometry(replayGroup, geometry, style, feature) {
    if (geometry.getType() == "GeometryCollection") {
        const geometries = /** @type {import("../geom/GeometryCollection.js").default} */ geometry.getGeometries();
        for(let i = 0, ii = geometries.length; i < ii; ++i)renderGeometry(replayGroup, geometries[i], style, feature);
        return;
    }
    const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
    replay.drawCustom(/** @type {import("../geom/SimpleGeometry.js").default} */ geometry, feature, style.getRenderer(), style.getHitDetectionRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
    const geometries = geometry.getGeometriesArray();
    let i, ii;
    for(i = 0, ii = geometries.length; i < ii; ++i){
        const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
        geometryRenderer(replayGroup, geometries[i], style, feature, declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), "LineString");
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), "Text");
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), "LineString");
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawMultiLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), "Text");
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawMultiPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), "Text");
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ let declutterImageWithText;
    if (imageStyle) {
        if (imageStyle.getImageState() != (0, _imageStateJsDefault.default).LOADED) return;
        let imageBuilderGroup = builderGroup;
        if (declutterBuilderGroup) {
            const declutterMode = imageStyle.getDeclutterMode();
            if (declutterMode !== "none") {
                imageBuilderGroup = declutterBuilderGroup;
                if (declutterMode === "obstacle") {
                    // draw in non-declutter group:
                    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
                    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
                    imageReplay.drawPoint(geometry, feature);
                } else if (textStyle && textStyle.getText()) declutterImageWithText = {};
            }
        }
        const imageReplay1 = imageBuilderGroup.getBuilder(style.getZIndex(), "Image");
        imageReplay1.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay1.drawPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        let textBuilderGroup = builderGroup;
        if (declutterBuilderGroup) textBuilderGroup = declutterBuilderGroup;
        const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ let declutterImageWithText;
    if (imageStyle) {
        if (imageStyle.getImageState() != (0, _imageStateJsDefault.default).LOADED) return;
        let imageBuilderGroup = builderGroup;
        if (declutterBuilderGroup) {
            const declutterMode = imageStyle.getDeclutterMode();
            if (declutterMode !== "none") {
                imageBuilderGroup = declutterBuilderGroup;
                if (declutterMode === "obstacle") {
                    // draw in non-declutter group:
                    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
                    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
                    imageReplay.drawMultiPoint(geometry, feature);
                } else if (textStyle && textStyle.getText()) declutterImageWithText = {};
            }
        }
        const imageReplay1 = imageBuilderGroup.getBuilder(style.getZIndex(), "Image");
        imageReplay1.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay1.drawMultiPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        let textBuilderGroup = builderGroup;
        if (declutterBuilderGroup) textBuilderGroup = declutterBuilderGroup;
        const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), "Text");
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}

},{"../ImageState.js":"c4jJS","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9w7Fr":[function(require,module,exports) {
/**
 * @module ol/source/Vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */ parcelHelpers.export(exports, "VectorSourceEvent", ()=>VectorSourceEvent);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _vectorEventTypeJs = require("./VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _functionsJs = require("../functions.js");
var _loadingstrategyJs = require("../loadingstrategy.js");
var _assertsJs = require("../asserts.js");
var _extentJs = require("../extent.js");
var _arrayJs = require("../array.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
var _eventsJs = require("../events.js");
var _featureloaderJs = require("../featureloader.js");
class VectorSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */ constructor(type, feature, features){
        super(type);
        /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {import("../Feature.js").default<Geometry>|undefined}
     * @api
     */ this.feature = feature;
        /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
     * @api
     */ this.features = features;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default<Geometry>>|Collection<import("../Feature.js").default<Geometry>>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */ /**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */ class VectorSource extends (0, _sourceJsDefault.default) {
    /**
   * @param {Options<Geometry>} [options] Vector source options.
   */ constructor(options){
        options = options || {};
        super({
            attributions: options.attributions,
            interpolate: true,
            projection: undefined,
            state: "ready",
            wrapX: options.wrapX !== undefined ? options.wrapX : true
        });
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {VectorSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */ this.loader_ = (0, _functionsJs.VOID);
        /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */ this.format_ = options.format;
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
        /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */ this.url_ = options.url;
        if (options.loader !== undefined) this.loader_ = options.loader;
        else if (this.url_ !== undefined) {
            (0, _assertsJs.assert)(this.format_, 7); // `format` must be set when `url` is set
            // create a XHR feature loader for "url" and "format"
            this.loader_ = (0, _featureloaderJs.xhr)(this.url_, /** @type {import("../format/Feature.js").default} */ this.format_);
        }
        /**
     * @private
     * @type {LoadingStrategy}
     */ this.strategy_ = options.strategy !== undefined ? options.strategy : (0, _loadingstrategyJs.all);
        const useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
        /**
     * @private
     * @type {RBush<import("../Feature.js").default<Geometry>>}
     */ this.featuresRtree_ = useSpatialIndex ? new (0, _rbushJsDefault.default)() : null;
        /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */ this.loadedExtentsRtree_ = new (0, _rbushJsDefault.default)();
        /**
     * @type {number}
     * @private
     */ this.loadingExtentsCount_ = 0;
        /**
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */ this.nullGeometryFeatures_ = {};
        /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */ this.idIndex_ = {};
        /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */ this.uidIndex_ = {};
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */ this.featureChangeKeys_ = {};
        /**
     * @private
     * @type {Collection<import("../Feature.js").default<Geometry>>|null}
     */ this.featuresCollection_ = null;
        /** @type {Collection<import("../Feature.js").default<Geometry>>} */ let collection;
        /** @type {Array<import("../Feature.js").default<Geometry>>} */ let features;
        if (Array.isArray(options.features)) features = options.features;
        else if (options.features) {
            collection = options.features;
            features = collection.getArray();
        }
        if (!useSpatialIndex && collection === undefined) collection = new (0, _collectionJsDefault.default)(features);
        if (features !== undefined) this.addFeaturesInternal(features);
        if (collection !== undefined) this.bindFeaturesCollection_(collection);
    }
    /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */ addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
    }
    /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */ addFeatureInternal(feature) {
        const featureKey = (0, _utilJs.getUid)(feature);
        if (!this.addToIndex_(featureKey, feature)) {
            if (this.featuresCollection_) this.featuresCollection_.remove(feature);
            return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
            const extent = geometry.getExtent();
            if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
        } else this.nullGeometryFeatures_[featureKey] = feature;
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).ADDFEATURE, feature));
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */ setupChangeEvents_(featureKey, feature) {
        this.featureChangeKeys_[featureKey] = [
            (0, _eventsJs.listen)(feature, (0, _eventTypeJsDefault.default).CHANGE, this.handleFeatureChange_, this),
            (0, _eventsJs.listen)(feature, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.handleFeatureChange_, this)
        ];
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */ addToIndex_(featureKey, feature) {
        let valid = true;
        const id = feature.getId();
        if (id !== undefined) {
            if (!(id.toString() in this.idIndex_)) this.idIndex_[id.toString()] = feature;
            else valid = false;
        }
        if (valid) {
            (0, _assertsJs.assert)(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source
            this.uidIndex_[featureKey] = feature;
        }
        return valid;
    }
    /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */ addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
    }
    /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */ addFeaturesInternal(features) {
        const extents = [];
        const newFeatures = [];
        const geometryFeatures = [];
        for(let i = 0, length = features.length; i < length; i++){
            const feature = features[i];
            const featureKey = (0, _utilJs.getUid)(feature);
            if (this.addToIndex_(featureKey, feature)) newFeatures.push(feature);
        }
        for(let i1 = 0, length1 = newFeatures.length; i1 < length1; i1++){
            const feature1 = newFeatures[i1];
            const featureKey1 = (0, _utilJs.getUid)(feature1);
            this.setupChangeEvents_(featureKey1, feature1);
            const geometry = feature1.getGeometry();
            if (geometry) {
                const extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature1);
            } else this.nullGeometryFeatures_[featureKey1] = feature1;
        }
        if (this.featuresRtree_) this.featuresRtree_.load(extents, geometryFeatures);
        if (this.hasListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE)) for(let i2 = 0, length2 = newFeatures.length; i2 < length2; i2++)this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).ADDFEATURE, newFeatures[i2]));
    }
    /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */ bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE, /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.push(evt.feature);
                modifyingCollection = false;
            }
        });
        this.addEventListener((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.remove(evt.feature);
                modifyingCollection = false;
            }
        });
        collection.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */ (function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.addFeature(evt.element);
                modifyingCollection = false;
            }
        }).bind(this));
        collection.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */ (function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.removeFeature(evt.element);
                modifyingCollection = false;
            }
        }).bind(this));
        this.featuresCollection_ = collection;
    }
    /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */ clear(fast) {
        if (fast) {
            for(const featureId in this.featureChangeKeys_){
                const keys = this.featureChangeKeys_[featureId];
                keys.forEach((0, _eventsJs.unlistenByKey));
            }
            if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {};
                this.idIndex_ = {};
                this.uidIndex_ = {};
            }
        } else if (this.featuresRtree_) {
            const removeAndIgnoreReturn = (function(feature) {
                this.removeFeatureInternal(feature);
            }).bind(this);
            this.featuresRtree_.forEach(removeAndIgnoreReturn);
            for(const id in this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
        if (this.featuresCollection_) this.featuresCollection_.clear();
        if (this.featuresRtree_) this.featuresRtree_.clear();
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
    }
    /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeature(callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEach(callback);
        else if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    }
    /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */ forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [
            coordinate[0],
            coordinate[1],
            coordinate[0],
            coordinate[1]
        ];
        return this.forEachFeatureInExtent(extent, function(feature) {
            const geometry = feature.getGeometry();
            if (geometry.intersectsCoordinate(coordinate)) return callback(feature);
            else return undefined;
        });
    }
    /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(extent, callback);
        else if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    }
    /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(extent, /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */ function(feature) {
            const geometry = feature.getGeometry();
            if (geometry.intersectsExtent(extent)) {
                const result = callback(feature);
                if (result) return result;
            }
        });
    }
    /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */ getFeaturesCollection() {
        return this.featuresCollection_;
    }
    /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */ getFeatures() {
        let features;
        if (this.featuresCollection_) features = this.featuresCollection_.getArray().slice(0);
        else if (this.featuresRtree_) {
            features = this.featuresRtree_.getAll();
            if (!(0, _objJs.isEmpty)(this.nullGeometryFeatures_)) (0, _arrayJs.extend)(features, Object.values(this.nullGeometryFeatures_));
        }
        return /** @type {Array<import("../Feature.js").default<Geometry>>} */ features;
    }
    /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */ getFeaturesAtCoordinate(coordinate) {
        const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
            features.push(feature);
        });
        return features;
    }
    /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */ getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
            const multiWorld = projection && projection.canWrapX() && this.getWrapX();
            if (!multiWorld) return this.featuresRtree_.getInExtent(extent);
            const extents = (0, _extentJs.wrapAndSliceX)(extent, projection);
            return [].concat(...extents.map((anExtent)=>this.featuresRtree_.getInExtent(anExtent)));
        } else if (this.featuresCollection_) return this.featuresCollection_.getArray().slice(0);
        else return [];
    }
    /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */ getClosestFeatureToCoordinate(coordinate, filter) {
        // Find the closest feature using branch and bound.  We start searching an
        // infinite extent, and find the distance from the first feature found.  This
        // becomes the closest feature.  We then compute a smaller extent which any
        // closer feature must intersect.  We continue searching with this smaller
        // extent, trying to find a closer feature.  Every time we find a closer
        // feature, we update the extent being searched so that any even closer
        // feature must intersect it.  We continue until we run out of features.
        const x = coordinate[0];
        const y = coordinate[1];
        let closestFeature = null;
        const closestPoint = [
            NaN,
            NaN
        ];
        let minSquaredDistance = Infinity;
        const extent = [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ];
        filter = filter ? filter : (0, _functionsJs.TRUE);
        this.featuresRtree_.forEachInExtent(extent, /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */ function(feature) {
            if (filter(feature)) {
                const geometry = feature.getGeometry();
                const previousMinSquaredDistance = minSquaredDistance;
                minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                if (minSquaredDistance < previousMinSquaredDistance) {
                    closestFeature = feature;
                    // This is sneaky.  Reduce the extent that it is currently being
                    // searched while the R-Tree traversal using this same extent object
                    // is still in progress.  This is safe because the new extent is
                    // strictly contained by the old extent.
                    const minDistance = Math.sqrt(minSquaredDistance);
                    extent[0] = x - minDistance;
                    extent[1] = y - minDistance;
                    extent[2] = x + minDistance;
                    extent[3] = y + minDistance;
                }
            }
        });
        return closestFeature;
    }
    /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
    }
    /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */ getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */ getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */ getFormat() {
        return this.format_;
    }
    /**
   * @return {boolean} The source can have overlapping geometries.
   */ getOverlaps() {
        return this.overlaps_;
    }
    /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */ getUrl() {
        return this.url_;
    }
    /**
   * @param {Event} event Event.
   * @private
   */ handleFeatureChange_(event) {
        const feature = /** @type {import("../Feature.js").default<Geometry>} */ event.target;
        const featureKey = (0, _utilJs.getUid)(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
            if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) this.featuresRtree_.remove(feature);
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        } else {
            const extent = geometry.getExtent();
            if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
            } else if (this.featuresRtree_) this.featuresRtree_.update(extent, feature);
        }
        const id = feature.getId();
        if (id !== undefined) {
            const sid = id.toString();
            if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
            }
        } else {
            this.removeFromIdIndex_(feature);
            this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).CHANGEFEATURE, feature));
    }
    /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */ hasFeature(feature) {
        const id = feature.getId();
        if (id !== undefined) return id in this.idIndex_;
        else return (0, _utilJs.getUid)(feature) in this.uidIndex_;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        if (this.featuresRtree_) return this.featuresRtree_.isEmpty() && (0, _objJs.isEmpty)(this.nullGeometryFeatures_);
        if (this.featuresCollection_) return this.featuresCollection_.getLength() === 0;
        return true;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for(let i = 0, ii = extentsToLoad.length; i < ii; ++i){
            const extentToLoad = extentsToLoad[i];
            const alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */ function(object) {
                return (0, _extentJs.containsExtent)(object.extent, extentToLoad);
            });
            if (!alreadyLoaded) {
                ++this.loadingExtentsCount_;
                this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADSTART));
                this.loader_.call(this, extentToLoad, resolution, projection, (function(features) {
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADEND, undefined, features));
                }).bind(this), (function() {
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADERROR));
                }).bind(this));
                loadedExtentsRtree.insert(extentToLoad, {
                    extent: extentToLoad.slice()
                });
            }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    }
    refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
    }
    /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        let obj;
        loadedExtentsRtree.forEachInExtent(extent, function(object) {
            if ((0, _extentJs.equals)(object.extent, extent)) {
                obj = object;
                return true;
            }
        });
        if (obj) loadedExtentsRtree.remove(obj);
    }
    /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */ removeFeature(feature) {
        if (!feature) return;
        const featureKey = (0, _utilJs.getUid)(feature);
        if (featureKey in this.nullGeometryFeatures_) delete this.nullGeometryFeatures_[featureKey];
        else if (this.featuresRtree_) this.featuresRtree_.remove(feature);
        const result = this.removeFeatureInternal(feature);
        if (result) this.changed();
    }
    /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */ removeFeatureInternal(feature) {
        const featureKey = (0, _utilJs.getUid)(feature);
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        if (!featureChangeKeys) return;
        featureChangeKeys.forEach((0, _eventsJs.unlistenByKey));
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== undefined) delete this.idIndex_[id.toString()];
        delete this.uidIndex_[featureKey];
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, feature));
        return feature;
    }
    /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */ removeFromIdIndex_(feature) {
        let removed = false;
        for(const id in this.idIndex_)if (this.idIndex_[id] === feature) {
            delete this.idIndex_[id];
            removed = true;
            break;
        }
        return removed;
    }
    /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */ setLoader(loader) {
        this.loader_ = loader;
    }
    /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */ setUrl(url) {
        (0, _assertsJs.assert)(this.format_, 7); // `format` must be set when `url` is set
        this.url_ = url;
        this.setLoader((0, _featureloaderJs.xhr)(url, this.format_));
    }
}
exports.default = VectorSource;

},{"../Collection.js":"gReoh","../CollectionEventType.js":"82Ksf","../events/Event.js":"hwXQP","../events/EventType.js":"hrQJ6","../ObjectEventType.js":"f2U6i","../structs/RBush.js":"ewGrv","./Source.js":"bgZ4G","./VectorEventType.js":"6IruY","../functions.js":"iqv8I","../loadingstrategy.js":"i1BBH","../asserts.js":"e4TiF","../extent.js":"6YrVc","../array.js":"1Fbic","../util.js":"pLBjQ","../obj.js":"3ssAG","../events.js":"dcspA","../featureloader.js":"csnhK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ewGrv":[function(require,module,exports) {
/**
 * @module ol/structs/RBush
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */ /**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */ class RBush {
    /**
   * @param {number} [maxEntries] Max entries.
   */ constructor(maxEntries){
        /**
     * @private
     */ this.rbush_ = new (0, _rbushDefault.default)(maxEntries);
        /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */ this.items_ = {};
    }
    /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ insert(extent, value) {
        /** @type {Entry} */ const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value: value
        };
        this.rbush_.insert(item);
        this.items_[(0, _utilJs.getUid)(value)] = item;
    }
    /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */ load(extents, values) {
        const items = new Array(values.length);
        for(let i = 0, l = values.length; i < l; i++){
            const extent = extents[i];
            const value = values[i];
            /** @type {Entry} */ const item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value: value
            };
            items[i] = item;
            this.items_[(0, _utilJs.getUid)(value)] = item;
        }
        this.rbush_.load(items);
    }
    /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */ remove(value) {
        const uid = (0, _utilJs.getUid)(value);
        // get the object in which the value was wrapped when adding to the
        // internal rbush. then use that object to do the removal.
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
    }
    /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ update(extent, value) {
        const item = this.items_[(0, _utilJs.getUid)(value)];
        const bbox = [
            item.minX,
            item.minY,
            item.maxX,
            item.maxY
        ];
        if (!(0, _extentJs.equals)(bbox, extent)) {
            this.remove(value);
            this.insert(extent, value);
        }
    }
    /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */ getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */ getInExtent(extent) {
        /** @type {Entry} */ const bbox = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3]
        };
        const items = this.rbush_.search(bbox);
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */ forEach(callback) {
        return this.forEach_(this.getAll(), callback);
    }
    /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */ forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
    }
    /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */ forEach_(values, callback) {
        let result;
        for(let i = 0, l = values.length; i < l; i++){
            result = callback(values[i]);
            if (result) return result;
        }
        return result;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return (0, _objJs.isEmpty)(this.items_);
    }
    /**
   * Remove all values from the RBush.
   */ clear() {
        this.rbush_.clear();
        this.items_ = {};
    }
    /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */ getExtent(extent) {
        const data = this.rbush_.toJSON();
        return (0, _extentJs.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, extent);
    }
    /**
   * @param {RBush} rbush R-Tree.
   */ concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for(const i in rbush.items_)this.items_[i] = rbush.items_[i];
    }
}
exports.default = RBush;

},{"rbush":"k2VZu","../extent.js":"6YrVc","../util.js":"pLBjQ","../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6IruY":[function(require,module,exports) {
/**
 * @module ol/source/VectorEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */ ADDFEATURE: "addfeature",
    /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */ CHANGEFEATURE: "changefeature",
    /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */ CLEAR: "clear",
    /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */ REMOVEFEATURE: "removefeature",
    /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */ FEATURESLOADSTART: "featuresloadstart",
    /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */ FEATURESLOADEND: "featuresloadend",
    /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */ FEATURESLOADERROR: "featuresloaderror"
}; /**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i1BBH":[function(require,module,exports) {
/**
 * @module ol/loadingstrategy
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "all", ()=>all);
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "bbox", ()=>bbox);
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */ parcelHelpers.export(exports, "tile", ()=>tile);
var _projJs = require("./proj.js");
function all(extent, resolution) {
    return [
        [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ]
    ];
}
function bbox(extent, resolution) {
    return [
        extent
    ];
}
function tile(tileGrid) {
    return(/**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */ function(extent, resolution, projection) {
        const z = tileGrid.getZForResolution((0, _projJs.fromUserResolution)(resolution, projection));
        const tileRange = tileGrid.getTileRangeForExtentAndZ((0, _projJs.fromUserExtent)(extent, projection), z);
        /** @type {Array<import("./extent.js").Extent>} */ const extents = [];
        /** @type {import("./tilecoord.js").TileCoord} */ const tileCoord = [
            z,
            0,
            0
        ];
        for(tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1])for(tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2])extents.push((0, _projJs.toUserExtent)(tileGrid.getTileCoordExtent(tileCoord), projection));
        return extents;
    });
}

},{"./proj.js":"SznqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"csnhK":[function(require,module,exports) {
/**
 * @module ol/featureloader
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */ /**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */ /**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */ parcelHelpers.export(exports, "loadFeaturesXhr", ()=>loadFeaturesXhr);
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */ parcelHelpers.export(exports, "xhr", ()=>xhr);
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */ parcelHelpers.export(exports, "setWithCredentials", ()=>setWithCredentials);
var _functionsJs = require("./functions.js");
/**
 *
 * @type {boolean}
 * @private
 */ let withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", typeof url === "function" ? url(extent, resolution, projection) : url, true);
    if (format.getType() == "arraybuffer") xhr.responseType = "arraybuffer";
    xhr.withCredentials = withCredentials;
    /**
   * @param {Event} event Event.
   * @private
   */ xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
            const type = format.getType();
            /** @type {Document|Node|Object|string|undefined} */ let source;
            if (type == "json" || type == "text") source = xhr.responseText;
            else if (type == "xml") {
                source = xhr.responseXML;
                if (!source) source = new DOMParser().parseFromString(xhr.responseText, "application/xml");
            } else if (type == "arraybuffer") source = /** @type {ArrayBuffer} */ xhr.response;
            if (source) success(/** @type {Array<import("./Feature.js").default>} */ format.readFeatures(source, {
                extent: extent,
                featureProjection: projection
            }), format.readProjection(source));
            else failure();
        } else failure();
    };
    /**
   * @private
   */ xhr.onerror = failure;
    xhr.send();
}
function xhr(url, format) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   * @this {import("./source/Vector").default}
   */ return function(extent, resolution, projection, success, failure) {
        const source = /** @type {import("./source/Vector").default} */ this;
        loadFeaturesXhr(url, format, extent, resolution, projection, /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */ function(features, dataProjection) {
            source.addFeatures(features);
            if (success !== undefined) success(features);
        }, /* FIXME handle error */ failure ? failure : (0, _functionsJs.VOID));
    };
}
function setWithCredentials(xhrWithCredentials) {
    withCredentials = xhrWithCredentials;
}

},{"./functions.js":"iqv8I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6rnkA":[function(require,module,exports) {
/**
 * @module ol/layer/VectorTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseVectorJs = require("./BaseVector.js");
var _baseVectorJsDefault = parcelHelpers.interopDefault(_baseVectorJs);
var _vectorTileLayerJs = require("../renderer/canvas/VectorTileLayer.js");
var _vectorTileLayerJsDefault = parcelHelpers.interopDefault(_vectorTileLayerJs);
var _tilePropertyJs = require("./TileProperty.js");
var _tilePropertyJsDefault = parcelHelpers.interopDefault(_tilePropertyJs);
var _assertsJs = require("../asserts.js");
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature
 */ /**
 * @typedef {'hybrid' | 'vector'} VectorTileRenderType
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector
 *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of
 *    another layer with the same source).
 * @property {import("../source/VectorTile.js").default} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor|false} [background] Background color for the layer. If not specified, no
 * background will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @param {Options} [options] Options.
 * @extends {BaseVectorLayer<import("../source/VectorTile.js").default, CanvasVectorTileLayerRenderer>}
 * @api
 */ class VectorTileLayer extends (0, _baseVectorJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const baseOptions = /** @type {Object} */ Object.assign({}, options);
        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        super(/** @type {import("./BaseVector.js").Options<import("../source/VectorTile.js").default>} */ baseOptions);
        /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {VectorTileLayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {VectorTileLayerOnSignature<void>}
     */ this.un;
        const renderMode = options.renderMode || "hybrid";
        // `renderMode` must be `'hybrid'` or `'vector'`.
        (0, _assertsJs.assert)(renderMode == "hybrid" || renderMode == "vector", 28);
        /**
     * @private
     * @type {VectorTileRenderType}
     */ this.renderMode_ = renderMode;
        this.setPreload(options.preload ? options.preload : 0);
        this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
        /**
     * @return {import("./Base.js").BackgroundColor} Background color.
     * @function
     * @api
     */ this.getBackground;
        /**
     * @param {import("./Base.js").BackgroundColor} background Background color.
     * @function
     * @api
     */ this.setBackground;
    }
    createRenderer() {
        return new (0, _vectorTileLayerJsDefault.default)(this);
    }
    /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */ getFeatures(pixel) {
        return super.getFeatures(pixel);
    }
    /**
   * @return {VectorTileRenderType} The render mode.
   */ getRenderMode() {
        return this.renderMode_;
    }
    /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */ getPreload() {
        return /** @type {number} */ this.get((0, _tilePropertyJsDefault.default).PRELOAD);
    }
    /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */ getUseInterimTilesOnError() {
        return /** @type {boolean} */ this.get((0, _tilePropertyJsDefault.default).USE_INTERIM_TILES_ON_ERROR);
    }
    /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */ setPreload(preload) {
        this.set((0, _tilePropertyJsDefault.default).PRELOAD, preload);
    }
    /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */ setUseInterimTilesOnError(useInterimTilesOnError) {
        this.set((0, _tilePropertyJsDefault.default).USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    }
}
exports.default = VectorTileLayer;

},{"./BaseVector.js":"2tWeN","../renderer/canvas/VectorTileLayer.js":"7Jb5f","./TileProperty.js":"cIL12","../asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Jb5f":[function(require,module,exports) {
/**
 * @module ol/renderer/canvas/VectorTileLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderGroupJs = require("../../render/canvas/BuilderGroup.js");
var _builderGroupJsDefault = parcelHelpers.interopDefault(_builderGroupJs);
var _executorGroupJs = require("../../render/canvas/ExecutorGroup.js");
var _executorGroupJsDefault = parcelHelpers.interopDefault(_executorGroupJs);
var _tileLayerJs = require("./TileLayer.js");
var _tileLayerJsDefault = parcelHelpers.interopDefault(_tileLayerJs);
var _tileStateJs = require("../../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _viewHintJs = require("../../ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hitdetectJs = require("../../render/canvas/hitdetect.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _vectorJs = require("../vector.js");
var _utilJs = require("../../util.js");
var _sizeJs = require("../../size.js");
var _coordinateJs = require("../../coordinate.js");
/**
 * @type {!Object<string, Array<import("../../render/canvas.js").BuilderType>>}
 */ const IMAGE_REPLAYS = {
    "image": [
        "Polygon",
        "Circle",
        "LineString",
        "Image",
        "Text"
    ],
    "hybrid": [
        "Polygon",
        "LineString"
    ],
    "vector": []
};
/**
 * @type {!Object<string, Array<import("../../render/canvas.js").BuilderType>>}
 */ const VECTOR_REPLAYS = {
    "hybrid": [
        "Image",
        "Text",
        "Default"
    ],
    "vector": [
        "Polygon",
        "Circle",
        "LineString",
        "Image",
        "Text",
        "Default"
    ]
};
/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 * @extends {CanvasTileLayerRenderer<import("../../layer/VectorTile.js").default>}
 */ class CanvasVectorTileLayerRenderer extends (0, _tileLayerJsDefault.default) {
    /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */ constructor(layer){
        super(layer);
        /** @private */ this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        /**
     * @private
     * @type {number}
     */ this.renderedLayerRevision_;
        /**
     * @private
     * @type {import("../../transform").Transform}
     */ this.renderedPixelToCoordinateTransform_ = null;
        /**
     * @private
     * @type {number}
     */ this.renderedRotation_;
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.tmpTransform_ = (0, _transformJs.create)();
    }
    /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */ prepareTile(tile, pixelRatio, projection) {
        let render;
        const state = tile.getState();
        if (state === (0, _tileStateJsDefault.default).LOADED || state === (0, _tileStateJsDefault.default).ERROR) {
            this.updateExecutorGroup_(tile, pixelRatio, projection);
            if (this.tileImageNeedsRender_(tile)) render = true;
        }
        return render;
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */ getTile(z, x, y, frameState) {
        const pixelRatio = frameState.pixelRatio;
        const viewState = frameState.viewState;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const layer = this.getLayer();
        const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);
        const viewHints = frameState.viewHints;
        const hifi = !(viewHints[(0, _viewHintJsDefault.default).ANIMATING] || viewHints[(0, _viewHintJsDefault.default).INTERACTING]);
        if (hifi || !tile.wantedResolution) tile.wantedResolution = resolution;
        const render = this.prepareTile(tile, pixelRatio, projection);
        if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== "vector") this.renderTileImage_(tile, frameState);
        return super.getTile(z, x, y, frameState);
    }
    /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */ isDrawableTile(tile) {
        const layer = this.getLayer();
        return super.isDrawableTile(tile) && (layer.getRenderMode() === "vector" ? (0, _utilJs.getUid)(layer) in tile.executorGroups : tile.hasContext(layer));
    }
    /**
   * @inheritDoc
   */ getTileImage(tile) {
        return tile.getImage(this.getLayer());
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        const layerRevision = this.getLayer().getRevision();
        if (this.renderedLayerRevision_ !== layerRevision) {
            this.renderedLayerRevision_ = layerRevision;
            this.renderedTiles.length = 0;
        }
        return super.prepareFrame(frameState);
    }
    /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */ updateExecutorGroup_(tile, pixelRatio, projection) {
        const layer = /** @type {import("../../layer/VectorTile.js").default} */ this.getLayer();
        const revision = layer.getRevision();
        const renderOrder = layer.getRenderOrder() || null;
        const resolution = tile.wantedResolution;
        const builderState = tile.getReplayState(layer);
        if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) return;
        const source = layer.getSource();
        const declutter = layer.getDeclutter();
        const sourceTileGrid = source.getTileGrid();
        const tileGrid = source.getTileGridForProjection(projection);
        const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
        const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);
        const layerUid = (0, _utilJs.getUid)(layer);
        delete tile.hitDetectionImageData[layerUid];
        tile.executorGroups[layerUid] = [];
        if (declutter) tile.declutterExecutorGroups[layerUid] = [];
        builderState.dirty = false;
        for(let t = 0, tt = sourceTiles.length; t < tt; ++t){
            const sourceTile = sourceTiles[t];
            if (sourceTile.getState() != (0, _tileStateJsDefault.default).LOADED) continue;
            const sourceTileCoord = sourceTile.tileCoord;
            const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
            const sharedExtent = (0, _extentJs.getIntersection)(tileExtent, sourceTileExtent);
            const builderExtent = (0, _extentJs.buffer)(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);
            const bufferedExtent = (0, _extentJs.equals)(sourceTileExtent, sharedExtent) ? null : builderExtent;
            const builderGroup = new (0, _builderGroupJsDefault.default)(0, builderExtent, resolution, pixelRatio);
            const declutterBuilderGroup = declutter ? new (0, _builderGroupJsDefault.default)(0, sharedExtent, resolution, pixelRatio) : undefined;
            const squaredTolerance = (0, _vectorJs.getSquaredTolerance)(resolution, pixelRatio);
            /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @this {CanvasVectorTileLayerRenderer}
       */ const render = function(feature) {
                let styles;
                const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
                if (styleFunction) styles = styleFunction(feature, resolution);
                if (styles) {
                    const dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
                    builderState.dirty = builderState.dirty || dirty;
                }
            };
            const features = sourceTile.getFeatures();
            if (renderOrder && renderOrder !== builderState.renderedRenderOrder) features.sort(renderOrder);
            for(let i = 0, ii = features.length; i < ii; ++i){
                const feature = features[i];
                if (!bufferedExtent || (0, _extentJs.intersects)(bufferedExtent, feature.getGeometry().getExtent())) render.call(this, feature);
            }
            const executorGroupInstructions = builderGroup.finish();
            // no need to clip when the render tile is covered by a single source tile
            const replayExtent = layer.getRenderMode() !== "vector" && declutter && sourceTiles.length === 1 ? null : sharedExtent;
            const renderingReplayGroup = new (0, _executorGroupJsDefault.default)(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
            tile.executorGroups[layerUid].push(renderingReplayGroup);
            if (declutterBuilderGroup) {
                const declutterExecutorGroup = new (0, _executorGroupJsDefault.default)(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
                tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
            }
        }
        builderState.renderedRevision = revision;
        builderState.renderedRenderOrder = renderOrder;
        builderState.renderedResolution = resolution;
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
        const layer = this.getLayer();
        const source = layer.getSource();
        const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
        const hitExtent = (0, _extentJs.boundingExtent)([
            coordinate
        ]);
        (0, _extentJs.buffer)(hitExtent, resolution * hitTolerance, hitExtent);
        /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */ const features = {};
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position.
     * @return {T|undefined} Callback result.
     */ const featureCallback = function(feature, geometry, distanceSq) {
            let key = feature.getId();
            if (key === undefined) key = (0, _utilJs.getUid)(feature);
            const match = features[key];
            if (!match) {
                if (distanceSq === 0) {
                    features[key] = true;
                    return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                    feature: feature,
                    layer: layer,
                    geometry: geometry,
                    distanceSq: distanceSq,
                    callback: callback
                });
            } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                    features[key] = true;
                    matches.splice(matches.lastIndexOf(match), 1);
                    return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
            }
            return undefined;
        };
        const renderedTiles = /** @type {Array<import("../../VectorRenderTile.js").default>} */ this.renderedTiles;
        let found;
        for(let i = 0, ii = renderedTiles.length; !found && i < ii; ++i){
            const tile = renderedTiles[i];
            const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
            if (!(0, _extentJs.intersects)(tileExtent, hitExtent)) continue;
            const layerUid = (0, _utilJs.getUid)(layer);
            const executorGroups = [
                tile.executorGroups[layerUid]
            ];
            const declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];
            if (declutterExecutorGroups) executorGroups.push(declutterExecutorGroups);
            executorGroups.some((executorGroups)=>{
                const declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map((item)=>item.value) : null;
                for(let t = 0, tt = executorGroups.length; t < tt; ++t){
                    const executorGroup = executorGroups[t];
                    found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);
                    if (found) return true;
                }
            });
        }
        return found;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */ getFeatures(pixel) {
        return new Promise((function(resolve, reject) {
            const layer = /** @type {import("../../layer/VectorTile.js").default} */ this.getLayer();
            const layerUid = (0, _utilJs.getUid)(layer);
            const source = layer.getSource();
            const projection = this.renderedProjection;
            const projectionExtent = projection.getExtent();
            const resolution = this.renderedResolution;
            const tileGrid = source.getTileGridForProjection(projection);
            const coordinate = (0, _transformJs.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice());
            const tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
            let tile;
            for(let i = 0, ii = this.renderedTiles.length; i < ii; ++i)if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {
                tile = this.renderedTiles[i];
                if (tile.getState() === (0, _tileStateJsDefault.default).LOADED) {
                    const extent = tileGrid.getTileCoordExtent(tile.tileCoord);
                    if (source.getWrapX() && projection.canWrapX() && !(0, _extentJs.containsExtent)(projectionExtent, extent)) (0, _coordinateJs.wrapX)(coordinate, projection);
                    break;
                }
                tile = undefined;
            }
            if (!tile || tile.loadingSourceTiles > 0) {
                resolve([]);
                return;
            }
            const extent1 = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
            const corner = (0, _extentJs.getTopLeft)(extent1);
            const tilePixel = [
                (coordinate[0] - corner[0]) / resolution,
                (corner[1] - coordinate[1]) / resolution
            ];
            const features = tile.getSourceTiles().reduce(function(accumulator, sourceTile) {
                return accumulator.concat(sourceTile.getFeatures());
            }, []);
            let hitDetectionImageData = tile.hitDetectionImageData[layerUid];
            if (!hitDetectionImageData && !this.animatingOrInteracting_) {
                const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(tileGrid.getZForResolution(resolution, source.zDirection)));
                const rotation = this.renderedRotation_;
                const transforms = [
                    this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), tileSize[0] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION), tileSize[1] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION), 0)
                ];
                hitDetectionImageData = (0, _hitdetectJs.createHitDetectionImageData)(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);
                tile.hitDetectionImageData[layerUid] = hitDetectionImageData;
            }
            resolve((0, _hitdetectJs.hitDetect)(tilePixel, features, hitDetectionImageData));
        }).bind(this));
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */ handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) layer.changed();
    }
    /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */ handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
    }
    /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        const context = this.context;
        const alpha = context.globalAlpha;
        context.globalAlpha = this.getLayer().getOpacity();
        const viewHints = frameState.viewHints;
        const hifi = !(viewHints[(0, _viewHintJsDefault.default).ANIMATING] || viewHints[(0, _viewHintJsDefault.default).INTERACTING]);
        const tiles = /** @type {Array<import("../../VectorRenderTile.js").default>} */ this.renderedTiles;
        for(let i = 0, ii = tiles.length; i < ii; ++i){
            const tile = tiles[i];
            const declutterExecutorGroups = tile.declutterExecutorGroups[(0, _utilJs.getUid)(this.getLayer())];
            if (declutterExecutorGroups) for(let j = declutterExecutorGroups.length - 1; j >= 0; --j)declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);
        }
        context.globalAlpha = alpha;
    }
    getTileRenderTransform(tile, frameState) {
        const pixelRatio = frameState.pixelRatio;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const rotation = viewState.rotation;
        const size = frameState.size;
        const width = Math.round(size[0] * pixelRatio);
        const height = Math.round(size[1] * pixelRatio);
        const source = this.getLayer().getSource();
        const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
        const tileCoord = tile.tileCoord;
        const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
        const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
        const transform = (0, _transformJs.multiply)((0, _transformJs.scale)(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
        return transform;
    }
    /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */ postRender(context, frameState) {
        const viewHints = frameState.viewHints;
        const hifi = !(viewHints[(0, _viewHintJsDefault.default).ANIMATING] || viewHints[(0, _viewHintJsDefault.default).INTERACTING]);
        this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
        this.renderedRotation_ = frameState.viewState.rotation;
        const layer = /** @type {import("../../layer/VectorTile.js").default} */ this.getLayer();
        const renderMode = layer.getRenderMode();
        const alpha = context.globalAlpha;
        context.globalAlpha = layer.getOpacity();
        const replayTypes = VECTOR_REPLAYS[renderMode];
        const viewState = frameState.viewState;
        const rotation = viewState.rotation;
        const tileSource = layer.getSource();
        const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
        const tiles = this.renderedTiles;
        const clips = [];
        const clipZs = [];
        let ready = true;
        for(let i = tiles.length - 1; i >= 0; --i){
            const tile = /** @type {import("../../VectorRenderTile.js").default} */ tiles[i];
            ready = ready && !tile.getReplayState(layer).dirty;
            const executorGroups = tile.executorGroups[(0, _utilJs.getUid)(layer)].filter((group)=>group.hasExecutors(replayTypes));
            if (executorGroups.length === 0) continue;
            const transform = this.getTileRenderTransform(tile, frameState);
            const currentZ = tile.tileCoord[0];
            let contextSaved = false;
            // Clip mask for regions in this tile that already filled by a higher z tile
            const currentClip = executorGroups[0].getClipCoords(transform);
            if (currentClip) {
                for(let j = 0, jj = clips.length; j < jj; ++j)if (z !== currentZ && currentZ < clipZs[j]) {
                    const clip = clips[j];
                    if ((0, _extentJs.intersects)([
                        currentClip[0],
                        currentClip[3],
                        currentClip[4],
                        currentClip[7]
                    ], [
                        clip[0],
                        clip[3],
                        clip[4],
                        clip[7]
                    ])) {
                        if (!contextSaved) {
                            context.save();
                            contextSaved = true;
                        }
                        context.beginPath();
                        // counter-clockwise (outer ring) for current tile
                        context.moveTo(currentClip[0], currentClip[1]);
                        context.lineTo(currentClip[2], currentClip[3]);
                        context.lineTo(currentClip[4], currentClip[5]);
                        context.lineTo(currentClip[6], currentClip[7]);
                        // clockwise (inner ring) for higher z tile
                        context.moveTo(clip[6], clip[7]);
                        context.lineTo(clip[4], clip[5]);
                        context.lineTo(clip[2], clip[3]);
                        context.lineTo(clip[0], clip[1]);
                        context.clip();
                    }
                }
                clips.push(currentClip);
                clipZs.push(currentZ);
            }
            for(let t = 0, tt = executorGroups.length; t < tt; ++t){
                const executorGroup = executorGroups[t];
                executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);
            }
            if (contextSaved) context.restore();
        }
        context.globalAlpha = alpha;
        this.ready = ready;
        super.postRender(context, frameState);
    }
    /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder group for decluttering.
   * @return {boolean} `true` if an image is loading.
   */ renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup) {
        if (!styles) return false;
        let loading = false;
        if (Array.isArray(styles)) for(let i = 0, ii = styles.length; i < ii; ++i)loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup) || loading;
        else loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup);
        return loading;
    }
    /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */ tileImageNeedsRender_(tile) {
        const layer = /** @type {import("../../layer/VectorTile.js").default} */ this.getLayer();
        if (layer.getRenderMode() === "vector") return false;
        const replayState = tile.getReplayState(layer);
        const revision = layer.getRevision();
        const resolution = tile.wantedResolution;
        return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;
    }
    /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */ renderTileImage_(tile, frameState) {
        const layer = /** @type {import("../../layer/VectorTile.js").default} */ this.getLayer();
        const replayState = tile.getReplayState(layer);
        const revision = layer.getRevision();
        const executorGroups = tile.executorGroups[(0, _utilJs.getUid)(layer)];
        replayState.renderedTileRevision = revision;
        const tileCoord = tile.wrappedTileCoord;
        const z = tileCoord[0];
        const source = layer.getSource();
        let pixelRatio = frameState.pixelRatio;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const tileGrid = source.getTileGridForProjection(projection);
        const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);
        const renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;
        const resolution = tileGrid.getResolution(z);
        const context = tile.getContext(layer);
        // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles
        pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
        const size = source.getTilePixelSize(z, pixelRatio, projection);
        context.canvas.width = size[0];
        context.canvas.height = size[1];
        const renderScale = pixelRatio / renderPixelRatio;
        if (renderScale !== 1) {
            const canvasTransform = (0, _transformJs.reset)(this.tmpTransform_);
            (0, _transformJs.scale)(canvasTransform, renderScale, renderScale);
            context.setTransform.apply(context, canvasTransform);
        }
        const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
        const pixelScale = renderPixelRatio / resolution;
        const transform = (0, _transformJs.reset)(this.tmpTransform_);
        (0, _transformJs.scale)(transform, pixelScale, -pixelScale);
        (0, _transformJs.translate)(transform, -tileExtent[0], -tileExtent[3]);
        for(let i = 0, ii = executorGroups.length; i < ii; ++i){
            const executorGroup = executorGroups[i];
            executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
        }
        replayState.renderedTileResolution = tile.wantedResolution;
    }
}
exports.default = CanvasVectorTileLayerRenderer;

},{"../../render/canvas/BuilderGroup.js":"kQbDd","../../render/canvas/ExecutorGroup.js":"eUidV","./TileLayer.js":"6bgv8","../../TileState.js":"2fodI","../../ViewHint.js":"6THmF","../../render/canvas/hitdetect.js":"hriIE","../../transform.js":"1BqUf","../../extent.js":"6YrVc","../vector.js":"liv8a","../../util.js":"pLBjQ","../../size.js":"lKEPe","../../coordinate.js":"85Vu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Tarl":[function(require,module,exports) {
/**
 * @module ol/source/VectorTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sets the loader for a tile.
 * @param {import("../VectorTile.js").default} tile Vector tile.
 * @param {string} url URL.
 */ parcelHelpers.export(exports, "defaultLoadFunction", ()=>defaultLoadFunction);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _vectorTileJs = require("../VectorTile.js");
var _vectorTileJsDefault = parcelHelpers.interopDefault(_vectorTileJs);
var _tileCacheJs = require("../TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileGridJs = require("../tilegrid/TileGrid.js");
var _tileGridJsDefault = parcelHelpers.interopDefault(_tileGridJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _urlTileJs = require("./UrlTile.js");
var _urlTileJsDefault = parcelHelpers.interopDefault(_urlTileJs);
var _vectorRenderTileJs = require("../VectorRenderTile.js");
var _vectorRenderTileJsDefault = parcelHelpers.interopDefault(_vectorRenderTileJs);
var _commonJs = require("../tilegrid/common.js");
var _extentJs = require("../extent.js");
var _tilegridJs = require("../tilegrid.js");
var _tilecoordJs = require("../tilecoord.js");
var _objJs = require("../obj.js");
var _featureloaderJs = require("../featureloader.js");
var _sizeJs = require("../size.js");
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {import("../format/Feature.js").default} [format] Feature format for tiles. Used and required by the default.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/VectorTile~VectorTile}.
 * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. Could look like this for pbf tiles:
 * ```js
 * function(tile, url) {
 *   tile.setLoader(function(extent, resolution, projection) {
 *     fetch(url).then(function(response) {
 *       response.arrayBuffer().then(function(data) {
 *         const format = tile.getFormat() // ol/format/MVT configured as source format
 *         const features = format.readFeatures(data, {
 *           extent: extent,
 *           featureProjection: projection
 *         });
 *         tile.setFeatures(features);
 *       });
 *     });
 *   });
 * }
 * ```
 * If you do not need extent, resolution and projection to get the features for a tile (e.g.
 * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure
 * to call `setFeatures()` on the tile:
 * ```js
 * const format = new GeoJSON({featureProjection: map.getView().getProjection()});
 * async function tileLoadFunction(tile, url) {
 *   const response = await fetch(url);
 *   const data = await response.json();
 *   tile.setFeatures(format.readFeatures(data));
 * }
 * ```
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=1]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature
 * editing.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */ class VectorTile extends (0, _urlTileJsDefault.default) {
    /**
   * @param {!Options} options Vector tile options.
   */ constructor(options){
        const projection = options.projection || "EPSG:3857";
        const extent = options.extent || (0, _tilegridJs.extentFromProjection)(projection);
        const tileGrid = options.tileGrid || (0, _tilegridJs.createXYZ)({
            extent: extent,
            maxResolution: options.maxResolution,
            maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,
            minZoom: options.minZoom,
            tileSize: options.tileSize || 512
        });
        super({
            attributions: options.attributions,
            attributionsCollapsible: options.attributionsCollapsible,
            cacheSize: options.cacheSize,
            interpolate: true,
            opaque: false,
            projection: projection,
            state: options.state,
            tileGrid: tileGrid,
            tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,
            tileUrlFunction: options.tileUrlFunction,
            url: options.url,
            urls: options.urls,
            wrapX: options.wrapX === undefined ? true : options.wrapX,
            transition: options.transition,
            zDirection: options.zDirection === undefined ? 1 : options.zDirection
        });
        /**
     * @private
     * @type {import("../format/Feature.js").default|null}
     */ this.format_ = options.format ? options.format : null;
        /**
     * @private
     * @type {TileCache}
     */ this.sourceTileCache = new (0, _tileCacheJsDefault.default)(this.tileCache.highWaterMark);
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
        /**
     * @protected
     * @type {typeof import("../VectorTile.js").default}
     */ this.tileClass = options.tileClass ? options.tileClass : (0, _vectorTileJsDefault.default);
        /**
     * @private
     * @type {Object<string, import("../tilegrid/TileGrid.js").default>}
     */ this.tileGrids_ = {};
    }
    /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */ getFeaturesInExtent(extent) {
        const features = [];
        const tileCache = this.tileCache;
        if (tileCache.getCount() === 0) return features;
        const z = (0, _tilecoordJs.fromKey)(tileCache.peekFirstKey())[0];
        const tileGrid = this.tileGrid;
        tileCache.forEach(function(tile) {
            if (tile.tileCoord[0] !== z || tile.getState() !== (0, _tileStateJsDefault.default).LOADED) return;
            const sourceTiles = tile.getSourceTiles();
            for(let i = 0, ii = sourceTiles.length; i < ii; ++i){
                const sourceTile = sourceTiles[i];
                const tileCoord = sourceTile.tileCoord;
                if ((0, _extentJs.intersects)(extent, tileGrid.getTileCoordExtent(tileCoord))) {
                    const tileFeatures = sourceTile.getFeatures();
                    if (tileFeatures) for(let j = 0, jj = tileFeatures.length; j < jj; ++j){
                        const candidate = tileFeatures[j];
                        const geometry = candidate.getGeometry();
                        if ((0, _extentJs.intersects)(extent, geometry.getExtent())) features.push(candidate);
                    }
                }
            }
        });
        return features;
    }
    /**
   * @return {boolean} The source can have overlapping geometries.
   */ getOverlaps() {
        return this.overlaps_;
    }
    /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */ clear() {
        this.tileCache.clear();
        this.sourceTileCache.clear();
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */ expireCache(projection, usedTiles) {
        const tileCache = this.getTileCacheForProjection(projection);
        const usedSourceTiles = Object.keys(usedTiles).reduce((acc, key)=>{
            const cacheKey = (0, _tilecoordJs.getCacheKeyForTileKey)(key);
            const tile = tileCache.peek(cacheKey);
            if (tile) {
                const sourceTiles = tile.sourceTiles;
                for(let i = 0, ii = sourceTiles.length; i < ii; ++i)acc[sourceTiles[i].getKey()] = true;
            }
            return acc;
        }, {});
        super.expireCache(projection, usedTiles);
        this.sourceTileCache.expireCache(usedSourceTiles);
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */ getSourceTiles(pixelRatio, projection, tile) {
        if (tile.getState() === (0, _tileStateJsDefault.default).IDLE) {
            tile.setState((0, _tileStateJsDefault.default).LOADING);
            const urlTileCoord = tile.wrappedTileCoord;
            const tileGrid = this.getTileGridForProjection(projection);
            const extent = tileGrid.getTileCoordExtent(urlTileCoord);
            const z = urlTileCoord[0];
            const resolution = tileGrid.getResolution(z);
            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space
            (0, _extentJs.buffer)(extent, -resolution, extent);
            const sourceTileGrid = this.tileGrid;
            const sourceExtent = sourceTileGrid.getExtent();
            if (sourceExtent) (0, _extentJs.getIntersection)(extent, sourceExtent, extent);
            const sourceZ = sourceTileGrid.getZForResolution(resolution, this.zDirection);
            sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord)=>{
                const tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
                const sourceTile = this.sourceTileCache.containsKey(tileUrl) ? this.sourceTileCache.get(tileUrl) : new this.tileClass(sourceTileCoord, tileUrl ? (0, _tileStateJsDefault.default).IDLE : (0, _tileStateJsDefault.default).EMPTY, tileUrl, this.format_, this.tileLoadFunction);
                tile.sourceTiles.push(sourceTile);
                const sourceTileState = sourceTile.getState();
                if (sourceTileState < (0, _tileStateJsDefault.default).LOADED) {
                    const listenChange = (event)=>{
                        this.handleTileChange(event);
                        const state = sourceTile.getState();
                        if (state === (0, _tileStateJsDefault.default).LOADED || state === (0, _tileStateJsDefault.default).ERROR) {
                            const sourceTileKey = sourceTile.getKey();
                            if (sourceTileKey in tile.errorTileKeys) {
                                if (sourceTile.getState() === (0, _tileStateJsDefault.default).LOADED) delete tile.errorTileKeys[sourceTileKey];
                            } else tile.loadingSourceTiles--;
                            if (state === (0, _tileStateJsDefault.default).ERROR) tile.errorTileKeys[sourceTileKey] = true;
                            else sourceTile.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, listenChange);
                            if (tile.loadingSourceTiles === 0) tile.setState((0, _objJs.isEmpty)(tile.errorTileKeys) ? (0, _tileStateJsDefault.default).LOADED : (0, _tileStateJsDefault.default).ERROR);
                        }
                    };
                    sourceTile.addEventListener((0, _eventTypeJsDefault.default).CHANGE, listenChange);
                    tile.loadingSourceTiles++;
                }
                if (sourceTileState === (0, _tileStateJsDefault.default).IDLE) {
                    sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
                    sourceTile.projection = projection;
                    sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);
                    this.sourceTileCache.set(tileUrl, sourceTile);
                    sourceTile.load();
                }
            });
            if (!tile.loadingSourceTiles) tile.setState(tile.sourceTiles.some((sourceTile)=>sourceTile.getState() === (0, _tileStateJsDefault.default).ERROR) ? (0, _tileStateJsDefault.default).ERROR : (0, _tileStateJsDefault.default).LOADED);
        }
        return tile.sourceTiles;
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */ getTile(z, x, y, pixelRatio, projection) {
        const coordKey = (0, _tilecoordJs.getKeyZXY)(z, x, y);
        const key = this.getKey();
        let tile;
        if (this.tileCache.containsKey(coordKey)) {
            tile = this.tileCache.get(coordKey);
            if (tile.key === key) return tile;
        }
        const tileCoord = [
            z,
            x,
            y
        ];
        let urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        const sourceExtent = this.getTileGrid().getExtent();
        const tileGrid = this.getTileGridForProjection(projection);
        if (urlTileCoord && sourceExtent) {
            const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);
            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space
            (0, _extentJs.buffer)(tileExtent, -tileGrid.getResolution(z), tileExtent);
            if (!(0, _extentJs.intersects)(sourceExtent, tileExtent)) urlTileCoord = null;
        }
        let empty = true;
        if (urlTileCoord !== null) {
            const sourceTileGrid = this.tileGrid;
            const resolution = tileGrid.getResolution(z);
            const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);
            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space
            const extent = tileGrid.getTileCoordExtent(urlTileCoord);
            (0, _extentJs.buffer)(extent, -resolution, extent);
            sourceTileGrid.forEachTileCoord(extent, sourceZ, (function(sourceTileCoord) {
                empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
            }).bind(this));
        }
        const newTile = new (0, _vectorRenderTileJsDefault.default)(tileCoord, empty ? (0, _tileStateJsDefault.default).EMPTY : (0, _tileStateJsDefault.default).IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));
        newTile.key = key;
        if (tile) {
            newTile.interimTile = tile;
            newTile.refreshInterimChain();
            this.tileCache.replace(coordKey, newTile);
        } else this.tileCache.set(coordKey, newTile);
        return newTile;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */ getTileGridForProjection(projection) {
        const code = projection.getCode();
        let tileGrid = this.tileGrids_[code];
        if (!tileGrid) {
            // A tile grid that matches the tile size of the source tile grid is more
            // likely to have 1:1 relationships between source tiles and rendered tiles.
            const sourceTileGrid = this.tileGrid;
            const resolutions = sourceTileGrid.getResolutions().slice();
            const origins = resolutions.map(function(resolution, z) {
                return sourceTileGrid.getOrigin(z);
            });
            const tileSizes = resolutions.map(function(resolution, z) {
                return sourceTileGrid.getTileSize(z);
            });
            const length = (0, _commonJs.DEFAULT_MAX_ZOOM) + 1;
            for(let z = resolutions.length; z < length; ++z){
                resolutions.push(resolutions[z - 1] / 2);
                origins.push(origins[z - 1]);
                tileSizes.push(tileSizes[z - 1]);
            }
            tileGrid = new (0, _tileGridJsDefault.default)({
                extent: sourceTileGrid.getExtent(),
                origins: origins,
                resolutions: resolutions,
                tileSizes: tileSizes
            });
            this.tileGrids_[code] = tileGrid;
        }
        return tileGrid;
    }
    /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */ getTilePixelRatio(pixelRatio) {
        return pixelRatio;
    }
    /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */ getTilePixelSize(z, pixelRatio, projection) {
        const tileGrid = this.getTileGridForProjection(projection);
        const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(z), this.tmpSize);
        return [
            Math.round(tileSize[0] * pixelRatio),
            Math.round(tileSize[1] * pixelRatio)
        ];
    }
    /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ updateCacheSize(tileCount, projection) {
        super.updateCacheSize(tileCount * 2, projection);
        this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;
    }
}
exports.default = VectorTile;
function defaultLoadFunction(tile, url) {
    tile.setLoader(/**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */ function(extent, resolution, projection) {
        (0, _featureloaderJs.loadFeaturesXhr)(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));
    });
}

},{"../events/EventType.js":"hrQJ6","../VectorTile.js":"a0ujH","../TileCache.js":"3AgyC","../tilegrid/TileGrid.js":"cZOJJ","../TileState.js":"2fodI","./UrlTile.js":"2X3sL","../VectorRenderTile.js":"eHNhu","../tilegrid/common.js":"bxYGl","../extent.js":"6YrVc","../tilegrid.js":"1Yr4i","../tilecoord.js":"bZ2LT","../obj.js":"3ssAG","../featureloader.js":"csnhK","../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0ujH":[function(require,module,exports) {
/**
 * @module ol/VectorTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
class VectorTile extends (0, _tileJsDefault.default) {
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */ constructor(tileCoord, state, src, format, tileLoadFunction, options){
        super(tileCoord, state, options);
        /**
     * Extent of this tile; set by the source.
     * @type {import("./extent.js").Extent}
     */ this.extent = null;
        /**
     * @private
     * @type {import("./format/Feature.js").default}
     */ this.format_ = format;
        /**
     * @private
     * @type {Array<import("./Feature.js").default>}
     */ this.features_ = null;
        /**
     * @private
     * @type {import("./featureloader.js").FeatureLoader}
     */ this.loader_;
        /**
     * Feature projection of this tile; set by the source.
     * @type {import("./proj/Projection.js").default}
     */ this.projection = null;
        /**
     * Resolution of this tile; set by the source.
     * @type {number}
     */ this.resolution;
        /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */ this.tileLoadFunction_ = tileLoadFunction;
        /**
     * @private
     * @type {string}
     */ this.url_ = src;
        this.key = src;
    }
    /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */ getFormat() {
        return this.format_;
    }
    /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */ getFeatures() {
        return this.features_;
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _tileStateJsDefault.default).IDLE) {
            this.setState((0, _tileStateJsDefault.default).LOADING);
            this.tileLoadFunction_(this, this.url_);
            if (this.loader_) this.loader_(this.extent, this.resolution, this.projection);
        }
    }
    /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */ onLoad(features, dataProjection) {
        this.setFeatures(features);
    }
    /**
   * Handler for tile load errors.
   */ onError() {
        this.setState((0, _tileStateJsDefault.default).ERROR);
    }
    /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").default>} features Features.
   * @api
   */ setFeatures(features) {
        this.features_ = features;
        this.setState((0, _tileStateJsDefault.default).LOADED);
    }
    /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */ setLoader(loader) {
        this.loader_ = loader;
    }
}
exports.default = VectorTile;

},{"./Tile.js":"4sqb5","./TileState.js":"2fodI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eHNhu":[function(require,module,exports) {
/**
 * @module ol/VectorRenderTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _domJs = require("./dom.js");
var _utilJs = require("./util.js");
/**
 * @typedef {Object} ReplayState
 * @property {boolean} dirty Dirty.
 * @property {null|import("./render.js").OrderFunction} renderedRenderOrder RenderedRenderOrder.
 * @property {number} renderedTileRevision RenderedTileRevision.
 * @property {number} renderedResolution RenderedResolution.
 * @property {number} renderedRevision RenderedRevision.
 * @property {number} renderedTileResolution RenderedTileResolution.
 * @property {number} renderedTileZ RenderedTileZ.
 */ /**
 * @type {Array<HTMLCanvasElement>}
 */ const canvasPool = [];
class VectorRenderTile extends (0, _tileJsDefault.default) {
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */ constructor(tileCoord, state, urlTileCoord, getSourceTiles){
        super(tileCoord, state, {
            transition: 0
        });
        /**
     * @private
     * @type {!Object<string, CanvasRenderingContext2D>}
     */ this.context_ = {};
        /**
     * Executor groups by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */ this.executorGroups = {};
        /**
     * Executor groups for decluttering, by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */ this.declutterExecutorGroups = {};
        /**
     * Number of loading source tiles. Read/written by the source.
     * @type {number}
     */ this.loadingSourceTiles = 0;
        /**
     * @type {Object<number, ImageData>}
     */ this.hitDetectionImageData = {};
        /**
     * @private
     * @type {!Object<string, ReplayState>}
     */ this.replayState_ = {};
        /**
     * @type {Array<import("./VectorTile.js").default>}
     */ this.sourceTiles = [];
        /**
     * @type {Object<string, boolean>}
     */ this.errorTileKeys = {};
        /**
     * @type {number}
     */ this.wantedResolution;
        /**
     * @type {!function():Array<import("./VectorTile.js").default>}
     */ this.getSourceTiles = getSourceTiles.bind(undefined, this);
        /**
     * @type {import("./tilecoord.js").TileCoord}
     */ this.wrappedTileCoord = urlTileCoord;
    }
    /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */ getContext(layer) {
        const key = (0, _utilJs.getUid)(layer);
        if (!(key in this.context_)) this.context_[key] = (0, _domJs.createCanvasContext2D)(1, 1, canvasPool);
        return this.context_[key];
    }
    /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */ hasContext(layer) {
        return (0, _utilJs.getUid)(layer) in this.context_;
    }
    /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */ getImage(layer) {
        return this.hasContext(layer) ? this.getContext(layer).canvas : null;
    }
    /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */ getReplayState(layer) {
        const key = (0, _utilJs.getUid)(layer);
        if (!(key in this.replayState_)) this.replayState_[key] = {
            dirty: false,
            renderedRenderOrder: null,
            renderedResolution: NaN,
            renderedRevision: -1,
            renderedTileResolution: NaN,
            renderedTileRevision: -1,
            renderedTileZ: -1
        };
        return this.replayState_[key];
    }
    /**
   * Load the tile.
   */ load() {
        this.getSourceTiles();
    }
    /**
   * Remove from the cache due to expiry
   */ release() {
        for(const key in this.context_){
            const context = this.context_[key];
            (0, _domJs.releaseCanvas)(context);
            canvasPool.push(context.canvas);
            delete this.context_[key];
        }
        super.release();
    }
}
exports.default = VectorRenderTile;

},{"./Tile.js":"4sqb5","./dom.js":"84QzQ","./util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["b5D61","fLDlt"], "fLDlt", "parcelRequire8f80")

//# sourceMappingURL=index.ef63603e.js.map
